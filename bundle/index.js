// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.

// This is a specialised implementation of a System module loader.

"use strict";

// @ts-nocheck
/* eslint-disable */
let System, __instantiate;
(() => {
  const r = new Map();

  System = {
    register(id, d, f) {
      r.set(id, { d, f, exp: {} });
    },
  };
  async function dI(mid, src) {
    let id = mid.replace(/\.\w+$/i, "");
    if (id.includes("./")) {
      const [o, ...ia] = id.split("/").reverse(),
        [, ...sa] = src.split("/").reverse(),
        oa = [o];
      let s = 0,
        i;
      while ((i = ia.shift())) {
        if (i === "..") s++;
        else if (i === ".") break;
        else oa.push(i);
      }
      if (s < sa.length) oa.push(...sa.slice(s));
      id = oa.reverse().join("/");
    }
    return r.has(id) ? gExpA(id) : import(mid);
  }

  function gC(id, main) {
    return {
      id,
      import: (m) => dI(m, id),
      meta: { url: id, main },
    };
  }

  function gE(exp) {
    return (id, v) => {
      const e = typeof id === "string" ? { [id]: v } : id;
      for (const [id, value] of Object.entries(e)) {
        Object.defineProperty(exp, id, {
          value,
          writable: true,
          enumerable: true,
        });
      }
      return v;
    };
  }

  function rF(main) {
    for (const [id, m] of r.entries()) {
      const { f, exp } = m;
      const { execute: e, setters: s } = f(gE(exp), gC(id, id === main));
      delete m.f;
      m.e = e;
      m.s = s;
    }
  }

  async function gExpA(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](await gExpA(d[i]));
      const r = e();
      if (r) await r;
    }
    return m.exp;
  }

  function gExp(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](gExp(d[i]));
      e();
    }
    return m.exp;
  }
  __instantiate = (m, a) => {
    System = __instantiate = undefined;
    rF(m);
    return a ? gExpA(m) : gExp(m);
  };
})();

System.register("https://deno.land/std@0.74.0/fmt/colors", [], function (exports_1, context_1) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_1 && context_1.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_1("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_1("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_1("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_1("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_1("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_1("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_1("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_1("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_1("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_1("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_1("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_1("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_1("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_1("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_1("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_1("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_1("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_1("white", white);
    function gray(str) {
        return brightBlack(str);
    }
    exports_1("gray", gray);
    function brightBlack(str) {
        return run(str, code([90], 39));
    }
    exports_1("brightBlack", brightBlack);
    function brightRed(str) {
        return run(str, code([91], 39));
    }
    exports_1("brightRed", brightRed);
    function brightGreen(str) {
        return run(str, code([92], 39));
    }
    exports_1("brightGreen", brightGreen);
    function brightYellow(str) {
        return run(str, code([93], 39));
    }
    exports_1("brightYellow", brightYellow);
    function brightBlue(str) {
        return run(str, code([94], 39));
    }
    exports_1("brightBlue", brightBlue);
    function brightMagenta(str) {
        return run(str, code([95], 39));
    }
    exports_1("brightMagenta", brightMagenta);
    function brightCyan(str) {
        return run(str, code([96], 39));
    }
    exports_1("brightCyan", brightCyan);
    function brightWhite(str) {
        return run(str, code([97], 39));
    }
    exports_1("brightWhite", brightWhite);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_1("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_1("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_1("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_1("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_1("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_1("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_1("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_1("bgWhite", bgWhite);
    function bgBrightBlack(str) {
        return run(str, code([100], 49));
    }
    exports_1("bgBrightBlack", bgBrightBlack);
    function bgBrightRed(str) {
        return run(str, code([101], 49));
    }
    exports_1("bgBrightRed", bgBrightRed);
    function bgBrightGreen(str) {
        return run(str, code([102], 49));
    }
    exports_1("bgBrightGreen", bgBrightGreen);
    function bgBrightYellow(str) {
        return run(str, code([103], 49));
    }
    exports_1("bgBrightYellow", bgBrightYellow);
    function bgBrightBlue(str) {
        return run(str, code([104], 49));
    }
    exports_1("bgBrightBlue", bgBrightBlue);
    function bgBrightMagenta(str) {
        return run(str, code([105], 49));
    }
    exports_1("bgBrightMagenta", bgBrightMagenta);
    function bgBrightCyan(str) {
        return run(str, code([106], 49));
    }
    exports_1("bgBrightCyan", bgBrightCyan);
    function bgBrightWhite(str) {
        return run(str, code([107], 49));
    }
    exports_1("bgBrightWhite", bgBrightWhite);
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_1("rgb8", rgb8);
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_1("bgRgb8", bgRgb8);
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_1("rgb24", rgb24);
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_1("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_1("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
System.register("https://deno.land/std@0.73.0/bytes/mod", [], function (exports_2, context_2) {
    "use strict";
    var __moduleName = context_2 && context_2.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_2("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_2("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_2("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_2("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_2("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_2("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_2("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_2("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_2("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/hash/sha1", [], function (exports_3, context_3) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, blocks, Sha1;
    var __moduleName = context_3 && context_3.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            blocks = [];
            Sha1 = class Sha1 {
                constructor(sharedMemory = false) {
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#lastByteIndex = 0;
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                }
                #blocks;
                #block;
                #start;
                #bytes;
                #hBytes;
                #finalized;
                #hashed;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #lastByteIndex;
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 +
                                        (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) >>> 0;
                        this.#bytes = this.#bytes >>> 0;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f;
                    let j;
                    let t;
                    const blocks = this.#blocks;
                    for (j = 16; j < 80; ++j) {
                        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
                        blocks[j] = (t << 1) | (t >>> 31);
                    }
                    for (j = 0; j < 20; j += 5) {
                        f = (b & c) | (~b & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1518500249 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (~a & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1518500249 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (~e & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1518500249 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (~d & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1518500249 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (~c & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1518500249 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 40; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1859775393 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1859775393 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1859775393 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1859775393 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1859775393 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 60; j += 5) {
                        f = (b & c) | (b & d) | (c & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 1894007588 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (a & c) | (b & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 1894007588 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (e & b) | (a & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 1894007588 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (d & a) | (e & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 1894007588 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (c & e) | (d & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 1894007588 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 80; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 899497514 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 899497514 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 899497514 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 899497514 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 899497514 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    this.#h0 = (this.#h0 + a) >>> 0;
                    this.#h1 = (this.#h1 + b) >>> 0;
                    this.#h2 = (this.#h2 + c) >>> 0;
                    this.#h3 = (this.#h3 + d) >>> 0;
                    this.#h4 = (this.#h4 + e) >>> 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return (HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f]);
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                    ];
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(20);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    return buffer;
                }
            };
            exports_3("Sha1", Sha1);
        }
    };
});
System.register("https://deno.land/std@0.73.0/hash/sha256", [], function (exports_4, context_4) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha256, HmacSha256;
    var __moduleName = context_4 && context_4.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
                0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
                0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
                0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
                0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
                0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
            blocks = [];
            Sha256 = class Sha256 {
                constructor(is224 = false, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(is224, sharedMemory);
                }
                #block;
                #blocks;
                #bytes;
                #finalized;
                #first;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #h5;
                #h6;
                #h7;
                #hashed;
                #hBytes;
                #is224;
                #lastByteIndex;
                #start;
                init(is224, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (is224) {
                        this.#h0 = 0xc1059ed8;
                        this.#h1 = 0x367cd507;
                        this.#h2 = 0x3070dd17;
                        this.#h3 = 0xf70e5939;
                        this.#h4 = 0xffc00b31;
                        this.#h5 = 0x68581511;
                        this.#h6 = 0x64f98fa7;
                        this.#h7 = 0xbefa4fa4;
                    }
                    else {
                        this.#h0 = 0x6a09e667;
                        this.#h1 = 0xbb67ae85;
                        this.#h2 = 0x3c6ef372;
                        this.#h3 = 0xa54ff53a;
                        this.#h4 = 0x510e527f;
                        this.#h5 = 0x9b05688c;
                        this.#h6 = 0x1f83d9ab;
                        this.#h7 = 0x5be0cd19;
                    }
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                    this.#first = true;
                    this.#is224 = is224;
                }
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 +
                                        (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f = this.#h5;
                    let g = this.#h6;
                    let h = this.#h7;
                    const blocks = this.#blocks;
                    let s0;
                    let s1;
                    let maj;
                    let t1;
                    let t2;
                    let ch;
                    let ab;
                    let da;
                    let cd;
                    let bc;
                    for (let j = 16; j < 64; ++j) {
                        t1 = blocks[j - 15];
                        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
                        t1 = blocks[j - 2];
                        s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^
                            (t1 >>> 10);
                        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
                    }
                    bc = b & c;
                    for (let j = 0; j < 64; j += 4) {
                        if (this.#first) {
                            if (this.#is224) {
                                ab = 300032;
                                t1 = blocks[0] - 1413257819;
                                h = (t1 - 150054599) << 0;
                                d = (t1 + 24177077) << 0;
                            }
                            else {
                                ab = 704751109;
                                t1 = blocks[0] - 210244248;
                                h = (t1 - 1521486534) << 0;
                                d = (t1 + 143694565) << 0;
                            }
                            this.#first = false;
                        }
                        else {
                            s0 = ((a >>> 2) | (a << 30)) ^
                                ((a >>> 13) | (a << 19)) ^
                                ((a >>> 22) | (a << 10));
                            s1 = ((e >>> 6) | (e << 26)) ^
                                ((e >>> 11) | (e << 21)) ^
                                ((e >>> 25) | (e << 7));
                            ab = a & b;
                            maj = ab ^ (a & c) ^ bc;
                            ch = (e & f) ^ (~e & g);
                            t1 = h + s1 + ch + K[j] + blocks[j];
                            t2 = s0 + maj;
                            h = (d + t1) << 0;
                            d = (t1 + t2) << 0;
                        }
                        s0 = ((d >>> 2) | (d << 30)) ^
                            ((d >>> 13) | (d << 19)) ^
                            ((d >>> 22) | (d << 10));
                        s1 = ((h >>> 6) | (h << 26)) ^
                            ((h >>> 11) | (h << 21)) ^
                            ((h >>> 25) | (h << 7));
                        da = d & a;
                        maj = da ^ (d & b) ^ ab;
                        ch = (h & e) ^ (~h & f);
                        t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
                        t2 = s0 + maj;
                        g = (c + t1) << 0;
                        c = (t1 + t2) << 0;
                        s0 = ((c >>> 2) | (c << 30)) ^
                            ((c >>> 13) | (c << 19)) ^
                            ((c >>> 22) | (c << 10));
                        s1 = ((g >>> 6) | (g << 26)) ^
                            ((g >>> 11) | (g << 21)) ^
                            ((g >>> 25) | (g << 7));
                        cd = c & d;
                        maj = cd ^ (c & a) ^ da;
                        ch = (g & h) ^ (~g & e);
                        t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
                        t2 = s0 + maj;
                        f = (b + t1) << 0;
                        b = (t1 + t2) << 0;
                        s0 = ((b >>> 2) | (b << 30)) ^
                            ((b >>> 13) | (b << 19)) ^
                            ((b >>> 22) | (b << 10));
                        s1 = ((f >>> 6) | (f << 26)) ^
                            ((f >>> 11) | (f << 21)) ^
                            ((f >>> 25) | (f << 7));
                        bc = b & c;
                        maj = bc ^ (b & d) ^ cd;
                        ch = (f & g) ^ (~f & h);
                        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
                        t2 = s0 + maj;
                        e = (a + t1) << 0;
                        a = (t1 + t2) << 0;
                    }
                    this.#h0 = (this.#h0 + a) << 0;
                    this.#h1 = (this.#h1 + b) << 0;
                    this.#h2 = (this.#h2 + c) << 0;
                    this.#h3 = (this.#h3 + d) << 0;
                    this.#h4 = (this.#h4 + e) << 0;
                    this.#h5 = (this.#h5 + f) << 0;
                    this.#h6 = (this.#h6 + g) << 0;
                    this.#h7 = (this.#h7 + h) << 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    let hex = HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f] +
                        HEX_CHARS[(h5 >> 28) & 0x0f] +
                        HEX_CHARS[(h5 >> 24) & 0x0f] +
                        HEX_CHARS[(h5 >> 20) & 0x0f] +
                        HEX_CHARS[(h5 >> 16) & 0x0f] +
                        HEX_CHARS[(h5 >> 12) & 0x0f] +
                        HEX_CHARS[(h5 >> 8) & 0x0f] +
                        HEX_CHARS[(h5 >> 4) & 0x0f] +
                        HEX_CHARS[h5 & 0x0f] +
                        HEX_CHARS[(h6 >> 28) & 0x0f] +
                        HEX_CHARS[(h6 >> 24) & 0x0f] +
                        HEX_CHARS[(h6 >> 20) & 0x0f] +
                        HEX_CHARS[(h6 >> 16) & 0x0f] +
                        HEX_CHARS[(h6 >> 12) & 0x0f] +
                        HEX_CHARS[(h6 >> 8) & 0x0f] +
                        HEX_CHARS[(h6 >> 4) & 0x0f] +
                        HEX_CHARS[h6 & 0x0f];
                    if (!this.#is224) {
                        hex += HEX_CHARS[(h7 >> 28) & 0x0f] +
                            HEX_CHARS[(h7 >> 24) & 0x0f] +
                            HEX_CHARS[(h7 >> 20) & 0x0f] +
                            HEX_CHARS[(h7 >> 16) & 0x0f] +
                            HEX_CHARS[(h7 >> 12) & 0x0f] +
                            HEX_CHARS[(h7 >> 8) & 0x0f] +
                            HEX_CHARS[(h7 >> 4) & 0x0f] +
                            HEX_CHARS[h7 & 0x0f];
                    }
                    return hex;
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    const arr = [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                        (h5 >> 24) & 0xff,
                        (h5 >> 16) & 0xff,
                        (h5 >> 8) & 0xff,
                        h5 & 0xff,
                        (h6 >> 24) & 0xff,
                        (h6 >> 16) & 0xff,
                        (h6 >> 8) & 0xff,
                        h6 & 0xff,
                    ];
                    if (!this.#is224) {
                        arr.push((h7 >> 24) & 0xff, (h7 >> 16) & 0xff, (h7 >> 8) & 0xff, h7 & 0xff);
                    }
                    return arr;
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(this.#is224 ? 28 : 32);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    dataView.setUint32(20, this.#h5);
                    dataView.setUint32(24, this.#h6);
                    if (!this.#is224) {
                        dataView.setUint32(28, this.#h7);
                    }
                    return buffer;
                }
            };
            exports_4("Sha256", Sha256);
            HmacSha256 = class HmacSha256 extends Sha256 {
                constructor(secretKey, is224 = false, sharedMemory = false) {
                    super(is224, sharedMemory);
                    let key;
                    if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        for (let i = 0; i < length; ++i) {
                            let code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code = 0x10000 +
                                    (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        if (secretKey instanceof ArrayBuffer) {
                            key = new Uint8Array(secretKey);
                        }
                        else {
                            key = secretKey;
                        }
                    }
                    if (key.length > 64) {
                        key = new Sha256(is224, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 64; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#oKeyPad = oKeyPad;
                    this.#inner = true;
                    this.#is224 = is224;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #is224;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#is224, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_4("HmacSha256", HmacSha256);
        }
    };
});
System.register("https://deno.land/std@0.73.0/encoding/utf8", [], function (exports_5, context_5) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_5 && context_5.id;
    function encode(input) {
        return encoder.encode(input);
    }
    exports_5("encode", encode);
    function decode(input) {
        return decoder.decode(input);
    }
    exports_5("decode", decode);
    return {
        setters: [],
        execute: function () {
            exports_5("encoder", encoder = new TextEncoder());
            exports_5("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/std@0.73.0/_util/assert", [], function (exports_6, context_6) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_6 && context_6.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_6("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_6("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/std@0.73.0/io/bufio", ["https://deno.land/std@0.73.0/bytes/mod", "https://deno.land/std@0.73.0/_util/assert"], function (exports_7, context_7) {
    "use strict";
    var mod_ts_1, assert_ts_1, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_7 && context_7.id;
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    async function* readDelim(reader, delim) {
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_7("readDelim", readDelim);
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_7("readStringDelim", readStringDelim);
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_7("readLines", readLines);
    return {
        setters: [
            function (mod_ts_1_1) {
                mod_ts_1 = mod_ts_1_1;
            },
            function (assert_ts_1_1) {
                assert_ts_1 = assert_ts_1_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_7("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_7("PartialReadError", PartialReadError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0;
                    this.w = 0;
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                async _fill() {
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_1.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                }
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_1.assert(nread >= 0, "negative read");
                            return rr;
                        }
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_1.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    const copied = mod_ts_1.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    return copied;
                }
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill();
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    return c;
                }
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_1.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            assert_ts_1.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r;
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_7("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                size() {
                    return this.buf.byteLength;
                }
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                buffered() {
                    return this.usedBufferBytes;
                }
            };
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_7("BufWriter", BufWriter);
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_1.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_7("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/deferred", [], function (exports_8, context_8) {
    "use strict";
    var __moduleName = context_8 && context_8.id;
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_8("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/delay", [], function (exports_9, context_9) {
    "use strict";
    var __moduleName = context_9 && context_9.id;
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_9("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/mux_async_iterator", ["https://deno.land/std@0.73.0/async/deferred"], function (exports_10, context_10) {
    "use strict";
    var deferred_ts_1, MuxAsyncIterator;
    var __moduleName = context_10 && context_10.id;
    return {
        setters: [
            function (deferred_ts_1_1) {
                deferred_ts_1 = deferred_ts_1_1;
            }
        ],
        execute: function () {
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.throws = [];
                    this.signal = deferred_ts_1.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    try {
                        const { value, done } = await iterator.next();
                        if (done) {
                            --this.iteratorCount;
                        }
                        else {
                            this.yields.push({ iterator, value });
                        }
                    }
                    catch (e) {
                        this.throws.push(e);
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        await this.signal;
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        if (this.throws.length) {
                            for (const e of this.throws) {
                                throw e;
                            }
                            this.throws.length = 0;
                        }
                        this.yields.length = 0;
                        this.signal = deferred_ts_1.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_10("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/pool", [], function (exports_11, context_11) {
    "use strict";
    var __moduleName = context_11 && context_11.id;
    function pooledMap(poolLimit, array, iteratorFn) {
        const res = new TransformStream({
            async transform(p, controller) {
                controller.enqueue(await p);
            },
        });
        (async () => {
            const writer = res.writable.getWriter();
            const executing = [];
            for await (const item of array) {
                const p = Promise.resolve().then(() => iteratorFn(item));
                writer.write(p);
                const e = p.then(() => executing.splice(executing.indexOf(e), 1));
                executing.push(e);
                if (executing.length >= poolLimit) {
                    await Promise.race(executing);
                }
            }
            await Promise.all(executing);
            writer.close();
        })();
        return res.readable.getIterator();
    }
    exports_11("pooledMap", pooledMap);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/async/mod", ["https://deno.land/std@0.73.0/async/deferred", "https://deno.land/std@0.73.0/async/delay", "https://deno.land/std@0.73.0/async/mux_async_iterator", "https://deno.land/std@0.73.0/async/pool"], function (exports_12, context_12) {
    "use strict";
    var __moduleName = context_12 && context_12.id;
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_12(exports);
    }
    return {
        setters: [
            function (deferred_ts_2_1) {
                exportStar_1(deferred_ts_2_1);
            },
            function (delay_ts_1_1) {
                exportStar_1(delay_ts_1_1);
            },
            function (mux_async_iterator_ts_1_1) {
                exportStar_1(mux_async_iterator_ts_1_1);
            },
            function (pool_ts_1_1) {
                exportStar_1(pool_ts_1_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/textproto/mod", ["https://deno.land/std@0.73.0/bytes/mod", "https://deno.land/std@0.73.0/encoding/utf8"], function (exports_13, context_13) {
    "use strict";
    var mod_ts_2, utf8_ts_1, invalidHeaderCharRegex, TextProtoReader;
    var __moduleName = context_13 && context_13.id;
    function str(buf) {
        if (buf == null) {
            return "";
        }
        else {
            return utf8_ts_1.decode(buf);
        }
    }
    function charCode(s) {
        return s.charCodeAt(0);
    }
    return {
        setters: [
            function (mod_ts_2_1) {
                mod_ts_2 = mod_ts_2_1;
            },
            function (utf8_ts_1_1) {
                utf8_ts_1 = utf8_ts_1_1;
            }
        ],
        execute: function () {
            invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
            TextProtoReader = class TextProtoReader {
                constructor(r) {
                    this.r = r;
                }
                async readLine() {
                    const s = await this.readLineSlice();
                    if (s === null)
                        return null;
                    return str(s);
                }
                async readMIMEHeader() {
                    const m = new Headers();
                    let line;
                    let buf = await this.r.peek(1);
                    if (buf === null) {
                        return null;
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        line = (await this.readLineSlice());
                    }
                    buf = await this.r.peek(1);
                    if (buf === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {
                        throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
                    }
                    while (true) {
                        const kv = await this.readLineSlice();
                        if (kv === null)
                            throw new Deno.errors.UnexpectedEof();
                        if (kv.byteLength === 0)
                            return m;
                        let i = kv.indexOf(charCode(":"));
                        if (i < 0) {
                            throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
                        }
                        const key = str(kv.subarray(0, i));
                        if (key == "") {
                            continue;
                        }
                        i++;
                        while (i < kv.byteLength &&
                            (kv[i] == charCode(" ") || kv[i] == charCode("\t"))) {
                            i++;
                        }
                        const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
                        try {
                            m.append(key, value);
                        }
                        catch {
                        }
                    }
                }
                async readLineSlice() {
                    let line;
                    while (true) {
                        const r = await this.r.readLine();
                        if (r === null)
                            return null;
                        const { line: l, more } = r;
                        if (!line && !more) {
                            if (this.skipSpace(l) === 0) {
                                return new Uint8Array(0);
                            }
                            return l;
                        }
                        line = line ? mod_ts_2.concat(line, l) : l;
                        if (!more) {
                            break;
                        }
                    }
                    return line;
                }
                skipSpace(l) {
                    let n = 0;
                    for (let i = 0; i < l.length; i++) {
                        if (l[i] === charCode(" ") || l[i] === charCode("\t")) {
                            continue;
                        }
                        n++;
                    }
                    return n;
                }
            };
            exports_13("TextProtoReader", TextProtoReader);
        }
    };
});
System.register("https://deno.land/std@0.73.0/http/http_status", [], function (exports_14, context_14) {
    "use strict";
    var Status, STATUS_TEXT;
    var __moduleName = context_14 && context_14.id;
    return {
        setters: [],
        execute: function () {
            (function (Status) {
                Status[Status["Continue"] = 100] = "Continue";
                Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";
                Status[Status["Processing"] = 102] = "Processing";
                Status[Status["EarlyHints"] = 103] = "EarlyHints";
                Status[Status["OK"] = 200] = "OK";
                Status[Status["Created"] = 201] = "Created";
                Status[Status["Accepted"] = 202] = "Accepted";
                Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
                Status[Status["NoContent"] = 204] = "NoContent";
                Status[Status["ResetContent"] = 205] = "ResetContent";
                Status[Status["PartialContent"] = 206] = "PartialContent";
                Status[Status["MultiStatus"] = 207] = "MultiStatus";
                Status[Status["AlreadyReported"] = 208] = "AlreadyReported";
                Status[Status["IMUsed"] = 226] = "IMUsed";
                Status[Status["MultipleChoices"] = 300] = "MultipleChoices";
                Status[Status["MovedPermanently"] = 301] = "MovedPermanently";
                Status[Status["Found"] = 302] = "Found";
                Status[Status["SeeOther"] = 303] = "SeeOther";
                Status[Status["NotModified"] = 304] = "NotModified";
                Status[Status["UseProxy"] = 305] = "UseProxy";
                Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";
                Status[Status["BadRequest"] = 400] = "BadRequest";
                Status[Status["Unauthorized"] = 401] = "Unauthorized";
                Status[Status["PaymentRequired"] = 402] = "PaymentRequired";
                Status[Status["Forbidden"] = 403] = "Forbidden";
                Status[Status["NotFound"] = 404] = "NotFound";
                Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                Status[Status["NotAcceptable"] = 406] = "NotAcceptable";
                Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
                Status[Status["RequestTimeout"] = 408] = "RequestTimeout";
                Status[Status["Conflict"] = 409] = "Conflict";
                Status[Status["Gone"] = 410] = "Gone";
                Status[Status["LengthRequired"] = 411] = "LengthRequired";
                Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";
                Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
                Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";
                Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
                Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
                Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";
                Status[Status["Teapot"] = 418] = "Teapot";
                Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";
                Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";
                Status[Status["Locked"] = 423] = "Locked";
                Status[Status["FailedDependency"] = 424] = "FailedDependency";
                Status[Status["TooEarly"] = 425] = "TooEarly";
                Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";
                Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";
                Status[Status["TooManyRequests"] = 429] = "TooManyRequests";
                Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
                Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
                Status[Status["InternalServerError"] = 500] = "InternalServerError";
                Status[Status["NotImplemented"] = 501] = "NotImplemented";
                Status[Status["BadGateway"] = 502] = "BadGateway";
                Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";
                Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
                Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
                Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";
                Status[Status["LoopDetected"] = 508] = "LoopDetected";
                Status[Status["NotExtended"] = 510] = "NotExtended";
                Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
            })(Status || (Status = {}));
            exports_14("Status", Status);
            exports_14("STATUS_TEXT", STATUS_TEXT = new Map([
                [Status.Continue, "Continue"],
                [Status.SwitchingProtocols, "Switching Protocols"],
                [Status.Processing, "Processing"],
                [Status.EarlyHints, "Early Hints"],
                [Status.OK, "OK"],
                [Status.Created, "Created"],
                [Status.Accepted, "Accepted"],
                [Status.NonAuthoritativeInfo, "Non-Authoritative Information"],
                [Status.NoContent, "No Content"],
                [Status.ResetContent, "Reset Content"],
                [Status.PartialContent, "Partial Content"],
                [Status.MultiStatus, "Multi-Status"],
                [Status.AlreadyReported, "Already Reported"],
                [Status.IMUsed, "IM Used"],
                [Status.MultipleChoices, "Multiple Choices"],
                [Status.MovedPermanently, "Moved Permanently"],
                [Status.Found, "Found"],
                [Status.SeeOther, "See Other"],
                [Status.NotModified, "Not Modified"],
                [Status.UseProxy, "Use Proxy"],
                [Status.TemporaryRedirect, "Temporary Redirect"],
                [Status.PermanentRedirect, "Permanent Redirect"],
                [Status.BadRequest, "Bad Request"],
                [Status.Unauthorized, "Unauthorized"],
                [Status.PaymentRequired, "Payment Required"],
                [Status.Forbidden, "Forbidden"],
                [Status.NotFound, "Not Found"],
                [Status.MethodNotAllowed, "Method Not Allowed"],
                [Status.NotAcceptable, "Not Acceptable"],
                [Status.ProxyAuthRequired, "Proxy Authentication Required"],
                [Status.RequestTimeout, "Request Timeout"],
                [Status.Conflict, "Conflict"],
                [Status.Gone, "Gone"],
                [Status.LengthRequired, "Length Required"],
                [Status.PreconditionFailed, "Precondition Failed"],
                [Status.RequestEntityTooLarge, "Request Entity Too Large"],
                [Status.RequestURITooLong, "Request URI Too Long"],
                [Status.UnsupportedMediaType, "Unsupported Media Type"],
                [Status.RequestedRangeNotSatisfiable, "Requested Range Not Satisfiable"],
                [Status.ExpectationFailed, "Expectation Failed"],
                [Status.Teapot, "I'm a teapot"],
                [Status.MisdirectedRequest, "Misdirected Request"],
                [Status.UnprocessableEntity, "Unprocessable Entity"],
                [Status.Locked, "Locked"],
                [Status.FailedDependency, "Failed Dependency"],
                [Status.TooEarly, "Too Early"],
                [Status.UpgradeRequired, "Upgrade Required"],
                [Status.PreconditionRequired, "Precondition Required"],
                [Status.TooManyRequests, "Too Many Requests"],
                [Status.RequestHeaderFieldsTooLarge, "Request Header Fields Too Large"],
                [Status.UnavailableForLegalReasons, "Unavailable For Legal Reasons"],
                [Status.InternalServerError, "Internal Server Error"],
                [Status.NotImplemented, "Not Implemented"],
                [Status.BadGateway, "Bad Gateway"],
                [Status.ServiceUnavailable, "Service Unavailable"],
                [Status.GatewayTimeout, "Gateway Timeout"],
                [Status.HTTPVersionNotSupported, "HTTP Version Not Supported"],
                [Status.VariantAlsoNegotiates, "Variant Also Negotiates"],
                [Status.InsufficientStorage, "Insufficient Storage"],
                [Status.LoopDetected, "Loop Detected"],
                [Status.NotExtended, "Not Extended"],
                [Status.NetworkAuthenticationRequired, "Network Authentication Required"],
            ]));
        }
    };
});
System.register("https://deno.land/std@0.73.0/http/_io", ["https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/textproto/mod", "https://deno.land/std@0.73.0/_util/assert", "https://deno.land/std@0.73.0/encoding/utf8", "https://deno.land/std@0.73.0/http/server", "https://deno.land/std@0.73.0/http/http_status"], function (exports_15, context_15) {
    "use strict";
    var bufio_ts_1, mod_ts_3, assert_ts_2, utf8_ts_2, server_ts_1, http_status_ts_1;
    var __moduleName = context_15 && context_15.id;
    function emptyReader() {
        return {
            read(_) {
                return Promise.resolve(null);
            },
        };
    }
    exports_15("emptyReader", emptyReader);
    function bodyReader(contentLength, r) {
        let totalRead = 0;
        let finished = false;
        async function read(buf) {
            if (finished)
                return null;
            let result;
            const remaining = contentLength - totalRead;
            if (remaining >= buf.byteLength) {
                result = await r.read(buf);
            }
            else {
                const readBuf = buf.subarray(0, remaining);
                result = await r.read(readBuf);
            }
            if (result !== null) {
                totalRead += result;
            }
            finished = totalRead === contentLength;
            return result;
        }
        return { read };
    }
    exports_15("bodyReader", bodyReader);
    function chunkedBodyReader(h, r) {
        const tp = new mod_ts_3.TextProtoReader(r);
        let finished = false;
        const chunks = [];
        async function read(buf) {
            if (finished)
                return null;
            const [chunk] = chunks;
            if (chunk) {
                const chunkRemaining = chunk.data.byteLength - chunk.offset;
                const readLength = Math.min(chunkRemaining, buf.byteLength);
                for (let i = 0; i < readLength; i++) {
                    buf[i] = chunk.data[chunk.offset + i];
                }
                chunk.offset += readLength;
                if (chunk.offset === chunk.data.byteLength) {
                    chunks.shift();
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                }
                return readLength;
            }
            const line = await tp.readLine();
            if (line === null)
                throw new Deno.errors.UnexpectedEof();
            const [chunkSizeString] = line.split(";");
            const chunkSize = parseInt(chunkSizeString, 16);
            if (Number.isNaN(chunkSize) || chunkSize < 0) {
                throw new Error("Invalid chunk size");
            }
            if (chunkSize > 0) {
                if (chunkSize > buf.byteLength) {
                    let eof = await r.readFull(buf);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                    eof = await r.readFull(restChunk);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else {
                        chunks.push({
                            offset: 0,
                            data: restChunk,
                        });
                    }
                    return buf.byteLength;
                }
                else {
                    const bufToFill = buf.subarray(0, chunkSize);
                    const eof = await r.readFull(bufToFill);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    return chunkSize;
                }
            }
            else {
                assert_ts_2.assert(chunkSize === 0);
                if ((await r.readLine()) === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                await readTrailers(h, r);
                finished = true;
                return null;
            }
        }
        return { read };
    }
    exports_15("chunkedBodyReader", chunkedBodyReader);
    function isProhibidedForTrailer(key) {
        const s = new Set(["transfer-encoding", "content-length", "trailer"]);
        return s.has(key.toLowerCase());
    }
    async function readTrailers(headers, r) {
        const trailers = parseTrailer(headers.get("trailer"));
        if (trailers == null)
            return;
        const trailerNames = [...trailers.keys()];
        const tp = new mod_ts_3.TextProtoReader(r);
        const result = await tp.readMIMEHeader();
        if (result == null) {
            throw new Deno.errors.InvalidData("Missing trailer header.");
        }
        const undeclared = [...result.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [k, v] of result) {
            headers.append(k, v);
        }
        const missingTrailers = trailerNames.filter((k) => !result.has(k));
        if (missingTrailers.length > 0) {
            throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
        }
        headers.delete("trailer");
    }
    exports_15("readTrailers", readTrailers);
    function parseTrailer(field) {
        if (field == null) {
            return undefined;
        }
        const trailerNames = field.split(",").map((v) => v.trim().toLowerCase());
        if (trailerNames.length === 0) {
            throw new Deno.errors.InvalidData("Empty trailer header.");
        }
        const prohibited = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibited.length > 0) {
            throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
        }
        return new Headers(trailerNames.map((key) => [key, ""]));
    }
    async function writeChunkedBody(w, r) {
        const writer = bufio_ts_1.BufWriter.create(w);
        for await (const chunk of Deno.iter(r)) {
            if (chunk.byteLength <= 0)
                continue;
            const start = utf8_ts_2.encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);
            const end = utf8_ts_2.encoder.encode("\r\n");
            await writer.write(start);
            await writer.write(chunk);
            await writer.write(end);
        }
        const endChunk = utf8_ts_2.encoder.encode("0\r\n\r\n");
        await writer.write(endChunk);
    }
    exports_15("writeChunkedBody", writeChunkedBody);
    async function writeTrailers(w, headers, trailers) {
        const trailer = headers.get("trailer");
        if (trailer === null) {
            throw new TypeError("Missing trailer header.");
        }
        const transferEncoding = headers.get("transfer-encoding");
        if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
            throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
        }
        const writer = bufio_ts_1.BufWriter.create(w);
        const trailerNames = trailer.split(",").map((s) => s.trim().toLowerCase());
        const prohibitedTrailers = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibitedTrailers.length > 0) {
            throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
        }
        const undeclared = [...trailers.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [key, value] of trailers) {
            await writer.write(utf8_ts_2.encoder.encode(`${key}: ${value}\r\n`));
        }
        await writer.write(utf8_ts_2.encoder.encode("\r\n"));
        await writer.flush();
    }
    exports_15("writeTrailers", writeTrailers);
    async function writeResponse(w, r) {
        const protoMajor = 1;
        const protoMinor = 1;
        const statusCode = r.status || 200;
        const statusText = http_status_ts_1.STATUS_TEXT.get(statusCode);
        const writer = bufio_ts_1.BufWriter.create(w);
        if (!statusText) {
            throw new Deno.errors.InvalidData("Bad status code");
        }
        if (!r.body) {
            r.body = new Uint8Array();
        }
        if (typeof r.body === "string") {
            r.body = utf8_ts_2.encoder.encode(r.body);
        }
        let out = `HTTP/${protoMajor}.${protoMinor} ${statusCode} ${statusText}\r\n`;
        const headers = r.headers ?? new Headers();
        if (r.body && !headers.get("content-length")) {
            if (r.body instanceof Uint8Array) {
                out += `content-length: ${r.body.byteLength}\r\n`;
            }
            else if (!headers.get("transfer-encoding")) {
                out += "transfer-encoding: chunked\r\n";
            }
        }
        for (const [key, value] of headers) {
            out += `${key}: ${value}\r\n`;
        }
        out += `\r\n`;
        const header = utf8_ts_2.encoder.encode(out);
        const n = await writer.write(header);
        assert_ts_2.assert(n === header.byteLength);
        if (r.body instanceof Uint8Array) {
            const n = await writer.write(r.body);
            assert_ts_2.assert(n === r.body.byteLength);
        }
        else if (headers.has("content-length")) {
            const contentLength = headers.get("content-length");
            assert_ts_2.assert(contentLength != null);
            const bodyLength = parseInt(contentLength);
            const n = await Deno.copy(r.body, writer);
            assert_ts_2.assert(n === bodyLength);
        }
        else {
            await writeChunkedBody(writer, r.body);
        }
        if (r.trailers) {
            const t = await r.trailers();
            await writeTrailers(writer, headers, t);
        }
        await writer.flush();
    }
    exports_15("writeResponse", writeResponse);
    function parseHTTPVersion(vers) {
        switch (vers) {
            case "HTTP/1.1":
                return [1, 1];
            case "HTTP/1.0":
                return [1, 0];
            default: {
                const Big = 1000000;
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > Big) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > Big) {
                    break;
                }
                return [major, minor];
            }
        }
        throw new Error(`malformed HTTP version ${vers}`);
    }
    exports_15("parseHTTPVersion", parseHTTPVersion);
    async function readRequest(conn, bufr) {
        const tp = new mod_ts_3.TextProtoReader(bufr);
        const firstLine = await tp.readLine();
        if (firstLine === null)
            return null;
        const headers = await tp.readMIMEHeader();
        if (headers === null)
            throw new Deno.errors.UnexpectedEof();
        const req = new server_ts_1.ServerRequest();
        req.conn = conn;
        req.r = bufr;
        [req.method, req.url, req.proto] = firstLine.split(" ", 3);
        [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);
        req.headers = headers;
        fixLength(req);
        return req;
    }
    exports_15("readRequest", readRequest);
    function fixLength(req) {
        const contentLength = req.headers.get("Content-Length");
        if (contentLength) {
            const arrClen = contentLength.split(",");
            if (arrClen.length > 1) {
                const distinct = [...new Set(arrClen.map((e) => e.trim()))];
                if (distinct.length > 1) {
                    throw Error("cannot contain multiple Content-Length headers");
                }
                else {
                    req.headers.set("Content-Length", distinct[0]);
                }
            }
            const c = req.headers.get("Content-Length");
            if (req.method === "HEAD" && c && c !== "0") {
                throw Error("http: method cannot contain a Content-Length");
            }
            if (c && req.headers.has("transfer-encoding")) {
                throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
            }
        }
    }
    return {
        setters: [
            function (bufio_ts_1_1) {
                bufio_ts_1 = bufio_ts_1_1;
            },
            function (mod_ts_3_1) {
                mod_ts_3 = mod_ts_3_1;
            },
            function (assert_ts_2_1) {
                assert_ts_2 = assert_ts_2_1;
            },
            function (utf8_ts_2_1) {
                utf8_ts_2 = utf8_ts_2_1;
            },
            function (server_ts_1_1) {
                server_ts_1 = server_ts_1_1;
            },
            function (http_status_ts_1_1) {
                http_status_ts_1 = http_status_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/http/server", ["https://deno.land/std@0.73.0/encoding/utf8", "https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/_util/assert", "https://deno.land/std@0.73.0/async/mod", "https://deno.land/std@0.73.0/http/_io"], function (exports_16, context_16) {
    "use strict";
    var utf8_ts_3, bufio_ts_2, assert_ts_3, mod_ts_4, _io_ts_1, ServerRequest, Server;
    var __moduleName = context_16 && context_16.id;
    function _parseAddrFromStr(addr) {
        let url;
        try {
            const host = addr.startsWith(":") ? `0.0.0.0${addr}` : addr;
            url = new URL(`http://${host}`);
        }
        catch {
            throw new TypeError("Invalid address.");
        }
        if (url.username ||
            url.password ||
            url.pathname != "/" ||
            url.search ||
            url.hash) {
            throw new TypeError("Invalid address.");
        }
        return {
            hostname: url.hostname,
            port: url.port === "" ? 80 : Number(url.port),
        };
    }
    exports_16("_parseAddrFromStr", _parseAddrFromStr);
    function serve(addr) {
        if (typeof addr === "string") {
            addr = _parseAddrFromStr(addr);
        }
        const listener = Deno.listen(addr);
        return new Server(listener);
    }
    exports_16("serve", serve);
    async function listenAndServe(addr, handler) {
        const server = serve(addr);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_16("listenAndServe", listenAndServe);
    function serveTLS(options) {
        const tlsOptions = {
            ...options,
            transport: "tcp",
        };
        const listener = Deno.listenTls(tlsOptions);
        return new Server(listener);
    }
    exports_16("serveTLS", serveTLS);
    async function listenAndServeTLS(options, handler) {
        const server = serveTLS(options);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_16("listenAndServeTLS", listenAndServeTLS);
    return {
        setters: [
            function (utf8_ts_3_1) {
                utf8_ts_3 = utf8_ts_3_1;
            },
            function (bufio_ts_2_1) {
                bufio_ts_2 = bufio_ts_2_1;
            },
            function (assert_ts_3_1) {
                assert_ts_3 = assert_ts_3_1;
            },
            function (mod_ts_4_1) {
                mod_ts_4 = mod_ts_4_1;
            },
            function (_io_ts_1_1) {
                _io_ts_1 = _io_ts_1_1;
            }
        ],
        execute: function () {
            ServerRequest = class ServerRequest {
                constructor() {
                    this.done = mod_ts_4.deferred();
                    this._contentLength = undefined;
                    this._body = null;
                    this.finalized = false;
                }
                get contentLength() {
                    if (this._contentLength === undefined) {
                        const cl = this.headers.get("content-length");
                        if (cl) {
                            this._contentLength = parseInt(cl);
                            if (Number.isNaN(this._contentLength)) {
                                this._contentLength = null;
                            }
                        }
                        else {
                            this._contentLength = null;
                        }
                    }
                    return this._contentLength;
                }
                get body() {
                    if (!this._body) {
                        if (this.contentLength != null) {
                            this._body = _io_ts_1.bodyReader(this.contentLength, this.r);
                        }
                        else {
                            const transferEncoding = this.headers.get("transfer-encoding");
                            if (transferEncoding != null) {
                                const parts = transferEncoding
                                    .split(",")
                                    .map((e) => e.trim().toLowerCase());
                                assert_ts_3.assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                                this._body = _io_ts_1.chunkedBodyReader(this.headers, this.r);
                            }
                            else {
                                this._body = _io_ts_1.emptyReader();
                            }
                        }
                    }
                    return this._body;
                }
                async respond(r) {
                    let err;
                    try {
                        await _io_ts_1.writeResponse(this.w, r);
                    }
                    catch (e) {
                        try {
                            this.conn.close();
                        }
                        catch {
                        }
                        err = e;
                    }
                    this.done.resolve(err);
                    if (err) {
                        throw err;
                    }
                }
                async finalize() {
                    if (this.finalized)
                        return;
                    const body = this.body;
                    const buf = new Uint8Array(1024);
                    while ((await body.read(buf)) !== null) {
                    }
                    this.finalized = true;
                }
            };
            exports_16("ServerRequest", ServerRequest);
            Server = class Server {
                constructor(listener) {
                    this.listener = listener;
                    this.closing = false;
                    this.connections = [];
                }
                close() {
                    this.closing = true;
                    this.listener.close();
                    for (const conn of this.connections) {
                        try {
                            conn.close();
                        }
                        catch (e) {
                            if (!(e instanceof Deno.errors.BadResource)) {
                                throw e;
                            }
                        }
                    }
                }
                async *iterateHttpRequests(conn) {
                    const reader = new bufio_ts_2.BufReader(conn);
                    const writer = new bufio_ts_2.BufWriter(conn);
                    while (!this.closing) {
                        let request;
                        try {
                            request = await _io_ts_1.readRequest(conn, reader);
                        }
                        catch (error) {
                            if (error instanceof Deno.errors.InvalidData ||
                                error instanceof Deno.errors.UnexpectedEof) {
                                await _io_ts_1.writeResponse(writer, {
                                    status: 400,
                                    body: utf8_ts_3.encode(`${error.message}\r\n\r\n`),
                                });
                            }
                            break;
                        }
                        if (request === null) {
                            break;
                        }
                        request.w = writer;
                        yield request;
                        const responseError = await request.done;
                        if (responseError) {
                            this.untrackConnection(request.conn);
                            return;
                        }
                        await request.finalize();
                    }
                    this.untrackConnection(conn);
                    try {
                        conn.close();
                    }
                    catch (e) {
                    }
                }
                trackConnection(conn) {
                    this.connections.push(conn);
                }
                untrackConnection(conn) {
                    const index = this.connections.indexOf(conn);
                    if (index !== -1) {
                        this.connections.splice(index, 1);
                    }
                }
                async *acceptConnAndIterateHttpRequests(mux) {
                    if (this.closing)
                        return;
                    let conn;
                    try {
                        conn = await this.listener.accept();
                    }
                    catch (error) {
                        if (error instanceof Deno.errors.BadResource ||
                            error instanceof Deno.errors.InvalidData ||
                            error instanceof Deno.errors.UnexpectedEof) {
                            return mux.add(this.acceptConnAndIterateHttpRequests(mux));
                        }
                        throw error;
                    }
                    this.trackConnection(conn);
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    yield* this.iterateHttpRequests(conn);
                }
                [Symbol.asyncIterator]() {
                    const mux = new mod_ts_4.MuxAsyncIterator();
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    return mux.iterate();
                }
            };
            exports_16("Server", Server);
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/_constants", [], function (exports_17, context_17) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, NATIVE_OS, navigator, isWindows;
    var __moduleName = context_17 && context_17.id;
    return {
        setters: [],
        execute: function () {
            exports_17("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65);
            exports_17("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97);
            exports_17("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90);
            exports_17("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122);
            exports_17("CHAR_DOT", CHAR_DOT = 46);
            exports_17("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47);
            exports_17("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92);
            exports_17("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124);
            exports_17("CHAR_COLON", CHAR_COLON = 58);
            exports_17("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63);
            exports_17("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95);
            exports_17("CHAR_LINE_FEED", CHAR_LINE_FEED = 10);
            exports_17("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13);
            exports_17("CHAR_TAB", CHAR_TAB = 9);
            exports_17("CHAR_FORM_FEED", CHAR_FORM_FEED = 12);
            exports_17("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33);
            exports_17("CHAR_HASH", CHAR_HASH = 35);
            exports_17("CHAR_SPACE", CHAR_SPACE = 32);
            exports_17("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160);
            exports_17("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279);
            exports_17("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91);
            exports_17("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93);
            exports_17("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60);
            exports_17("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62);
            exports_17("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123);
            exports_17("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125);
            exports_17("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45);
            exports_17("CHAR_PLUS", CHAR_PLUS = 43);
            exports_17("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34);
            exports_17("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39);
            exports_17("CHAR_PERCENT", CHAR_PERCENT = 37);
            exports_17("CHAR_SEMICOLON", CHAR_SEMICOLON = 59);
            exports_17("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94);
            exports_17("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96);
            exports_17("CHAR_AT", CHAR_AT = 64);
            exports_17("CHAR_AMPERSAND", CHAR_AMPERSAND = 38);
            exports_17("CHAR_EQUAL", CHAR_EQUAL = 61);
            exports_17("CHAR_0", CHAR_0 = 48);
            exports_17("CHAR_9", CHAR_9 = 57);
            NATIVE_OS = "linux";
            exports_17("NATIVE_OS", NATIVE_OS);
            navigator = globalThis.navigator;
            if (globalThis.Deno != null) {
                exports_17("NATIVE_OS", NATIVE_OS = Deno.build.os);
            }
            else if (navigator?.appVersion?.includes?.("Win") ?? false) {
                exports_17("NATIVE_OS", NATIVE_OS = "windows");
            }
            exports_17("isWindows", isWindows = NATIVE_OS == "windows");
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/_interface", [], function (exports_18, context_18) {
    "use strict";
    var __moduleName = context_18 && context_18.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/_util", ["https://deno.land/std@0.73.0/path/_constants"], function (exports_19, context_19) {
    "use strict";
    var _constants_ts_1;
    var __moduleName = context_19 && context_19.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_19("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_1.CHAR_FORWARD_SLASH;
    }
    exports_19("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_1.CHAR_BACKWARD_SLASH;
    }
    exports_19("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_1.CHAR_LOWERCASE_A && code <= _constants_ts_1.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_1.CHAR_UPPERCASE_A && code <= _constants_ts_1.CHAR_UPPERCASE_Z));
    }
    exports_19("isWindowsDeviceRoot", isWindowsDeviceRoot);
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_1.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_1.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_1.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_1.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_19("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base ||
            (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_19("_format", _format);
    return {
        setters: [
            function (_constants_ts_1_1) {
                _constants_ts_1 = _constants_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/win32", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/_util", "https://deno.land/std@0.73.0/_util/assert"], function (exports_20, context_20) {
    "use strict";
    var _constants_ts_2, _util_ts_1, assert_ts_4, sep, delimiter;
    var __moduleName = context_20 && context_20.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_1.assertPath(path);
            const len = path.length;
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            if (len > 1) {
                if (_util_ts_1.isPathSeparator(code)) {
                    isAbsolute = true;
                    if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                        let j = 2;
                        let last = j;
                        for (; j < len; ++j) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            last = j;
                            for (; j < len; ++j) {
                                if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                last = j;
                                for (; j < len; ++j) {
                                    if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                    if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        resolvedTail = _util_ts_1.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_1.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_20("resolve", resolve);
    function normalize(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                isAbsolute = true;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_1.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_1.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_1.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_20("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_1.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_1.isWindowsDeviceRoot(code)) {
            if (len > 2 && path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_20("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_1.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_4.assert(firstPart != null);
        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_1.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_20("join", join);
    function relative(from, to) {
        _util_ts_1.assertPath(from);
        _util_ts_1.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_2.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_2.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_20("relative", relative);
    function toNamespacedPath(path) {
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_2.CHAR_QUESTION_MARK && code !== _constants_ts_2.CHAR_DOT) {
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_20("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = offset = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                return path;
                            }
                            if (j !== last) {
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_20("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_1.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_1.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_1.isPathSeparator(code)) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_20("basename", basename);
    function extname(path) {
        _util_ts_1.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
            _util_ts_1.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_20("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_1._format("\\", pathObject);
    }
    exports_20("format", format);
    function parse(path) {
        _util_ts_1.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                rootEnd = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_20("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        let path = decodeURIComponent(url.pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\")
            .replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
        if (url.hostname != "") {
            path = `\\\\${url.hostname}${path}`;
        }
        return path;
    }
    exports_20("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_2_1) {
                _constants_ts_2 = _constants_ts_2_1;
            },
            function (_util_ts_1_1) {
                _util_ts_1 = _util_ts_1_1;
            },
            function (assert_ts_4_1) {
                assert_ts_4 = assert_ts_4_1;
            }
        ],
        execute: function () {
            exports_20("sep", sep = "\\");
            exports_20("delimiter", delimiter = ";");
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/posix", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/_util"], function (exports_21, context_21) {
    "use strict";
    var _constants_ts_3, _util_ts_2, sep, delimiter;
    var __moduleName = context_21 && context_21.id;
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_2.assertPath(path);
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        }
        resolvedPath = _util_ts_2.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_21("resolve", resolve);
    function normalize(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_3.CHAR_FORWARD_SLASH;
        path = _util_ts_2.normalizeString(path, !isAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_21("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_2.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
    }
    exports_21("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_2.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_21("join", join);
    function relative(from, to) {
        _util_ts_2.assertPath(from);
        _util_ts_2.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_3.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_3.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_21("relative", relative);
    function toNamespacedPath(path) {
        return path;
    }
    exports_21("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_21("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_2.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                end = i;
                            }
                        }
                        else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_21("basename", basename);
    function extname(path) {
        _util_ts_2.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_21("extname", extname);
    function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_2._format("/", pathObject);
    }
    exports_21("format", format);
    function parse(path) {
        _util_ts_2.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        let preDotState = 0;
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            preDotState === 0 ||
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_21("parse", parse);
    function fromFileUrl(url) {
        url = url instanceof URL ? url : new URL(url);
        if (url.protocol != "file:") {
            throw new TypeError("Must be a file URL.");
        }
        return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
    }
    exports_21("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_3_1) {
                _constants_ts_3 = _constants_ts_3_1;
            },
            function (_util_ts_2_1) {
                _util_ts_2 = _util_ts_2_1;
            }
        ],
        execute: function () {
            exports_21("sep", sep = "/");
            exports_21("delimiter", delimiter = ":");
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/separator", ["https://deno.land/std@0.73.0/path/_constants"], function (exports_22, context_22) {
    "use strict";
    var _constants_ts_4, SEP, SEP_PATTERN;
    var __moduleName = context_22 && context_22.id;
    return {
        setters: [
            function (_constants_ts_4_1) {
                _constants_ts_4 = _constants_ts_4_1;
            }
        ],
        execute: function () {
            exports_22("SEP", SEP = _constants_ts_4.isWindows ? "\\" : "/");
            exports_22("SEP_PATTERN", SEP_PATTERN = _constants_ts_4.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/common", ["https://deno.land/std@0.73.0/path/separator"], function (exports_23, context_23) {
    "use strict";
    var separator_ts_1;
    var __moduleName = context_23 && context_23.id;
    function common(paths, sep = separator_ts_1.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_23("common", common);
    return {
        setters: [
            function (separator_ts_1_1) {
                separator_ts_1 = separator_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/glob", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/mod", "https://deno.land/std@0.73.0/path/separator"], function (exports_24, context_24) {
    "use strict";
    var _constants_ts_5, mod_ts_5, separator_ts_2, regExpEscapeChars, rangeEscapeChars;
    var __moduleName = context_24 && context_24.id;
    function globToRegExp(glob, { extended = true, globstar: globstarOption = true, os = _constants_ts_5.NATIVE_OS } = {}) {
        if (glob == "") {
            return /(?!)/;
        }
        const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
        const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
        const seps = os == "windows" ? ["\\", "/"] : ["/"];
        const globstar = os == "windows"
            ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*"
            : "(?:[^/]*(?:/|$)+)*";
        const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
        const escapePrefix = os == "windows" ? "`" : "\\";
        let newLength = glob.length;
        for (; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--)
            ;
        glob = glob.slice(0, newLength);
        let regExpString = "";
        for (let j = 0; j < glob.length;) {
            let segment = "";
            const groupStack = [];
            let inRange = false;
            let inEscape = false;
            let endsWithSep = false;
            let i = j;
            for (; i < glob.length && !seps.includes(glob[i]); i++) {
                if (inEscape) {
                    inEscape = false;
                    const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                    segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                    continue;
                }
                if (glob[i] == escapePrefix) {
                    inEscape = true;
                    continue;
                }
                if (glob[i] == "[") {
                    if (!inRange) {
                        inRange = true;
                        segment += "[";
                        if (glob[i + 1] == "!") {
                            i++;
                            segment += "^";
                        }
                        else if (glob[i + 1] == "^") {
                            i++;
                            segment += "\\^";
                        }
                        continue;
                    }
                    else if (glob[i + 1] == ":") {
                        let k = i + 1;
                        let value = "";
                        while (glob[k + 1] != null && glob[k + 1] != ":") {
                            value += glob[k + 1];
                            k++;
                        }
                        if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                            i = k + 2;
                            if (value == "alnum")
                                segment += "\\dA-Za-z";
                            else if (value == "alpha")
                                segment += "A-Za-z";
                            else if (value == "ascii")
                                segment += "\x00-\x7F";
                            else if (value == "blank")
                                segment += "\t ";
                            else if (value == "cntrl")
                                segment += "\x00-\x1F\x7F";
                            else if (value == "digit")
                                segment += "\\d";
                            else if (value == "graph")
                                segment += "\x21-\x7E";
                            else if (value == "lower")
                                segment += "a-z";
                            else if (value == "print")
                                segment += "\x20-\x7E";
                            else if (value == "punct") {
                                segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_{|}~";
                            }
                            else if (value == "space")
                                segment += "\\s\v";
                            else if (value == "upper")
                                segment += "A-Z";
                            else if (value == "word")
                                segment += "\\w";
                            else if (value == "xdigit")
                                segment += "\\dA-Fa-f";
                            continue;
                        }
                    }
                }
                if (glob[i] == "]" && inRange) {
                    inRange = false;
                    segment += "]";
                    continue;
                }
                if (inRange) {
                    if (glob[i] == "\\") {
                        segment += `\\\\`;
                    }
                    else {
                        segment += glob[i];
                    }
                    continue;
                }
                if (glob[i] == ")" && groupStack.length > 0 &&
                    groupStack[groupStack.length - 1] != "BRACE") {
                    segment += ")";
                    const type = groupStack.pop();
                    if (type == "!") {
                        segment += wildcard;
                    }
                    else if (type != "@") {
                        segment += type;
                    }
                    continue;
                }
                if (glob[i] == "|" && groupStack.length > 0 &&
                    groupStack[groupStack.length - 1] != "BRACE") {
                    segment += "|";
                    continue;
                }
                if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("+");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("@");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "?") {
                    if (extended && glob[i + 1] == "(") {
                        i++;
                        groupStack.push("?");
                        segment += "(?:";
                    }
                    else {
                        segment += ".";
                    }
                    continue;
                }
                if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("!");
                    segment += "(?!";
                    continue;
                }
                if (glob[i] == "{") {
                    groupStack.push("BRACE");
                    segment += "(?:";
                    continue;
                }
                if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                    groupStack.pop();
                    segment += ")";
                    continue;
                }
                if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                    segment += "|";
                    continue;
                }
                if (glob[i] == "*") {
                    if (extended && glob[i + 1] == "(") {
                        i++;
                        groupStack.push("*");
                        segment += "(?:";
                    }
                    else {
                        const prevChar = glob[i - 1];
                        let numStars = 1;
                        while (glob[i + 1] == "*") {
                            i++;
                            numStars++;
                        }
                        const nextChar = glob[i + 1];
                        if (globstarOption && numStars == 2 &&
                            [...seps, undefined].includes(prevChar) &&
                            [...seps, undefined].includes(nextChar)) {
                            segment += globstar;
                            endsWithSep = true;
                        }
                        else {
                            segment += wildcard;
                        }
                    }
                    continue;
                }
                segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
            }
            if (groupStack.length > 0 || inRange || inEscape) {
                segment = "";
                for (const c of glob.slice(j, i)) {
                    segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                    endsWithSep = false;
                }
            }
            regExpString += segment;
            if (!endsWithSep) {
                regExpString += i < glob.length ? sep : sepMaybe;
                endsWithSep = true;
            }
            while (seps.includes(glob[i]))
                i++;
            if (!(i > j)) {
                throw new Error("Assertion failure: i > j (potential infinite loop)");
            }
            j = i;
        }
        regExpString = `^${regExpString}$`;
        return new RegExp(regExpString);
    }
    exports_24("globToRegExp", globToRegExp);
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_24("isGlob", isGlob);
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_5.normalize(glob);
        }
        const s = separator_ts_2.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_5.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_24("normalizeGlob", normalizeGlob);
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_5.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_2.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_24("joinGlobs", joinGlobs);
    return {
        setters: [
            function (_constants_ts_5_1) {
                _constants_ts_5 = _constants_ts_5_1;
            },
            function (mod_ts_5_1) {
                mod_ts_5 = mod_ts_5_1;
            },
            function (separator_ts_2_1) {
                separator_ts_2 = separator_ts_2_1;
            }
        ],
        execute: function () {
            regExpEscapeChars = ["!", "$", "(", ")", "*", "+", ".", "=", "?", "[", "\\", "^", "{", "|"];
            rangeEscapeChars = ["-", "\\", "]"];
        }
    };
});
System.register("https://deno.land/std@0.73.0/path/mod", ["https://deno.land/std@0.73.0/path/_constants", "https://deno.land/std@0.73.0/path/win32", "https://deno.land/std@0.73.0/path/posix", "https://deno.land/std@0.73.0/path/common", "https://deno.land/std@0.73.0/path/separator", "https://deno.land/std@0.73.0/path/_interface", "https://deno.land/std@0.73.0/path/glob"], function (exports_25, context_25) {
    "use strict";
    var _constants_ts_6, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_25 && context_25.id;
    var exportedNames_1 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_25(exports);
    }
    return {
        setters: [
            function (_constants_ts_6_1) {
                _constants_ts_6 = _constants_ts_6_1;
            },
            function (_win32_1) {
                _win32 = _win32_1;
            },
            function (_posix_1) {
                _posix = _posix_1;
            },
            function (common_ts_1_1) {
                exportStar_2(common_ts_1_1);
            },
            function (separator_ts_3_1) {
                exports_25({
                    "SEP": separator_ts_3_1["SEP"],
                    "SEP_PATTERN": separator_ts_3_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_1_1) {
                exportStar_2(_interface_ts_1_1);
            },
            function (glob_ts_1_1) {
                exportStar_2(glob_ts_1_1);
            }
        ],
        execute: function () {
            path = _constants_ts_6.isWindows ? _win32 : _posix;
            exports_25("win32", win32 = _win32);
            exports_25("posix", posix = _posix);
            exports_25("basename", basename = path.basename), exports_25("delimiter", delimiter = path.delimiter), exports_25("dirname", dirname = path.dirname), exports_25("extname", extname = path.extname), exports_25("format", format = path.format), exports_25("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_25("isAbsolute", isAbsolute = path.isAbsolute), exports_25("join", join = path.join), exports_25("normalize", normalize = path.normalize), exports_25("parse", parse = path.parse), exports_25("relative", relative = path.relative), exports_25("resolve", resolve = path.resolve), exports_25("sep", sep = path.sep), exports_25("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std@0.73.0/fmt/colors", [], function (exports_26, context_26) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_26 && context_26.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_26("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_26("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_26("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_26("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_26("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_26("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_26("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_26("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_26("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_26("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_26("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_26("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_26("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_26("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_26("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_26("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_26("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_26("white", white);
    function gray(str) {
        return brightBlack(str);
    }
    exports_26("gray", gray);
    function brightBlack(str) {
        return run(str, code([90], 39));
    }
    exports_26("brightBlack", brightBlack);
    function brightRed(str) {
        return run(str, code([91], 39));
    }
    exports_26("brightRed", brightRed);
    function brightGreen(str) {
        return run(str, code([92], 39));
    }
    exports_26("brightGreen", brightGreen);
    function brightYellow(str) {
        return run(str, code([93], 39));
    }
    exports_26("brightYellow", brightYellow);
    function brightBlue(str) {
        return run(str, code([94], 39));
    }
    exports_26("brightBlue", brightBlue);
    function brightMagenta(str) {
        return run(str, code([95], 39));
    }
    exports_26("brightMagenta", brightMagenta);
    function brightCyan(str) {
        return run(str, code([96], 39));
    }
    exports_26("brightCyan", brightCyan);
    function brightWhite(str) {
        return run(str, code([97], 39));
    }
    exports_26("brightWhite", brightWhite);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_26("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_26("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_26("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_26("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_26("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_26("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_26("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_26("bgWhite", bgWhite);
    function bgBrightBlack(str) {
        return run(str, code([100], 49));
    }
    exports_26("bgBrightBlack", bgBrightBlack);
    function bgBrightRed(str) {
        return run(str, code([101], 49));
    }
    exports_26("bgBrightRed", bgBrightRed);
    function bgBrightGreen(str) {
        return run(str, code([102], 49));
    }
    exports_26("bgBrightGreen", bgBrightGreen);
    function bgBrightYellow(str) {
        return run(str, code([103], 49));
    }
    exports_26("bgBrightYellow", bgBrightYellow);
    function bgBrightBlue(str) {
        return run(str, code([104], 49));
    }
    exports_26("bgBrightBlue", bgBrightBlue);
    function bgBrightMagenta(str) {
        return run(str, code([105], 49));
    }
    exports_26("bgBrightMagenta", bgBrightMagenta);
    function bgBrightCyan(str) {
        return run(str, code([106], 49));
    }
    exports_26("bgBrightCyan", bgBrightCyan);
    function bgBrightWhite(str) {
        return run(str, code([107], 49));
    }
    exports_26("bgBrightWhite", bgBrightWhite);
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_26("rgb8", rgb8);
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_26("bgRgb8", bgRgb8);
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_26("rgb24", rgb24);
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_26("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_26("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
System.register("https://deno.land/std@0.73.0/testing/_diff", [], function (exports_27, context_27) {
    "use strict";
    var DiffType, REMOVED, COMMON, ADDED;
    var __moduleName = context_27 && context_27.id;
    function createCommon(A, B, reverse) {
        const common = [];
        if (A.length === 0 || B.length === 0)
            return [];
        for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
            if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
                common.push(A[reverse ? A.length - i - 1 : i]);
            }
            else {
                return common;
            }
        }
        return common;
    }
    function diff(A, B) {
        const prefixCommon = createCommon(A, B);
        const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
        A = suffixCommon.length
            ? A.slice(prefixCommon.length, -suffixCommon.length)
            : A.slice(prefixCommon.length);
        B = suffixCommon.length
            ? B.slice(prefixCommon.length, -suffixCommon.length)
            : B.slice(prefixCommon.length);
        const swapped = B.length > A.length;
        [A, B] = swapped ? [B, A] : [A, B];
        const M = A.length;
        const N = B.length;
        if (!M && !N && !suffixCommon.length && !prefixCommon.length)
            return [];
        if (!N) {
            return [
                ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
                ...A.map((a) => ({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a,
                })),
                ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ];
        }
        const offset = N;
        const delta = M - N;
        const size = M + N + 1;
        const fp = new Array(size).fill({ y: -1 });
        const routes = new Uint32Array((M * N + size + 1) * 2);
        const diffTypesPtrOffset = routes.length / 2;
        let ptr = 0;
        let p = -1;
        function backTrace(A, B, current, swapped) {
            const M = A.length;
            const N = B.length;
            const result = [];
            let a = M - 1;
            let b = N - 1;
            let j = routes[current.id];
            let type = routes[current.id + diffTypesPtrOffset];
            while (true) {
                if (!j && !type)
                    break;
                const prev = j;
                if (type === REMOVED) {
                    result.unshift({
                        type: swapped ? DiffType.removed : DiffType.added,
                        value: B[b],
                    });
                    b -= 1;
                }
                else if (type === ADDED) {
                    result.unshift({
                        type: swapped ? DiffType.added : DiffType.removed,
                        value: A[a],
                    });
                    a -= 1;
                }
                else {
                    result.unshift({ type: DiffType.common, value: A[a] });
                    a -= 1;
                    b -= 1;
                }
                j = routes[prev];
                type = routes[prev + diffTypesPtrOffset];
            }
            return result;
        }
        function createFP(slide, down, k, M) {
            if (slide && slide.y === -1 && down && down.y === -1) {
                return { y: 0, id: 0 };
            }
            if ((down && down.y === -1) ||
                k === M ||
                (slide && slide.y) > (down && down.y) + 1) {
                const prev = slide.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = ADDED;
                return { y: slide.y, id: ptr };
            }
            else {
                const prev = down.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = REMOVED;
                return { y: down.y + 1, id: ptr };
            }
        }
        function snake(k, slide, down, _offset, A, B) {
            const M = A.length;
            const N = B.length;
            if (k < -N || M < k)
                return { y: -1, id: -1 };
            const fp = createFP(slide, down, k, M);
            while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
                const prev = fp.id;
                ptr++;
                fp.id = ptr;
                fp.y += 1;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = COMMON;
            }
            return fp;
        }
        while (fp[delta + offset].y < N) {
            p = p + 1;
            for (let k = -p; k < delta; ++k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            for (let k = delta + p; k > delta; --k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
        }
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...backTrace(A, B, fp[delta + offset], swapped),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    exports_27("diff", diff);
    return {
        setters: [],
        execute: function () {
            (function (DiffType) {
                DiffType["removed"] = "removed";
                DiffType["common"] = "common";
                DiffType["added"] = "added";
            })(DiffType || (DiffType = {}));
            exports_27("DiffType", DiffType);
            REMOVED = 1;
            COMMON = 2;
            ADDED = 3;
        }
    };
});
System.register("https://deno.land/std@0.73.0/testing/asserts", ["https://deno.land/std@0.73.0/fmt/colors", "https://deno.land/std@0.73.0/testing/_diff"], function (exports_28, context_28) {
    "use strict";
    var colors_ts_1, _diff_ts_1, CAN_NOT_DISPLAY, AssertionError;
    var __moduleName = context_28 && context_28.id;
    function _format(v) {
        return globalThis.Deno
            ? Deno.inspect(v, {
                depth: Infinity,
                sorted: true,
                trailingComma: true,
                compact: false,
                iterableLimit: Infinity,
            })
            : `"${String(v).replace(/(?=["\\])/g, "\\")}"`;
    }
    exports_28("_format", _format);
    function createColor(diffType) {
        switch (diffType) {
            case _diff_ts_1.DiffType.added:
                return (s) => colors_ts_1.green(colors_ts_1.bold(s));
            case _diff_ts_1.DiffType.removed:
                return (s) => colors_ts_1.red(colors_ts_1.bold(s));
            default:
                return colors_ts_1.white;
        }
    }
    function createSign(diffType) {
        switch (diffType) {
            case _diff_ts_1.DiffType.added:
                return "+   ";
            case _diff_ts_1.DiffType.removed:
                return "-   ";
            default:
                return "    ";
        }
    }
    function buildMessage(diffResult) {
        const messages = [];
        messages.push("");
        messages.push("");
        messages.push(`    ${colors_ts_1.gray(colors_ts_1.bold("[Diff]"))} ${colors_ts_1.red(colors_ts_1.bold("Actual"))} / ${colors_ts_1.green(colors_ts_1.bold("Expected"))}`);
        messages.push("");
        messages.push("");
        diffResult.forEach((result) => {
            const c = createColor(result.type);
            messages.push(c(`${createSign(result.type)}${result.value}`));
        });
        messages.push("");
        return messages;
    }
    function isKeyedCollection(x) {
        return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
        const seen = new Map();
        return (function compare(a, b) {
            if (a &&
                b &&
                ((a instanceof RegExp && b instanceof RegExp) ||
                    (a instanceof URL && b instanceof URL))) {
                return String(a) === String(b);
            }
            if (a instanceof Date && b instanceof Date) {
                const aTime = a.getTime();
                const bTime = b.getTime();
                if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                    return true;
                }
                return a.getTime() === b.getTime();
            }
            if (Object.is(a, b)) {
                return true;
            }
            if (a && typeof a === "object" && b && typeof b === "object") {
                if (seen.get(a) === b) {
                    return true;
                }
                if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                    return false;
                }
                if (isKeyedCollection(a) && isKeyedCollection(b)) {
                    if (a.size !== b.size) {
                        return false;
                    }
                    let unmatchedEntries = a.size;
                    for (const [aKey, aValue] of a.entries()) {
                        for (const [bKey, bValue] of b.entries()) {
                            if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                (compare(aKey, bKey) && compare(aValue, bValue))) {
                                unmatchedEntries--;
                            }
                        }
                    }
                    return unmatchedEntries === 0;
                }
                const merged = { ...a, ...b };
                for (const key in merged) {
                    if (!compare(a && a[key], b && b[key])) {
                        return false;
                    }
                }
                seen.set(a, b);
                return true;
            }
            return false;
        })(c, d);
    }
    exports_28("equal", equal);
    function assert(expr, msg = "") {
        if (!expr) {
            throw new AssertionError(msg);
        }
    }
    exports_28("assert", assert);
    function assertEquals(actual, expected, msg) {
        if (equal(actual, expected)) {
            return;
        }
        let message = "";
        const actualString = _format(actual);
        const expectedString = _format(expected);
        try {
            const diffResult = _diff_ts_1.diff(actualString.split("\n"), expectedString.split("\n"));
            const diffMsg = buildMessage(diffResult).join("\n");
            message = `Values are not equal:\n${diffMsg}`;
        }
        catch (e) {
            message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
        }
        if (msg) {
            message = msg;
        }
        throw new AssertionError(message);
    }
    exports_28("assertEquals", assertEquals);
    function assertNotEquals(actual, expected, msg) {
        if (!equal(actual, expected)) {
            return;
        }
        let actualString;
        let expectedString;
        try {
            actualString = String(actual);
        }
        catch (e) {
            actualString = "[Cannot display]";
        }
        try {
            expectedString = String(expected);
        }
        catch (e) {
            expectedString = "[Cannot display]";
        }
        if (!msg) {
            msg = `actual: ${actualString} expected: ${expectedString}`;
        }
        throw new AssertionError(msg);
    }
    exports_28("assertNotEquals", assertNotEquals);
    function assertStrictEquals(actual, expected, msg) {
        if (actual === expected) {
            return;
        }
        let message;
        if (msg) {
            message = msg;
        }
        else {
            const actualString = _format(actual);
            const expectedString = _format(expected);
            if (actualString === expectedString) {
                const withOffset = actualString
                    .split("\n")
                    .map((l) => `    ${l}`)
                    .join("\n");
                message =
                    `Values have the same structure but are not reference-equal:\n\n${colors_ts_1.red(withOffset)}\n`;
            }
            else {
                try {
                    const diffResult = _diff_ts_1.diff(actualString.split("\n"), expectedString.split("\n"));
                    const diffMsg = buildMessage(diffResult).join("\n");
                    message = `Values are not strictly equal:\n${diffMsg}`;
                }
                catch (e) {
                    message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
                }
            }
        }
        throw new AssertionError(message);
    }
    exports_28("assertStrictEquals", assertStrictEquals);
    function assertNotStrictEquals(actual, expected, msg) {
        if (actual !== expected) {
            return;
        }
        throw new AssertionError(msg ?? `Expected "actual" to be strictly unequal to: ${_format(actual)}\n`);
    }
    exports_28("assertNotStrictEquals", assertNotStrictEquals);
    function assertStringContains(actual, expected, msg) {
        if (!actual.includes(expected)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to contain: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_28("assertStringContains", assertStringContains);
    function assertArrayContains(actual, expected, msg) {
        const missing = [];
        for (let i = 0; i < expected.length; i++) {
            let found = false;
            for (let j = 0; j < actual.length; j++) {
                if (equal(expected[i], actual[j])) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                missing.push(expected[i]);
            }
        }
        if (missing.length === 0) {
            return;
        }
        if (!msg) {
            msg = `actual: "${_format(actual)}" expected to contain: "${_format(expected)}"\nmissing: ${_format(missing)}`;
        }
        throw new AssertionError(msg);
    }
    exports_28("assertArrayContains", assertArrayContains);
    function assertMatch(actual, expected, msg) {
        if (!expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_28("assertMatch", assertMatch);
    function assertNotMatch(actual, expected, msg) {
        if (expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to not match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_28("assertNotMatch", assertNotMatch);
    function fail(msg) {
        assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
    }
    exports_28("fail", fail);
    function assertThrows(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            fn();
        }
        catch (e) {
            if (e instanceof Error === false) {
                throw new AssertionError("A non-Error object was thrown.");
            }
            if (ErrorClass && !(e instanceof ErrorClass)) {
                msg =
                    `Expected error to be instance of "${ErrorClass.name}", but was "${e.constructor.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg =
                    `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_28("assertThrows", assertThrows);
    async function assertThrowsAsync(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            await fn();
        }
        catch (e) {
            if (e instanceof Error === false) {
                throw new AssertionError("A non-Error object was thrown or rejected.");
            }
            if (ErrorClass && !(e instanceof ErrorClass)) {
                msg =
                    `Expected error to be instance of "${ErrorClass.name}", but got "${e.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg =
                    `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_28("assertThrowsAsync", assertThrowsAsync);
    function unimplemented(msg) {
        throw new AssertionError(msg || "unimplemented");
    }
    exports_28("unimplemented", unimplemented);
    function unreachable() {
        throw new AssertionError("unreachable");
    }
    exports_28("unreachable", unreachable);
    return {
        setters: [
            function (colors_ts_1_1) {
                colors_ts_1 = colors_ts_1_1;
            },
            function (_diff_ts_1_1) {
                _diff_ts_1 = _diff_ts_1_1;
            }
        ],
        execute: function () {
            CAN_NOT_DISPLAY = "[Cannot display]";
            AssertionError = class AssertionError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "AssertionError";
                }
            };
            exports_28("AssertionError", AssertionError);
        }
    };
});
System.register("https://deno.land/std@0.73.0/_util/has_own_property", [], function (exports_29, context_29) {
    "use strict";
    var __moduleName = context_29 && context_29.id;
    function hasOwnProperty(obj, v) {
        if (obj == null) {
            return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, v);
    }
    exports_29("hasOwnProperty", hasOwnProperty);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.73.0/io/ioutil", ["https://deno.land/std@0.73.0/_util/assert"], function (exports_30, context_30) {
    "use strict";
    var assert_ts_5, DEFAULT_BUFFER_SIZE, MAX_SAFE_INTEGER;
    var __moduleName = context_30 && context_30.id;
    async function copyN(r, dest, size) {
        let bytesRead = 0;
        let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);
        while (bytesRead < size) {
            if (size - bytesRead < DEFAULT_BUFFER_SIZE) {
                buf = new Uint8Array(size - bytesRead);
            }
            const result = await r.read(buf);
            const nread = result ?? 0;
            bytesRead += nread;
            if (nread > 0) {
                let n = 0;
                while (n < nread) {
                    n += await dest.write(buf.slice(n, nread));
                }
                assert_ts_5.assert(n === nread, "could not write");
            }
            if (result === null) {
                break;
            }
        }
        return bytesRead;
    }
    exports_30("copyN", copyN);
    async function readShort(buf) {
        const high = await buf.readByte();
        if (high === null)
            return null;
        const low = await buf.readByte();
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 8) | low;
    }
    exports_30("readShort", readShort);
    async function readInt(buf) {
        const high = await readShort(buf);
        if (high === null)
            return null;
        const low = await readShort(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 16) | low;
    }
    exports_30("readInt", readInt);
    async function readLong(buf) {
        const high = await readInt(buf);
        if (high === null)
            return null;
        const low = await readInt(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        const big = (BigInt(high) << 32n) | BigInt(low);
        if (big > MAX_SAFE_INTEGER) {
            throw new RangeError("Long value too big to be represented as a JavaScript number.");
        }
        return Number(big);
    }
    exports_30("readLong", readLong);
    function sliceLongToBytes(d, dest = new Array(8)) {
        let big = BigInt(d);
        for (let i = 0; i < 8; i++) {
            dest[7 - i] = Number(big & 0xffn);
            big >>= 8n;
        }
        return dest;
    }
    exports_30("sliceLongToBytes", sliceLongToBytes);
    return {
        setters: [
            function (assert_ts_5_1) {
                assert_ts_5 = assert_ts_5_1;
            }
        ],
        execute: function () {
            DEFAULT_BUFFER_SIZE = 32 * 1024;
            MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
        }
    };
});
System.register("https://deno.land/std@0.73.0/ws/mod", ["https://deno.land/std@0.73.0/encoding/utf8", "https://deno.land/std@0.73.0/_util/has_own_property", "https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/io/ioutil", "https://deno.land/std@0.73.0/hash/sha1", "https://deno.land/std@0.73.0/http/_io", "https://deno.land/std@0.73.0/textproto/mod", "https://deno.land/std@0.73.0/async/deferred", "https://deno.land/std@0.73.0/_util/assert", "https://deno.land/std@0.73.0/bytes/mod"], function (exports_31, context_31) {
    "use strict";
    var utf8_ts_4, has_own_property_ts_1, bufio_ts_3, ioutil_ts_1, sha1_ts_1, _io_ts_2, mod_ts_6, deferred_ts_3, assert_ts_6, mod_ts_7, OpCode, WebSocketImpl, kGUID, kSecChars;
    var __moduleName = context_31 && context_31.id;
    function isWebSocketCloseEvent(a) {
        return has_own_property_ts_1.hasOwnProperty(a, "code");
    }
    exports_31("isWebSocketCloseEvent", isWebSocketCloseEvent);
    function isWebSocketPingEvent(a) {
        return Array.isArray(a) && a[0] === "ping" && a[1] instanceof Uint8Array;
    }
    exports_31("isWebSocketPingEvent", isWebSocketPingEvent);
    function isWebSocketPongEvent(a) {
        return Array.isArray(a) && a[0] === "pong" && a[1] instanceof Uint8Array;
    }
    exports_31("isWebSocketPongEvent", isWebSocketPongEvent);
    function unmask(payload, mask) {
        if (mask) {
            for (let i = 0, len = payload.length; i < len; i++) {
                payload[i] ^= mask[i & 3];
            }
        }
    }
    exports_31("unmask", unmask);
    async function writeFrame(frame, writer) {
        const payloadLength = frame.payload.byteLength;
        let header;
        const hasMask = frame.mask ? 0x80 : 0;
        if (frame.mask && frame.mask.byteLength !== 4) {
            throw new Error("invalid mask. mask must be 4 bytes: length=" + frame.mask.byteLength);
        }
        if (payloadLength < 126) {
            header = new Uint8Array([0x80 | frame.opcode, hasMask | payloadLength]);
        }
        else if (payloadLength < 0xffff) {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111110,
                payloadLength >>> 8,
                payloadLength & 0x00ff,
            ]);
        }
        else {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111111,
                ...ioutil_ts_1.sliceLongToBytes(payloadLength),
            ]);
        }
        if (frame.mask) {
            header = mod_ts_7.concat(header, frame.mask);
        }
        unmask(frame.payload, frame.mask);
        header = mod_ts_7.concat(header, frame.payload);
        const w = bufio_ts_3.BufWriter.create(writer);
        await w.write(header);
        await w.flush();
    }
    exports_31("writeFrame", writeFrame);
    async function readFrame(buf) {
        let b = await buf.readByte();
        assert_ts_6.assert(b !== null);
        let isLastFrame = false;
        switch (b >>> 4) {
            case 0b1000:
                isLastFrame = true;
                break;
            case 0b0000:
                isLastFrame = false;
                break;
            default:
                throw new Error("invalid signature");
        }
        const opcode = b & 0x0f;
        b = await buf.readByte();
        assert_ts_6.assert(b !== null);
        const hasMask = b >>> 7;
        let payloadLength = b & 0b01111111;
        if (payloadLength === 126) {
            const l = await ioutil_ts_1.readShort(buf);
            assert_ts_6.assert(l !== null);
            payloadLength = l;
        }
        else if (payloadLength === 127) {
            const l = await ioutil_ts_1.readLong(buf);
            assert_ts_6.assert(l !== null);
            payloadLength = Number(l);
        }
        let mask;
        if (hasMask) {
            mask = new Uint8Array(4);
            assert_ts_6.assert((await buf.readFull(mask)) !== null);
        }
        const payload = new Uint8Array(payloadLength);
        assert_ts_6.assert((await buf.readFull(payload)) !== null);
        return {
            isLastFrame,
            opcode,
            mask,
            payload,
        };
    }
    exports_31("readFrame", readFrame);
    function acceptable(req) {
        const upgrade = req.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = req.headers.get("sec-websocket-key");
        return (req.headers.has("sec-websocket-key") &&
            typeof secKey === "string" &&
            secKey.length > 0);
    }
    exports_31("acceptable", acceptable);
    function createSecAccept(nonce) {
        const sha1 = new sha1_ts_1.Sha1();
        sha1.update(nonce + kGUID);
        const bytes = sha1.digest();
        return btoa(String.fromCharCode(...bytes));
    }
    exports_31("createSecAccept", createSecAccept);
    async function acceptWebSocket(req) {
        const { conn, headers, bufReader, bufWriter } = req;
        if (acceptable(req)) {
            const sock = new WebSocketImpl({ conn, bufReader, bufWriter });
            const secKey = headers.get("sec-websocket-key");
            if (typeof secKey !== "string") {
                throw new Error("sec-websocket-key is not provided");
            }
            const secAccept = createSecAccept(secKey);
            await _io_ts_2.writeResponse(bufWriter, {
                status: 101,
                headers: new Headers({
                    Upgrade: "websocket",
                    Connection: "Upgrade",
                    "Sec-WebSocket-Accept": secAccept,
                }),
            });
            return sock;
        }
        throw new Error("request is not acceptable");
    }
    exports_31("acceptWebSocket", acceptWebSocket);
    function createSecKey() {
        let key = "";
        for (let i = 0; i < 16; i++) {
            const j = Math.floor(Math.random() * kSecChars.length);
            key += kSecChars[j];
        }
        return btoa(key);
    }
    exports_31("createSecKey", createSecKey);
    async function handshake(url, headers, bufReader, bufWriter) {
        const { hostname, pathname, search } = url;
        const key = createSecKey();
        if (!headers.has("host")) {
            headers.set("host", hostname);
        }
        headers.set("upgrade", "websocket");
        headers.set("connection", "upgrade");
        headers.set("sec-websocket-key", key);
        headers.set("sec-websocket-version", "13");
        let headerStr = `GET ${pathname}${search} HTTP/1.1\r\n`;
        for (const [key, value] of headers) {
            headerStr += `${key}: ${value}\r\n`;
        }
        headerStr += "\r\n";
        await bufWriter.write(utf8_ts_4.encode(headerStr));
        await bufWriter.flush();
        const tpReader = new mod_ts_6.TextProtoReader(bufReader);
        const statusLine = await tpReader.readLine();
        if (statusLine === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const m = statusLine.match(/^(?<version>\S+) (?<statusCode>\S+) /);
        if (!m) {
            throw new Error("ws: invalid status line: " + statusLine);
        }
        assert_ts_6.assert(m.groups);
        const { version, statusCode } = m.groups;
        if (version !== "HTTP/1.1" || statusCode !== "101") {
            throw new Error(`ws: server didn't accept handshake: ` +
                `version=${version}, statusCode=${statusCode}`);
        }
        const responseHeaders = await tpReader.readMIMEHeader();
        if (responseHeaders === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const expectedSecAccept = createSecAccept(key);
        const secAccept = responseHeaders.get("sec-websocket-accept");
        if (secAccept !== expectedSecAccept) {
            throw new Error(`ws: unexpected sec-websocket-accept header: ` +
                `expected=${expectedSecAccept}, actual=${secAccept}`);
        }
    }
    exports_31("handshake", handshake);
    function createWebSocket(params) {
        return new WebSocketImpl(params);
    }
    exports_31("createWebSocket", createWebSocket);
    return {
        setters: [
            function (utf8_ts_4_1) {
                utf8_ts_4 = utf8_ts_4_1;
            },
            function (has_own_property_ts_1_1) {
                has_own_property_ts_1 = has_own_property_ts_1_1;
            },
            function (bufio_ts_3_1) {
                bufio_ts_3 = bufio_ts_3_1;
            },
            function (ioutil_ts_1_1) {
                ioutil_ts_1 = ioutil_ts_1_1;
            },
            function (sha1_ts_1_1) {
                sha1_ts_1 = sha1_ts_1_1;
            },
            function (_io_ts_2_1) {
                _io_ts_2 = _io_ts_2_1;
            },
            function (mod_ts_6_1) {
                mod_ts_6 = mod_ts_6_1;
            },
            function (deferred_ts_3_1) {
                deferred_ts_3 = deferred_ts_3_1;
            },
            function (assert_ts_6_1) {
                assert_ts_6 = assert_ts_6_1;
            },
            function (mod_ts_7_1) {
                mod_ts_7 = mod_ts_7_1;
            }
        ],
        execute: function () {
            (function (OpCode) {
                OpCode[OpCode["Continue"] = 0] = "Continue";
                OpCode[OpCode["TextFrame"] = 1] = "TextFrame";
                OpCode[OpCode["BinaryFrame"] = 2] = "BinaryFrame";
                OpCode[OpCode["Close"] = 8] = "Close";
                OpCode[OpCode["Ping"] = 9] = "Ping";
                OpCode[OpCode["Pong"] = 10] = "Pong";
            })(OpCode || (OpCode = {}));
            exports_31("OpCode", OpCode);
            WebSocketImpl = class WebSocketImpl {
                constructor({ conn, bufReader, bufWriter, mask, }) {
                    this.sendQueue = [];
                    this._isClosed = false;
                    this.conn = conn;
                    this.mask = mask;
                    this.bufReader = bufReader || new bufio_ts_3.BufReader(conn);
                    this.bufWriter = bufWriter || new bufio_ts_3.BufWriter(conn);
                }
                async *[Symbol.asyncIterator]() {
                    let frames = [];
                    let payloadsLength = 0;
                    while (!this._isClosed) {
                        let frame;
                        try {
                            frame = await readFrame(this.bufReader);
                        }
                        catch (e) {
                            this.ensureSocketClosed();
                            break;
                        }
                        unmask(frame.payload, frame.mask);
                        switch (frame.opcode) {
                            case OpCode.TextFrame:
                            case OpCode.BinaryFrame:
                            case OpCode.Continue:
                                frames.push(frame);
                                payloadsLength += frame.payload.length;
                                if (frame.isLastFrame) {
                                    const concat = new Uint8Array(payloadsLength);
                                    let offs = 0;
                                    for (const frame of frames) {
                                        concat.set(frame.payload, offs);
                                        offs += frame.payload.length;
                                    }
                                    if (frames[0].opcode === OpCode.TextFrame) {
                                        yield utf8_ts_4.decode(concat);
                                    }
                                    else {
                                        yield concat;
                                    }
                                    frames = [];
                                    payloadsLength = 0;
                                }
                                break;
                            case OpCode.Close: {
                                const code = (frame.payload[0] << 8) | frame.payload[1];
                                const reason = utf8_ts_4.decode(frame.payload.subarray(2, frame.payload.length));
                                await this.close(code, reason);
                                yield { code, reason };
                                return;
                            }
                            case OpCode.Ping:
                                await this.enqueue({
                                    opcode: OpCode.Pong,
                                    payload: frame.payload,
                                    isLastFrame: true,
                                });
                                yield ["ping", frame.payload];
                                break;
                            case OpCode.Pong:
                                yield ["pong", frame.payload];
                                break;
                            default:
                        }
                    }
                }
                dequeue() {
                    const [entry] = this.sendQueue;
                    if (!entry)
                        return;
                    if (this._isClosed)
                        return;
                    const { d, frame } = entry;
                    writeFrame(frame, this.bufWriter)
                        .then(() => d.resolve())
                        .catch((e) => d.reject(e))
                        .finally(() => {
                        this.sendQueue.shift();
                        this.dequeue();
                    });
                }
                enqueue(frame) {
                    if (this._isClosed) {
                        throw new Deno.errors.ConnectionReset("Socket has already been closed");
                    }
                    const d = deferred_ts_3.deferred();
                    this.sendQueue.push({ d, frame });
                    if (this.sendQueue.length === 1) {
                        this.dequeue();
                    }
                    return d;
                }
                send(data) {
                    const opcode = typeof data === "string"
                        ? OpCode.TextFrame
                        : OpCode.BinaryFrame;
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const isLastFrame = true;
                    const frame = {
                        isLastFrame,
                        opcode,
                        payload,
                        mask: this.mask,
                    };
                    return this.enqueue(frame);
                }
                ping(data = "") {
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const frame = {
                        isLastFrame: true,
                        opcode: OpCode.Ping,
                        mask: this.mask,
                        payload,
                    };
                    return this.enqueue(frame);
                }
                get isClosed() {
                    return this._isClosed;
                }
                async close(code = 1000, reason) {
                    try {
                        const header = [code >>> 8, code & 0x00ff];
                        let payload;
                        if (reason) {
                            const reasonBytes = utf8_ts_4.encode(reason);
                            payload = new Uint8Array(2 + reasonBytes.byteLength);
                            payload.set(header);
                            payload.set(reasonBytes, 2);
                        }
                        else {
                            payload = new Uint8Array(header);
                        }
                        await this.enqueue({
                            isLastFrame: true,
                            opcode: OpCode.Close,
                            mask: this.mask,
                            payload,
                        });
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        this.ensureSocketClosed();
                    }
                }
                closeForce() {
                    this.ensureSocketClosed();
                }
                ensureSocketClosed() {
                    if (this.isClosed)
                        return;
                    try {
                        this.conn.close();
                    }
                    catch (e) {
                        console.error(e);
                    }
                    finally {
                        this._isClosed = true;
                        const rest = this.sendQueue;
                        this.sendQueue = [];
                        rest.forEach((e) => e.d.reject(new Deno.errors.ConnectionReset("Socket has already been closed")));
                    }
                }
            };
            kGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            kSecChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.~_";
        }
    };
});
/*!
 * Ported from: https://github.com/jshttp/mime-db and licensed as:
 *
 * (The MIT License)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2020 the Deno authors
 * Copyright (c) 2020 the oak authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/media_types@v2.5.1/db", [], function (exports_32, context_32) {
    "use strict";
    var db;
    var __moduleName = context_32 && context_32.id;
    return {
        setters: [],
        execute: function () {
            exports_32("db", db = JSON.parse(`{
  "application/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/3gpp-ims+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/a2l": {
    "source": "iana"
  },
  "application/activemessage": {
    "source": "iana"
  },
  "application/activity+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-costmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-directory+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcost+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointcostparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointprop+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-endpointpropparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-error+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-networkmapfilter+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamcontrol+json": {
    "source": "iana",
    "compressible": true
  },
  "application/alto-updatestreamparams+json": {
    "source": "iana",
    "compressible": true
  },
  "application/aml": {
    "source": "iana"
  },
  "application/andrew-inset": {
    "source": "iana",
    "extensions": ["ez"]
  },
  "application/applefile": {
    "source": "iana"
  },
  "application/applixware": {
    "source": "apache",
    "extensions": ["aw"]
  },
  "application/atf": {
    "source": "iana"
  },
  "application/atfx": {
    "source": "iana"
  },
  "application/atom+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atom"]
  },
  "application/atomcat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomcat"]
  },
  "application/atomdeleted+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomdeleted"]
  },
  "application/atomicmail": {
    "source": "iana"
  },
  "application/atomsvc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["atomsvc"]
  },
  "application/atsc-dwd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dwd"]
  },
  "application/atsc-dynamic-event-message": {
    "source": "iana"
  },
  "application/atsc-held+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["held"]
  },
  "application/atsc-rdt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/atsc-rsat+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsat"]
  },
  "application/atxml": {
    "source": "iana"
  },
  "application/auth-policy+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/bacnet-xdd+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/batch-smtp": {
    "source": "iana"
  },
  "application/bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/beep+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/calendar+json": {
    "source": "iana",
    "compressible": true
  },
  "application/calendar+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xcs"]
  },
  "application/call-completion": {
    "source": "iana"
  },
  "application/cals-1840": {
    "source": "iana"
  },
  "application/captive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cbor": {
    "source": "iana"
  },
  "application/cbor-seq": {
    "source": "iana"
  },
  "application/cccex": {
    "source": "iana"
  },
  "application/ccmp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ccxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ccxml"]
  },
  "application/cdfx+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdfx"]
  },
  "application/cdmi-capability": {
    "source": "iana",
    "extensions": ["cdmia"]
  },
  "application/cdmi-container": {
    "source": "iana",
    "extensions": ["cdmic"]
  },
  "application/cdmi-domain": {
    "source": "iana",
    "extensions": ["cdmid"]
  },
  "application/cdmi-object": {
    "source": "iana",
    "extensions": ["cdmio"]
  },
  "application/cdmi-queue": {
    "source": "iana",
    "extensions": ["cdmiq"]
  },
  "application/cdni": {
    "source": "iana"
  },
  "application/cea": {
    "source": "iana"
  },
  "application/cea-2018+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cellml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cfw": {
    "source": "iana"
  },
  "application/clue+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/clue_info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cms": {
    "source": "iana"
  },
  "application/cnrp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-group+json": {
    "source": "iana",
    "compressible": true
  },
  "application/coap-payload": {
    "source": "iana"
  },
  "application/commonground": {
    "source": "iana"
  },
  "application/conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cose": {
    "source": "iana"
  },
  "application/cose-key": {
    "source": "iana"
  },
  "application/cose-key-set": {
    "source": "iana"
  },
  "application/cpl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csrattrs": {
    "source": "iana"
  },
  "application/csta+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/cstadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/csvm+json": {
    "source": "iana",
    "compressible": true
  },
  "application/cu-seeme": {
    "source": "apache",
    "extensions": ["cu"]
  },
  "application/cwt": {
    "source": "iana"
  },
  "application/cybercash": {
    "source": "iana"
  },
  "application/dart": {
    "compressible": true
  },
  "application/dash+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpd"]
  },
  "application/dashdelta": {
    "source": "iana"
  },
  "application/davmount+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["davmount"]
  },
  "application/dca-rft": {
    "source": "iana"
  },
  "application/dcd": {
    "source": "iana"
  },
  "application/dec-dx": {
    "source": "iana"
  },
  "application/dialog-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom": {
    "source": "iana"
  },
  "application/dicom+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dicom+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dii": {
    "source": "iana"
  },
  "application/dit": {
    "source": "iana"
  },
  "application/dns": {
    "source": "iana"
  },
  "application/dns+json": {
    "source": "iana",
    "compressible": true
  },
  "application/dns-message": {
    "source": "iana"
  },
  "application/docbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dbk"]
  },
  "application/dots+cbor": {
    "source": "iana"
  },
  "application/dskpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/dssc+der": {
    "source": "iana",
    "extensions": ["dssc"]
  },
  "application/dssc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdssc"]
  },
  "application/dvcs": {
    "source": "iana"
  },
  "application/ecmascript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ecma","es"]
  },
  "application/edi-consent": {
    "source": "iana"
  },
  "application/edi-x12": {
    "source": "iana",
    "compressible": false
  },
  "application/edifact": {
    "source": "iana",
    "compressible": false
  },
  "application/efi": {
    "source": "iana"
  },
  "application/emergencycalldata.cap+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/emergencycalldata.comment+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.ecall.msd": {
    "source": "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emergencycalldata.veds+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/emma+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emma"]
  },
  "application/emotionml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["emotionml"]
  },
  "application/encaprtp": {
    "source": "iana"
  },
  "application/epp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/epub+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["epub"]
  },
  "application/eshop": {
    "source": "iana"
  },
  "application/exi": {
    "source": "iana",
    "extensions": ["exi"]
  },
  "application/expect-ct-report+json": {
    "source": "iana",
    "compressible": true
  },
  "application/fastinfoset": {
    "source": "iana"
  },
  "application/fastsoap": {
    "source": "iana"
  },
  "application/fdt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fdt"]
  },
  "application/fhir+json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fhir+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/fido.trusted-apps+json": {
    "compressible": true
  },
  "application/fits": {
    "source": "iana"
  },
  "application/flexfec": {
    "source": "iana"
  },
  "application/font-sfnt": {
    "source": "iana"
  },
  "application/font-tdpfr": {
    "source": "iana",
    "extensions": ["pfr"]
  },
  "application/font-woff": {
    "source": "iana",
    "compressible": false
  },
  "application/framework-attributes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/geo+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["geojson"]
  },
  "application/geo+json-seq": {
    "source": "iana"
  },
  "application/geopackage+sqlite3": {
    "source": "iana"
  },
  "application/geoxacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/gltf-buffer": {
    "source": "iana"
  },
  "application/gml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gml"]
  },
  "application/gpx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["gpx"]
  },
  "application/gxf": {
    "source": "apache",
    "extensions": ["gxf"]
  },
  "application/gzip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gz"]
  },
  "application/h224": {
    "source": "iana"
  },
  "application/held+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/hjson": {
    "extensions": ["hjson"]
  },
  "application/http": {
    "source": "iana"
  },
  "application/hyperstudio": {
    "source": "iana",
    "extensions": ["stk"]
  },
  "application/ibe-key-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pkg-reply+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ibe-pp-data": {
    "source": "iana"
  },
  "application/iges": {
    "source": "iana"
  },
  "application/im-iscomposing+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/index": {
    "source": "iana"
  },
  "application/index.cmd": {
    "source": "iana"
  },
  "application/index.obj": {
    "source": "iana"
  },
  "application/index.response": {
    "source": "iana"
  },
  "application/index.vnd": {
    "source": "iana"
  },
  "application/inkml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ink","inkml"]
  },
  "application/iotp": {
    "source": "iana"
  },
  "application/ipfix": {
    "source": "iana",
    "extensions": ["ipfix"]
  },
  "application/ipp": {
    "source": "iana"
  },
  "application/isup": {
    "source": "iana"
  },
  "application/its+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["its"]
  },
  "application/java-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jar","war","ear"]
  },
  "application/java-serialized-object": {
    "source": "apache",
    "compressible": false,
    "extensions": ["ser"]
  },
  "application/java-vm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["class"]
  },
  "application/javascript": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["js","mjs"]
  },
  "application/jf2feed+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jose": {
    "source": "iana"
  },
  "application/jose+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jrd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["json","map"]
  },
  "application/json-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/json-seq": {
    "source": "iana"
  },
  "application/json5": {
    "extensions": ["json5"]
  },
  "application/jsonml+json": {
    "source": "apache",
    "compressible": true,
    "extensions": ["jsonml"]
  },
  "application/jwk+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwk-set+json": {
    "source": "iana",
    "compressible": true
  },
  "application/jwt": {
    "source": "iana"
  },
  "application/kpml-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/kpml-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/ld+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["jsonld"]
  },
  "application/lgr+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lgr"]
  },
  "application/link-format": {
    "source": "iana"
  },
  "application/load-control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lost+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lostxml"]
  },
  "application/lostsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/lpf+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/lxf": {
    "source": "iana"
  },
  "application/mac-binhex40": {
    "source": "iana",
    "extensions": ["hqx"]
  },
  "application/mac-compactpro": {
    "source": "apache",
    "extensions": ["cpt"]
  },
  "application/macwriteii": {
    "source": "iana"
  },
  "application/mads+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mads"]
  },
  "application/manifest+json": {
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["webmanifest"]
  },
  "application/marc": {
    "source": "iana",
    "extensions": ["mrc"]
  },
  "application/marcxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mrcx"]
  },
  "application/mathematica": {
    "source": "iana",
    "extensions": ["ma","nb","mb"]
  },
  "application/mathml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mathml"]
  },
  "application/mathml-content+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mathml-presentation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-associated-procedure-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-deregister+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-envelope+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-msk-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-protection-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-reception-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-register-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-schedule+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbms-user-service-description+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mbox": {
    "source": "iana",
    "extensions": ["mbox"]
  },
  "application/media-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/media_control+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/mediaservercontrol+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mscml"]
  },
  "application/merge-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/metalink+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["metalink"]
  },
  "application/metalink4+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["meta4"]
  },
  "application/mets+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mets"]
  },
  "application/mf4": {
    "source": "iana"
  },
  "application/mikey": {
    "source": "iana"
  },
  "application/mipc": {
    "source": "iana"
  },
  "application/mmt-aei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["maei"]
  },
  "application/mmt-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musd"]
  },
  "application/mods+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mods"]
  },
  "application/moss-keys": {
    "source": "iana"
  },
  "application/moss-signature": {
    "source": "iana"
  },
  "application/mosskey-data": {
    "source": "iana"
  },
  "application/mosskey-request": {
    "source": "iana"
  },
  "application/mp21": {
    "source": "iana",
    "extensions": ["m21","mp21"]
  },
  "application/mp4": {
    "source": "iana",
    "extensions": ["mp4s","m4p"]
  },
  "application/mpeg4-generic": {
    "source": "iana"
  },
  "application/mpeg4-iod": {
    "source": "iana"
  },
  "application/mpeg4-iod-xmt": {
    "source": "iana"
  },
  "application/mrb-consumer+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/mrb-publish+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/msc-ivr+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msc-mixer+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/msword": {
    "source": "iana",
    "compressible": false,
    "extensions": ["doc","dot"]
  },
  "application/mud+json": {
    "source": "iana",
    "compressible": true
  },
  "application/multipart-core": {
    "source": "iana"
  },
  "application/mxf": {
    "source": "iana",
    "extensions": ["mxf"]
  },
  "application/n-quads": {
    "source": "iana",
    "extensions": ["nq"]
  },
  "application/n-triples": {
    "source": "iana",
    "extensions": ["nt"]
  },
  "application/nasdata": {
    "source": "iana"
  },
  "application/news-checkgroups": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-groupinfo": {
    "source": "iana",
    "charset": "US-ASCII"
  },
  "application/news-transmission": {
    "source": "iana"
  },
  "application/nlsml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/node": {
    "source": "iana",
    "extensions": ["cjs"]
  },
  "application/nss": {
    "source": "iana"
  },
  "application/ocsp-request": {
    "source": "iana"
  },
  "application/ocsp-response": {
    "source": "iana"
  },
  "application/octet-stream": {
    "source": "iana",
    "compressible": false,
    "extensions": ["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]
  },
  "application/oda": {
    "source": "iana",
    "extensions": ["oda"]
  },
  "application/odm+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/odx": {
    "source": "iana"
  },
  "application/oebps-package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["opf"]
  },
  "application/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogx"]
  },
  "application/omdoc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["omdoc"]
  },
  "application/onenote": {
    "source": "apache",
    "extensions": ["onetoc","onetoc2","onetmp","onepkg"]
  },
  "application/opc-nodeset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/oscore": {
    "source": "iana"
  },
  "application/oxps": {
    "source": "iana",
    "extensions": ["oxps"]
  },
  "application/p2p-overlay+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["relo"]
  },
  "application/parityfec": {
    "source": "iana"
  },
  "application/passport": {
    "source": "iana"
  },
  "application/patch-ops-error+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xer"]
  },
  "application/pdf": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pdf"]
  },
  "application/pdx": {
    "source": "iana"
  },
  "application/pem-certificate-chain": {
    "source": "iana"
  },
  "application/pgp-encrypted": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pgp"]
  },
  "application/pgp-keys": {
    "source": "iana"
  },
  "application/pgp-signature": {
    "source": "iana",
    "extensions": ["asc","sig"]
  },
  "application/pics-rules": {
    "source": "apache",
    "extensions": ["prf"]
  },
  "application/pidf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pidf-diff+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/pkcs10": {
    "source": "iana",
    "extensions": ["p10"]
  },
  "application/pkcs12": {
    "source": "iana"
  },
  "application/pkcs7-mime": {
    "source": "iana",
    "extensions": ["p7m","p7c"]
  },
  "application/pkcs7-signature": {
    "source": "iana",
    "extensions": ["p7s"]
  },
  "application/pkcs8": {
    "source": "iana",
    "extensions": ["p8"]
  },
  "application/pkcs8-encrypted": {
    "source": "iana"
  },
  "application/pkix-attr-cert": {
    "source": "iana",
    "extensions": ["ac"]
  },
  "application/pkix-cert": {
    "source": "iana",
    "extensions": ["cer"]
  },
  "application/pkix-crl": {
    "source": "iana",
    "extensions": ["crl"]
  },
  "application/pkix-pkipath": {
    "source": "iana",
    "extensions": ["pkipath"]
  },
  "application/pkixcmp": {
    "source": "iana",
    "extensions": ["pki"]
  },
  "application/pls+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pls"]
  },
  "application/poc-settings+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/postscript": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ai","eps","ps"]
  },
  "application/ppsp-tracker+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+json": {
    "source": "iana",
    "compressible": true
  },
  "application/problem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/provenance+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["provx"]
  },
  "application/prs.alvestrand.titrax-sheet": {
    "source": "iana"
  },
  "application/prs.cww": {
    "source": "iana",
    "extensions": ["cww"]
  },
  "application/prs.hpub+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/prs.nprend": {
    "source": "iana"
  },
  "application/prs.plucker": {
    "source": "iana"
  },
  "application/prs.rdf-xml-crypt": {
    "source": "iana"
  },
  "application/prs.xsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/pskc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["pskcxml"]
  },
  "application/pvd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/qsig": {
    "source": "iana"
  },
  "application/raml+yaml": {
    "compressible": true,
    "extensions": ["raml"]
  },
  "application/raptorfec": {
    "source": "iana"
  },
  "application/rdap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/rdf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rdf","owl"]
  },
  "application/reginfo+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rif"]
  },
  "application/relax-ng-compact-syntax": {
    "source": "iana",
    "extensions": ["rnc"]
  },
  "application/remote-printing": {
    "source": "iana"
  },
  "application/reputon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/resource-lists+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rl"]
  },
  "application/resource-lists-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rld"]
  },
  "application/rfc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/riscos": {
    "source": "iana"
  },
  "application/rlmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/rls-services+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rs"]
  },
  "application/route-apd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rapd"]
  },
  "application/route-s-tsid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sls"]
  },
  "application/route-usd+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rusd"]
  },
  "application/rpki-ghostbusters": {
    "source": "iana",
    "extensions": ["gbr"]
  },
  "application/rpki-manifest": {
    "source": "iana",
    "extensions": ["mft"]
  },
  "application/rpki-publication": {
    "source": "iana"
  },
  "application/rpki-roa": {
    "source": "iana",
    "extensions": ["roa"]
  },
  "application/rpki-updown": {
    "source": "iana"
  },
  "application/rsd+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rsd"]
  },
  "application/rss+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["rss"]
  },
  "application/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "application/rtploopback": {
    "source": "iana"
  },
  "application/rtx": {
    "source": "iana"
  },
  "application/samlassertion+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/samlmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sarif+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sbe": {
    "source": "iana"
  },
  "application/sbml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sbml"]
  },
  "application/scaip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/scim+json": {
    "source": "iana",
    "compressible": true
  },
  "application/scvp-cv-request": {
    "source": "iana",
    "extensions": ["scq"]
  },
  "application/scvp-cv-response": {
    "source": "iana",
    "extensions": ["scs"]
  },
  "application/scvp-vp-request": {
    "source": "iana",
    "extensions": ["spq"]
  },
  "application/scvp-vp-response": {
    "source": "iana",
    "extensions": ["spp"]
  },
  "application/sdp": {
    "source": "iana",
    "extensions": ["sdp"]
  },
  "application/secevent+jwt": {
    "source": "iana"
  },
  "application/senml+cbor": {
    "source": "iana"
  },
  "application/senml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["senmlx"]
  },
  "application/senml-etch+cbor": {
    "source": "iana"
  },
  "application/senml-etch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/senml-exi": {
    "source": "iana"
  },
  "application/sensml+cbor": {
    "source": "iana"
  },
  "application/sensml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/sensml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sensmlx"]
  },
  "application/sensml-exi": {
    "source": "iana"
  },
  "application/sep+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sep-exi": {
    "source": "iana"
  },
  "application/session-info": {
    "source": "iana"
  },
  "application/set-payment": {
    "source": "iana"
  },
  "application/set-payment-initiation": {
    "source": "iana",
    "extensions": ["setpay"]
  },
  "application/set-registration": {
    "source": "iana"
  },
  "application/set-registration-initiation": {
    "source": "iana",
    "extensions": ["setreg"]
  },
  "application/sgml": {
    "source": "iana"
  },
  "application/sgml-open-catalog": {
    "source": "iana"
  },
  "application/shf+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["shf"]
  },
  "application/sieve": {
    "source": "iana",
    "extensions": ["siv","sieve"]
  },
  "application/simple-filter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/simple-message-summary": {
    "source": "iana"
  },
  "application/simplesymbolcontainer": {
    "source": "iana"
  },
  "application/sipc": {
    "source": "iana"
  },
  "application/slate": {
    "source": "iana"
  },
  "application/smil": {
    "source": "iana"
  },
  "application/smil+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["smi","smil"]
  },
  "application/smpte336m": {
    "source": "iana"
  },
  "application/soap+fastinfoset": {
    "source": "iana"
  },
  "application/soap+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sparql-query": {
    "source": "iana",
    "extensions": ["rq"]
  },
  "application/sparql-results+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["srx"]
  },
  "application/spirits-event+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/sql": {
    "source": "iana"
  },
  "application/srgs": {
    "source": "iana",
    "extensions": ["gram"]
  },
  "application/srgs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["grxml"]
  },
  "application/sru+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sru"]
  },
  "application/ssdl+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ssdl"]
  },
  "application/ssml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ssml"]
  },
  "application/stix+json": {
    "source": "iana",
    "compressible": true
  },
  "application/swid+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["swidtag"]
  },
  "application/tamp-apex-update": {
    "source": "iana"
  },
  "application/tamp-apex-update-confirm": {
    "source": "iana"
  },
  "application/tamp-community-update": {
    "source": "iana"
  },
  "application/tamp-community-update-confirm": {
    "source": "iana"
  },
  "application/tamp-error": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust": {
    "source": "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    "source": "iana"
  },
  "application/tamp-status-query": {
    "source": "iana"
  },
  "application/tamp-status-response": {
    "source": "iana"
  },
  "application/tamp-update": {
    "source": "iana"
  },
  "application/tamp-update-confirm": {
    "source": "iana"
  },
  "application/tar": {
    "compressible": true
  },
  "application/taxii+json": {
    "source": "iana",
    "compressible": true
  },
  "application/td+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tei+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tei","teicorpus"]
  },
  "application/tetra_isi": {
    "source": "iana"
  },
  "application/thraud+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tfi"]
  },
  "application/timestamp-query": {
    "source": "iana"
  },
  "application/timestamp-reply": {
    "source": "iana"
  },
  "application/timestamped-data": {
    "source": "iana",
    "extensions": ["tsd"]
  },
  "application/tlsrpt+gzip": {
    "source": "iana"
  },
  "application/tlsrpt+json": {
    "source": "iana",
    "compressible": true
  },
  "application/tnauthlist": {
    "source": "iana"
  },
  "application/toml": {
    "compressible": true,
    "extensions": ["toml"]
  },
  "application/trickle-ice-sdpfrag": {
    "source": "iana"
  },
  "application/trig": {
    "source": "iana"
  },
  "application/ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttml"]
  },
  "application/tve-trigger": {
    "source": "iana"
  },
  "application/tzif": {
    "source": "iana"
  },
  "application/tzif-leap": {
    "source": "iana"
  },
  "application/ubjson": {
    "compressible": false,
    "extensions": ["ubj"]
  },
  "application/ulpfec": {
    "source": "iana"
  },
  "application/urc-grpsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/urc-ressheet+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rsheet"]
  },
  "application/urc-targetdesc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["td"]
  },
  "application/urc-uisocketdesc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vcard+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vemmi": {
    "source": "iana"
  },
  "application/vividence.scriptfile": {
    "source": "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["1km"]
  },
  "application/vnd.3gpp-prose+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    "source": "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.bsf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.gmop+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-payload": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    "source": "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.mid-call+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.pic-bw-large": {
    "source": "iana",
    "extensions": ["plb"]
  },
  "application/vnd.3gpp.pic-bw-small": {
    "source": "iana",
    "extensions": ["psb"]
  },
  "application/vnd.3gpp.pic-bw-var": {
    "source": "iana",
    "extensions": ["pvb"]
  },
  "application/vnd.3gpp.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp.ussd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.3gpp2.sms": {
    "source": "iana"
  },
  "application/vnd.3gpp2.tcap": {
    "source": "iana",
    "extensions": ["tcap"]
  },
  "application/vnd.3lightssoftware.imagescal": {
    "source": "iana"
  },
  "application/vnd.3m.post-it-notes": {
    "source": "iana",
    "extensions": ["pwn"]
  },
  "application/vnd.accpac.simply.aso": {
    "source": "iana",
    "extensions": ["aso"]
  },
  "application/vnd.accpac.simply.imp": {
    "source": "iana",
    "extensions": ["imp"]
  },
  "application/vnd.acucobol": {
    "source": "iana",
    "extensions": ["acu"]
  },
  "application/vnd.acucorp": {
    "source": "iana",
    "extensions": ["atc","acutc"]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["air"]
  },
  "application/vnd.adobe.flash.movie": {
    "source": "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    "source": "iana",
    "extensions": ["fcdt"]
  },
  "application/vnd.adobe.fxp": {
    "source": "iana",
    "extensions": ["fxp","fxpl"]
  },
  "application/vnd.adobe.partial-upload": {
    "source": "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdp"]
  },
  "application/vnd.adobe.xfdf": {
    "source": "iana",
    "extensions": ["xfdf"]
  },
  "application/vnd.aether.imp": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata": {
    "source": "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-charset": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    "source": "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    "source": "iana"
  },
  "application/vnd.afpc.modca": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    "source": "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    "source": "iana"
  },
  "application/vnd.ah-barcode": {
    "source": "iana"
  },
  "application/vnd.ahead.space": {
    "source": "iana",
    "extensions": ["ahead"]
  },
  "application/vnd.airzip.filesecure.azf": {
    "source": "iana",
    "extensions": ["azf"]
  },
  "application/vnd.airzip.filesecure.azs": {
    "source": "iana",
    "extensions": ["azs"]
  },
  "application/vnd.amadeus+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.amazon.ebook": {
    "source": "apache",
    "extensions": ["azw"]
  },
  "application/vnd.amazon.mobi8-ebook": {
    "source": "iana"
  },
  "application/vnd.americandynamics.acc": {
    "source": "iana",
    "extensions": ["acc"]
  },
  "application/vnd.amiga.ami": {
    "source": "iana",
    "extensions": ["ami"]
  },
  "application/vnd.amundsen.maze+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.android.ota": {
    "source": "iana"
  },
  "application/vnd.android.package-archive": {
    "source": "apache",
    "compressible": false,
    "extensions": ["apk"]
  },
  "application/vnd.anki": {
    "source": "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    "source": "iana",
    "extensions": ["cii"]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    "source": "apache",
    "extensions": ["fti"]
  },
  "application/vnd.antix.game-component": {
    "source": "iana",
    "extensions": ["atx"]
  },
  "application/vnd.apache.thrift.binary": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.compact": {
    "source": "iana"
  },
  "application/vnd.apache.thrift.json": {
    "source": "iana"
  },
  "application/vnd.api+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.aplextor.warrp+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apothekende.reservation+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.apple.installer+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mpkg"]
  },
  "application/vnd.apple.keynote": {
    "source": "iana",
    "extensions": ["key"]
  },
  "application/vnd.apple.mpegurl": {
    "source": "iana",
    "extensions": ["m3u8"]
  },
  "application/vnd.apple.numbers": {
    "source": "iana",
    "extensions": ["numbers"]
  },
  "application/vnd.apple.pages": {
    "source": "iana",
    "extensions": ["pages"]
  },
  "application/vnd.apple.pkpass": {
    "compressible": false,
    "extensions": ["pkpass"]
  },
  "application/vnd.arastra.swi": {
    "source": "iana"
  },
  "application/vnd.aristanetworks.swi": {
    "source": "iana",
    "extensions": ["swi"]
  },
  "application/vnd.artisan+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.artsquare": {
    "source": "iana"
  },
  "application/vnd.astraea-software.iota": {
    "source": "iana",
    "extensions": ["iota"]
  },
  "application/vnd.audiograph": {
    "source": "iana",
    "extensions": ["aep"]
  },
  "application/vnd.autopackage": {
    "source": "iana"
  },
  "application/vnd.avalon+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.avistar+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.balsamiq.bmml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmml"]
  },
  "application/vnd.balsamiq.bmpr": {
    "source": "iana"
  },
  "application/vnd.banana-accounting": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.error": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg": {
    "source": "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bekitzur-stech+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.bint.med-content": {
    "source": "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.blink-idb-value-wrapper": {
    "source": "iana"
  },
  "application/vnd.blueice.multipass": {
    "source": "iana",
    "extensions": ["mpm"]
  },
  "application/vnd.bluetooth.ep.oob": {
    "source": "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    "source": "iana"
  },
  "application/vnd.bmi": {
    "source": "iana",
    "extensions": ["bmi"]
  },
  "application/vnd.bpf": {
    "source": "iana"
  },
  "application/vnd.bpf3": {
    "source": "iana"
  },
  "application/vnd.businessobjects": {
    "source": "iana",
    "extensions": ["rep"]
  },
  "application/vnd.byu.uapi+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cab-jscript": {
    "source": "iana"
  },
  "application/vnd.canon-cpdl": {
    "source": "iana"
  },
  "application/vnd.canon-lips": {
    "source": "iana"
  },
  "application/vnd.capasystems-pg+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    "source": "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    "source": "iana"
  },
  "application/vnd.chemdraw+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["cdxml"]
  },
  "application/vnd.chess-pgn": {
    "source": "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    "source": "iana",
    "extensions": ["mmd"]
  },
  "application/vnd.ciedi": {
    "source": "iana"
  },
  "application/vnd.cinderella": {
    "source": "iana",
    "extensions": ["cdy"]
  },
  "application/vnd.cirpack.isdn-ext": {
    "source": "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csl"]
  },
  "application/vnd.claymore": {
    "source": "iana",
    "extensions": ["cla"]
  },
  "application/vnd.cloanto.rp9": {
    "source": "iana",
    "extensions": ["rp9"]
  },
  "application/vnd.clonk.c4group": {
    "source": "iana",
    "extensions": ["c4g","c4d","c4f","c4p","c4u"]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    "source": "iana",
    "extensions": ["c11amc"]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    "source": "iana",
    "extensions": ["c11amz"]
  },
  "application/vnd.coffeescript": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    "source": "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    "source": "iana"
  },
  "application/vnd.collection+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.doc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.collection.next+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.comicbook+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.comicbook-rar": {
    "source": "iana"
  },
  "application/vnd.commerce-battelle": {
    "source": "iana"
  },
  "application/vnd.commonspace": {
    "source": "iana",
    "extensions": ["csp"]
  },
  "application/vnd.contact.cmsg": {
    "source": "iana",
    "extensions": ["cdbcmsg"]
  },
  "application/vnd.coreos.ignition+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cosmocaller": {
    "source": "iana",
    "extensions": ["cmc"]
  },
  "application/vnd.crick.clicker": {
    "source": "iana",
    "extensions": ["clkx"]
  },
  "application/vnd.crick.clicker.keyboard": {
    "source": "iana",
    "extensions": ["clkk"]
  },
  "application/vnd.crick.clicker.palette": {
    "source": "iana",
    "extensions": ["clkp"]
  },
  "application/vnd.crick.clicker.template": {
    "source": "iana",
    "extensions": ["clkt"]
  },
  "application/vnd.crick.clicker.wordbank": {
    "source": "iana",
    "extensions": ["clkw"]
  },
  "application/vnd.criticaltools.wbs+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wbs"]
  },
  "application/vnd.cryptii.pipe+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.crypto-shade-file": {
    "source": "iana"
  },
  "application/vnd.ctc-posml": {
    "source": "iana",
    "extensions": ["pml"]
  },
  "application/vnd.ctct.ws+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cups-pdf": {
    "source": "iana"
  },
  "application/vnd.cups-postscript": {
    "source": "iana"
  },
  "application/vnd.cups-ppd": {
    "source": "iana",
    "extensions": ["ppd"]
  },
  "application/vnd.cups-raster": {
    "source": "iana"
  },
  "application/vnd.cups-raw": {
    "source": "iana"
  },
  "application/vnd.curl": {
    "source": "iana"
  },
  "application/vnd.curl.car": {
    "source": "apache",
    "extensions": ["car"]
  },
  "application/vnd.curl.pcurl": {
    "source": "apache",
    "extensions": ["pcurl"]
  },
  "application/vnd.cyan.dean.root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.cybank": {
    "source": "iana"
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.d3m-dataset": {
    "source": "iana"
  },
  "application/vnd.d3m-problem": {
    "source": "iana"
  },
  "application/vnd.dart": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dart"]
  },
  "application/vnd.data-vision.rdz": {
    "source": "iana",
    "extensions": ["rdz"]
  },
  "application/vnd.datapackage+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dataresource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dbf": {
    "source": "iana",
    "extensions": ["dbf"]
  },
  "application/vnd.debian.binary-package": {
    "source": "iana"
  },
  "application/vnd.dece.data": {
    "source": "iana",
    "extensions": ["uvf","uvvf","uvd","uvvd"]
  },
  "application/vnd.dece.ttml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uvt","uvvt"]
  },
  "application/vnd.dece.unspecified": {
    "source": "iana",
    "extensions": ["uvx","uvvx"]
  },
  "application/vnd.dece.zip": {
    "source": "iana",
    "extensions": ["uvz","uvvz"]
  },
  "application/vnd.denovo.fcselayout-link": {
    "source": "iana",
    "extensions": ["fe_launch"]
  },
  "application/vnd.desmume.movie": {
    "source": "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    "source": "iana"
  },
  "application/vnd.dm.delegation+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dna": {
    "source": "iana",
    "extensions": ["dna"]
  },
  "application/vnd.document+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dolby.mlp": {
    "source": "apache",
    "extensions": ["mlp"]
  },
  "application/vnd.dolby.mobile.1": {
    "source": "iana"
  },
  "application/vnd.dolby.mobile.2": {
    "source": "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    "source": "iana"
  },
  "application/vnd.dpgraph": {
    "source": "iana",
    "extensions": ["dpg"]
  },
  "application/vnd.dreamfactory": {
    "source": "iana",
    "extensions": ["dfac"]
  },
  "application/vnd.drive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ds-keypoint": {
    "source": "apache",
    "extensions": ["kpxx"]
  },
  "application/vnd.dtg.local": {
    "source": "iana"
  },
  "application/vnd.dtg.local.flash": {
    "source": "iana"
  },
  "application/vnd.dtg.local.html": {
    "source": "iana"
  },
  "application/vnd.dvb.ait": {
    "source": "iana",
    "extensions": ["ait"]
  },
  "application/vnd.dvb.dvbisl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.dvbj": {
    "source": "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    "source": "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    "source": "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    "source": "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-container+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-generic+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.notif-init+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.dvb.pfr": {
    "source": "iana"
  },
  "application/vnd.dvb.service": {
    "source": "iana",
    "extensions": ["svc"]
  },
  "application/vnd.dxr": {
    "source": "iana"
  },
  "application/vnd.dynageo": {
    "source": "iana",
    "extensions": ["geo"]
  },
  "application/vnd.dzr": {
    "source": "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    "source": "iana"
  },
  "application/vnd.ecdis-update": {
    "source": "iana"
  },
  "application/vnd.ecip.rlp": {
    "source": "iana"
  },
  "application/vnd.ecowin.chart": {
    "source": "iana",
    "extensions": ["mag"]
  },
  "application/vnd.ecowin.filerequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    "source": "iana"
  },
  "application/vnd.ecowin.series": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    "source": "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    "source": "iana"
  },
  "application/vnd.efi.img": {
    "source": "iana"
  },
  "application/vnd.efi.iso": {
    "source": "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.enliven": {
    "source": "iana",
    "extensions": ["nml"]
  },
  "application/vnd.enphase.envoy": {
    "source": "iana"
  },
  "application/vnd.eprints.data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.epson.esf": {
    "source": "iana",
    "extensions": ["esf"]
  },
  "application/vnd.epson.msf": {
    "source": "iana",
    "extensions": ["msf"]
  },
  "application/vnd.epson.quickanime": {
    "source": "iana",
    "extensions": ["qam"]
  },
  "application/vnd.epson.salt": {
    "source": "iana",
    "extensions": ["slt"]
  },
  "application/vnd.epson.ssf": {
    "source": "iana",
    "extensions": ["ssf"]
  },
  "application/vnd.ericsson.quickcall": {
    "source": "iana"
  },
  "application/vnd.espass-espass+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.eszigno3+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["es3","et3"]
  },
  "application/vnd.etsi.aoc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.asic-e+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.asic-s+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.etsi.cug+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvservice+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvsync+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mcid+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.mheg5": {
    "source": "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.pstn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.sci+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.simservs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.timestamp-token": {
    "source": "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.etsi.tsl.der": {
    "source": "iana"
  },
  "application/vnd.eudora.data": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    "source": "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    "source": "iana"
  },
  "application/vnd.exstream-empower+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.exstream-package": {
    "source": "iana"
  },
  "application/vnd.ezpix-album": {
    "source": "iana",
    "extensions": ["ez2"]
  },
  "application/vnd.ezpix-package": {
    "source": "iana",
    "extensions": ["ez3"]
  },
  "application/vnd.f-secure.mobile": {
    "source": "iana"
  },
  "application/vnd.fastcopy-disk-image": {
    "source": "iana"
  },
  "application/vnd.fdf": {
    "source": "iana",
    "extensions": ["fdf"]
  },
  "application/vnd.fdsn.mseed": {
    "source": "iana",
    "extensions": ["mseed"]
  },
  "application/vnd.fdsn.seed": {
    "source": "iana",
    "extensions": ["seed","dataless"]
  },
  "application/vnd.ffsns": {
    "source": "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.filmit.zfc": {
    "source": "iana"
  },
  "application/vnd.fints": {
    "source": "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    "source": "iana"
  },
  "application/vnd.flographit": {
    "source": "iana",
    "extensions": ["gph"]
  },
  "application/vnd.fluxtime.clip": {
    "source": "iana",
    "extensions": ["ftc"]
  },
  "application/vnd.font-fontforge-sfd": {
    "source": "iana"
  },
  "application/vnd.framemaker": {
    "source": "iana",
    "extensions": ["fm","frame","maker","book"]
  },
  "application/vnd.frogans.fnc": {
    "source": "iana",
    "extensions": ["fnc"]
  },
  "application/vnd.frogans.ltf": {
    "source": "iana",
    "extensions": ["ltf"]
  },
  "application/vnd.fsc.weblaunch": {
    "source": "iana",
    "extensions": ["fsc"]
  },
  "application/vnd.fujitsu.oasys": {
    "source": "iana",
    "extensions": ["oas"]
  },
  "application/vnd.fujitsu.oasys2": {
    "source": "iana",
    "extensions": ["oa2"]
  },
  "application/vnd.fujitsu.oasys3": {
    "source": "iana",
    "extensions": ["oa3"]
  },
  "application/vnd.fujitsu.oasysgp": {
    "source": "iana",
    "extensions": ["fg5"]
  },
  "application/vnd.fujitsu.oasysprs": {
    "source": "iana",
    "extensions": ["bh2"]
  },
  "application/vnd.fujixerox.art-ex": {
    "source": "iana"
  },
  "application/vnd.fujixerox.art4": {
    "source": "iana"
  },
  "application/vnd.fujixerox.ddd": {
    "source": "iana",
    "extensions": ["ddd"]
  },
  "application/vnd.fujixerox.docuworks": {
    "source": "iana",
    "extensions": ["xdw"]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    "source": "iana",
    "extensions": ["xbd"]
  },
  "application/vnd.fujixerox.docuworks.container": {
    "source": "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    "source": "iana"
  },
  "application/vnd.fut-misnet": {
    "source": "iana"
  },
  "application/vnd.futoin+cbor": {
    "source": "iana"
  },
  "application/vnd.futoin+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.fuzzysheet": {
    "source": "iana",
    "extensions": ["fzs"]
  },
  "application/vnd.genomatix.tuxedo": {
    "source": "iana",
    "extensions": ["txd"]
  },
  "application/vnd.gentics.grd+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geo+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geocube+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.geogebra.file": {
    "source": "iana",
    "extensions": ["ggb"]
  },
  "application/vnd.geogebra.tool": {
    "source": "iana",
    "extensions": ["ggt"]
  },
  "application/vnd.geometry-explorer": {
    "source": "iana",
    "extensions": ["gex","gre"]
  },
  "application/vnd.geonext": {
    "source": "iana",
    "extensions": ["gxt"]
  },
  "application/vnd.geoplan": {
    "source": "iana",
    "extensions": ["g2w"]
  },
  "application/vnd.geospace": {
    "source": "iana",
    "extensions": ["g3w"]
  },
  "application/vnd.gerber": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    "source": "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    "source": "iana"
  },
  "application/vnd.gmx": {
    "source": "iana",
    "extensions": ["gmx"]
  },
  "application/vnd.google-apps.document": {
    "compressible": false,
    "extensions": ["gdoc"]
  },
  "application/vnd.google-apps.presentation": {
    "compressible": false,
    "extensions": ["gslides"]
  },
  "application/vnd.google-apps.spreadsheet": {
    "compressible": false,
    "extensions": ["gsheet"]
  },
  "application/vnd.google-earth.kml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["kml"]
  },
  "application/vnd.google-earth.kmz": {
    "source": "iana",
    "compressible": false,
    "extensions": ["kmz"]
  },
  "application/vnd.gov.sk.e-form+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.gov.sk.e-form+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.grafeq": {
    "source": "iana",
    "extensions": ["gqf","gqs"]
  },
  "application/vnd.gridmp": {
    "source": "iana"
  },
  "application/vnd.groove-account": {
    "source": "iana",
    "extensions": ["gac"]
  },
  "application/vnd.groove-help": {
    "source": "iana",
    "extensions": ["ghf"]
  },
  "application/vnd.groove-identity-message": {
    "source": "iana",
    "extensions": ["gim"]
  },
  "application/vnd.groove-injector": {
    "source": "iana",
    "extensions": ["grv"]
  },
  "application/vnd.groove-tool-message": {
    "source": "iana",
    "extensions": ["gtm"]
  },
  "application/vnd.groove-tool-template": {
    "source": "iana",
    "extensions": ["tpl"]
  },
  "application/vnd.groove-vcard": {
    "source": "iana",
    "extensions": ["vcg"]
  },
  "application/vnd.hal+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hal+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["hal"]
  },
  "application/vnd.handheld-entertainment+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zmm"]
  },
  "application/vnd.hbci": {
    "source": "iana",
    "extensions": ["hbci"]
  },
  "application/vnd.hc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hcl-bireports": {
    "source": "iana"
  },
  "application/vnd.hdt": {
    "source": "iana"
  },
  "application/vnd.heroku+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hhe.lesson-player": {
    "source": "iana",
    "extensions": ["les"]
  },
  "application/vnd.hp-hpgl": {
    "source": "iana",
    "extensions": ["hpgl"]
  },
  "application/vnd.hp-hpid": {
    "source": "iana",
    "extensions": ["hpid"]
  },
  "application/vnd.hp-hps": {
    "source": "iana",
    "extensions": ["hps"]
  },
  "application/vnd.hp-jlyt": {
    "source": "iana",
    "extensions": ["jlt"]
  },
  "application/vnd.hp-pcl": {
    "source": "iana",
    "extensions": ["pcl"]
  },
  "application/vnd.hp-pclxl": {
    "source": "iana",
    "extensions": ["pclxl"]
  },
  "application/vnd.httphone": {
    "source": "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    "source": "iana",
    "extensions": ["sfd-hdstx"]
  },
  "application/vnd.hyper+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyper-item+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hyperdrive+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.hzn-3d-crossword": {
    "source": "iana"
  },
  "application/vnd.ibm.afplinedata": {
    "source": "iana"
  },
  "application/vnd.ibm.electronic-media": {
    "source": "iana"
  },
  "application/vnd.ibm.minipay": {
    "source": "iana",
    "extensions": ["mpy"]
  },
  "application/vnd.ibm.modcap": {
    "source": "iana",
    "extensions": ["afp","listafp","list3820"]
  },
  "application/vnd.ibm.rights-management": {
    "source": "iana",
    "extensions": ["irm"]
  },
  "application/vnd.ibm.secure-container": {
    "source": "iana",
    "extensions": ["sc"]
  },
  "application/vnd.iccprofile": {
    "source": "iana",
    "extensions": ["icc","icm"]
  },
  "application/vnd.ieee.1905": {
    "source": "iana"
  },
  "application/vnd.igloader": {
    "source": "iana",
    "extensions": ["igl"]
  },
  "application/vnd.imagemeter.folder+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.imagemeter.image+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.immervision-ivp": {
    "source": "iana",
    "extensions": ["ivp"]
  },
  "application/vnd.immervision-ivu": {
    "source": "iana",
    "extensions": ["ivu"]
  },
  "application/vnd.ims.imsccv1p1": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    "source": "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    "source": "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informedcontrol.rms+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.informix-visionary": {
    "source": "iana"
  },
  "application/vnd.infotech.project": {
    "source": "iana"
  },
  "application/vnd.infotech.project+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.innopath.wamp.notification": {
    "source": "iana"
  },
  "application/vnd.insors.igm": {
    "source": "iana",
    "extensions": ["igm"]
  },
  "application/vnd.intercon.formnet": {
    "source": "iana",
    "extensions": ["xpw","xpx"]
  },
  "application/vnd.intergeo": {
    "source": "iana",
    "extensions": ["i2g"]
  },
  "application/vnd.intertrust.digibox": {
    "source": "iana"
  },
  "application/vnd.intertrust.nncp": {
    "source": "iana"
  },
  "application/vnd.intu.qbo": {
    "source": "iana",
    "extensions": ["qbo"]
  },
  "application/vnd.intu.qfx": {
    "source": "iana",
    "extensions": ["qfx"]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ipunplugged.rcprofile": {
    "source": "iana",
    "extensions": ["rcprofile"]
  },
  "application/vnd.irepository.package+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["irp"]
  },
  "application/vnd.is-xpr": {
    "source": "iana",
    "extensions": ["xpr"]
  },
  "application/vnd.isac.fcs": {
    "source": "iana",
    "extensions": ["fcs"]
  },
  "application/vnd.iso11783-10+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.jam": {
    "source": "iana",
    "extensions": ["jam"]
  },
  "application/vnd.japannet-directory-service": {
    "source": "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-registration": {
    "source": "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    "source": "iana"
  },
  "application/vnd.japannet-verification": {
    "source": "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    "source": "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    "source": "iana",
    "extensions": ["rms"]
  },
  "application/vnd.jisp": {
    "source": "iana",
    "extensions": ["jisp"]
  },
  "application/vnd.joost.joda-archive": {
    "source": "iana",
    "extensions": ["joda"]
  },
  "application/vnd.jsk.isdn-ngn": {
    "source": "iana"
  },
  "application/vnd.kahootz": {
    "source": "iana",
    "extensions": ["ktz","ktr"]
  },
  "application/vnd.kde.karbon": {
    "source": "iana",
    "extensions": ["karbon"]
  },
  "application/vnd.kde.kchart": {
    "source": "iana",
    "extensions": ["chrt"]
  },
  "application/vnd.kde.kformula": {
    "source": "iana",
    "extensions": ["kfo"]
  },
  "application/vnd.kde.kivio": {
    "source": "iana",
    "extensions": ["flw"]
  },
  "application/vnd.kde.kontour": {
    "source": "iana",
    "extensions": ["kon"]
  },
  "application/vnd.kde.kpresenter": {
    "source": "iana",
    "extensions": ["kpr","kpt"]
  },
  "application/vnd.kde.kspread": {
    "source": "iana",
    "extensions": ["ksp"]
  },
  "application/vnd.kde.kword": {
    "source": "iana",
    "extensions": ["kwd","kwt"]
  },
  "application/vnd.kenameaapp": {
    "source": "iana",
    "extensions": ["htke"]
  },
  "application/vnd.kidspiration": {
    "source": "iana",
    "extensions": ["kia"]
  },
  "application/vnd.kinar": {
    "source": "iana",
    "extensions": ["kne","knp"]
  },
  "application/vnd.koan": {
    "source": "iana",
    "extensions": ["skp","skd","skt","skm"]
  },
  "application/vnd.kodak-descriptor": {
    "source": "iana",
    "extensions": ["sse"]
  },
  "application/vnd.las": {
    "source": "iana"
  },
  "application/vnd.las.las+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.las.las+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lasxml"]
  },
  "application/vnd.laszip": {
    "source": "iana"
  },
  "application/vnd.leap+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.liberty-request+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    "source": "iana",
    "extensions": ["lbd"]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["lbe"]
  },
  "application/vnd.logipipe.circuit+zip": {
    "source": "iana",
    "compressible": false
  },
  "application/vnd.loom": {
    "source": "iana"
  },
  "application/vnd.lotus-1-2-3": {
    "source": "iana",
    "extensions": ["123"]
  },
  "application/vnd.lotus-approach": {
    "source": "iana",
    "extensions": ["apr"]
  },
  "application/vnd.lotus-freelance": {
    "source": "iana",
    "extensions": ["pre"]
  },
  "application/vnd.lotus-notes": {
    "source": "iana",
    "extensions": ["nsf"]
  },
  "application/vnd.lotus-organizer": {
    "source": "iana",
    "extensions": ["org"]
  },
  "application/vnd.lotus-screencam": {
    "source": "iana",
    "extensions": ["scm"]
  },
  "application/vnd.lotus-wordpro": {
    "source": "iana",
    "extensions": ["lwp"]
  },
  "application/vnd.macports.portpkg": {
    "source": "iana",
    "extensions": ["portpkg"]
  },
  "application/vnd.mapbox-vector-tile": {
    "source": "iana"
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.license+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.marlin.drm.mdcf": {
    "source": "iana"
  },
  "application/vnd.mason+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.maxmind.maxmind-db": {
    "source": "iana"
  },
  "application/vnd.mcd": {
    "source": "iana",
    "extensions": ["mcd"]
  },
  "application/vnd.medcalcdata": {
    "source": "iana",
    "extensions": ["mc1"]
  },
  "application/vnd.mediastation.cdkey": {
    "source": "iana",
    "extensions": ["cdkey"]
  },
  "application/vnd.meridian-slingshot": {
    "source": "iana"
  },
  "application/vnd.mfer": {
    "source": "iana",
    "extensions": ["mwf"]
  },
  "application/vnd.mfmp": {
    "source": "iana",
    "extensions": ["mfm"]
  },
  "application/vnd.micro+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.micrografx.flo": {
    "source": "iana",
    "extensions": ["flo"]
  },
  "application/vnd.micrografx.igx": {
    "source": "iana",
    "extensions": ["igx"]
  },
  "application/vnd.microsoft.portable-executable": {
    "source": "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    "source": "iana"
  },
  "application/vnd.miele+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.mif": {
    "source": "iana",
    "extensions": ["mif"]
  },
  "application/vnd.minisoft-hp3000-save": {
    "source": "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    "source": "iana"
  },
  "application/vnd.mobius.daf": {
    "source": "iana",
    "extensions": ["daf"]
  },
  "application/vnd.mobius.dis": {
    "source": "iana",
    "extensions": ["dis"]
  },
  "application/vnd.mobius.mbk": {
    "source": "iana",
    "extensions": ["mbk"]
  },
  "application/vnd.mobius.mqy": {
    "source": "iana",
    "extensions": ["mqy"]
  },
  "application/vnd.mobius.msl": {
    "source": "iana",
    "extensions": ["msl"]
  },
  "application/vnd.mobius.plc": {
    "source": "iana",
    "extensions": ["plc"]
  },
  "application/vnd.mobius.txf": {
    "source": "iana",
    "extensions": ["txf"]
  },
  "application/vnd.mophun.application": {
    "source": "iana",
    "extensions": ["mpn"]
  },
  "application/vnd.mophun.certificate": {
    "source": "iana",
    "extensions": ["mpc"]
  },
  "application/vnd.motorola.flexsuite": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    "source": "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    "source": "iana"
  },
  "application/vnd.motorola.iprm": {
    "source": "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xul"]
  },
  "application/vnd.ms-3mfdocument": {
    "source": "iana"
  },
  "application/vnd.ms-artgalry": {
    "source": "iana",
    "extensions": ["cil"]
  },
  "application/vnd.ms-asf": {
    "source": "iana"
  },
  "application/vnd.ms-cab-compressed": {
    "source": "iana",
    "extensions": ["cab"]
  },
  "application/vnd.ms-color.iccprofile": {
    "source": "apache"
  },
  "application/vnd.ms-excel": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xls","xlm","xla","xlc","xlt","xlw"]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlam"]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsb"]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    "source": "iana",
    "extensions": ["xlsm"]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["xltm"]
  },
  "application/vnd.ms-fontobject": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eot"]
  },
  "application/vnd.ms-htmlhelp": {
    "source": "iana",
    "extensions": ["chm"]
  },
  "application/vnd.ms-ims": {
    "source": "iana",
    "extensions": ["ims"]
  },
  "application/vnd.ms-lrm": {
    "source": "iana",
    "extensions": ["lrm"]
  },
  "application/vnd.ms-office.activex+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-officetheme": {
    "source": "iana",
    "extensions": ["thmx"]
  },
  "application/vnd.ms-opentype": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-outlook": {
    "compressible": false,
    "extensions": ["msg"]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    "source": "apache"
  },
  "application/vnd.ms-pki.seccat": {
    "source": "apache",
    "extensions": ["cat"]
  },
  "application/vnd.ms-pki.stl": {
    "source": "apache",
    "extensions": ["stl"]
  },
  "application/vnd.ms-playready.initiator+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-powerpoint": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ppt","pps","pot"]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppam"]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    "source": "iana",
    "extensions": ["pptm"]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    "source": "iana",
    "extensions": ["sldm"]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    "source": "iana",
    "extensions": ["ppsm"]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["potm"]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-printing.printticket+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/vnd.ms-printschematicket+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.ms-project": {
    "source": "iana",
    "extensions": ["mpp","mpt"]
  },
  "application/vnd.ms-tnef": {
    "source": "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    "source": "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    "source": "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    "source": "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    "source": "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    "source": "iana",
    "extensions": ["docm"]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    "source": "iana",
    "extensions": ["dotm"]
  },
  "application/vnd.ms-works": {
    "source": "iana",
    "extensions": ["wps","wks","wcm","wdb"]
  },
  "application/vnd.ms-wpl": {
    "source": "iana",
    "extensions": ["wpl"]
  },
  "application/vnd.ms-xpsdocument": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xps"]
  },
  "application/vnd.msa-disk-image": {
    "source": "iana"
  },
  "application/vnd.mseq": {
    "source": "iana",
    "extensions": ["mseq"]
  },
  "application/vnd.msign": {
    "source": "iana"
  },
  "application/vnd.multiad.creator": {
    "source": "iana"
  },
  "application/vnd.multiad.creator.cif": {
    "source": "iana"
  },
  "application/vnd.music-niff": {
    "source": "iana"
  },
  "application/vnd.musician": {
    "source": "iana",
    "extensions": ["mus"]
  },
  "application/vnd.muvee.style": {
    "source": "iana",
    "extensions": ["msty"]
  },
  "application/vnd.mynfc": {
    "source": "iana",
    "extensions": ["taglet"]
  },
  "application/vnd.ncd.control": {
    "source": "iana"
  },
  "application/vnd.ncd.reference": {
    "source": "iana"
  },
  "application/vnd.nearst.inv+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nervana": {
    "source": "iana"
  },
  "application/vnd.netfpx": {
    "source": "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    "source": "iana",
    "extensions": ["nlu"]
  },
  "application/vnd.nimn": {
    "source": "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    "source": "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    "source": "iana"
  },
  "application/vnd.nitf": {
    "source": "iana",
    "extensions": ["ntf","nitf"]
  },
  "application/vnd.noblenet-directory": {
    "source": "iana",
    "extensions": ["nnd"]
  },
  "application/vnd.noblenet-sealer": {
    "source": "iana",
    "extensions": ["nns"]
  },
  "application/vnd.noblenet-web": {
    "source": "iana",
    "extensions": ["nnw"]
  },
  "application/vnd.nokia.catalogs": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.conml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.iptv.config+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.isds-radio-presets": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ac"]
  },
  "application/vnd.nokia.n-gage.data": {
    "source": "iana",
    "extensions": ["ngdat"]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    "source": "iana",
    "extensions": ["n-gage"]
  },
  "application/vnd.nokia.ncd": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    "source": "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.nokia.radio-preset": {
    "source": "iana",
    "extensions": ["rpst"]
  },
  "application/vnd.nokia.radio-presets": {
    "source": "iana",
    "extensions": ["rpss"]
  },
  "application/vnd.novadigm.edm": {
    "source": "iana",
    "extensions": ["edm"]
  },
  "application/vnd.novadigm.edx": {
    "source": "iana",
    "extensions": ["edx"]
  },
  "application/vnd.novadigm.ext": {
    "source": "iana",
    "extensions": ["ext"]
  },
  "application/vnd.ntt-local.content-share": {
    "source": "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    "source": "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    "source": "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    "source": "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    "source": "iana",
    "extensions": ["odc"]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    "source": "iana",
    "extensions": ["otc"]
  },
  "application/vnd.oasis.opendocument.database": {
    "source": "iana",
    "extensions": ["odb"]
  },
  "application/vnd.oasis.opendocument.formula": {
    "source": "iana",
    "extensions": ["odf"]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    "source": "iana",
    "extensions": ["odft"]
  },
  "application/vnd.oasis.opendocument.graphics": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odg"]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    "source": "iana",
    "extensions": ["otg"]
  },
  "application/vnd.oasis.opendocument.image": {
    "source": "iana",
    "extensions": ["odi"]
  },
  "application/vnd.oasis.opendocument.image-template": {
    "source": "iana",
    "extensions": ["oti"]
  },
  "application/vnd.oasis.opendocument.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odp"]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    "source": "iana",
    "extensions": ["otp"]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ods"]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    "source": "iana",
    "extensions": ["ots"]
  },
  "application/vnd.oasis.opendocument.text": {
    "source": "iana",
    "compressible": false,
    "extensions": ["odt"]
  },
  "application/vnd.oasis.opendocument.text-master": {
    "source": "iana",
    "extensions": ["odm"]
  },
  "application/vnd.oasis.opendocument.text-template": {
    "source": "iana",
    "extensions": ["ott"]
  },
  "application/vnd.oasis.opendocument.text-web": {
    "source": "iana",
    "extensions": ["oth"]
  },
  "application/vnd.obn": {
    "source": "iana"
  },
  "application/vnd.ocf+cbor": {
    "source": "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oftn.l10n+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    "source": "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.pae.gem": {
    "source": "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.spdlist+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.ueprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oipf.userprofile+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.olpc-sugar": {
    "source": "iana",
    "extensions": ["xo"]
  },
  "application/vnd.oma-scws-config": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-request": {
    "source": "iana"
  },
  "application/vnd.oma-scws-http-response": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.imd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.ltkm": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sgdu": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    "source": "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.bcast.stkm": {
    "source": "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-pcc+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.dcd": {
    "source": "iana"
  },
  "application/vnd.oma.dcdc": {
    "source": "iana"
  },
  "application/vnd.oma.dd2+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dd2"]
  },
  "application/vnd.oma.drm.risd+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.group-usage-list+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+cbor": {
    "source": "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.lwm2m+tlv": {
    "source": "iana"
  },
  "application/vnd.oma.pal+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.final-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.groups+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.push": {
    "source": "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oma.xcap-directory+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.omads-email+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-file+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omads-folder+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.omaloc-supl-init": {
    "source": "iana"
  },
  "application/vnd.onepager": {
    "source": "iana"
  },
  "application/vnd.onepagertamp": {
    "source": "iana"
  },
  "application/vnd.onepagertamx": {
    "source": "iana"
  },
  "application/vnd.onepagertat": {
    "source": "iana"
  },
  "application/vnd.onepagertatp": {
    "source": "iana"
  },
  "application/vnd.onepagertatx": {
    "source": "iana"
  },
  "application/vnd.openblox.game+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["obgx"]
  },
  "application/vnd.openblox.game-binary": {
    "source": "iana"
  },
  "application/vnd.openeye.oeb": {
    "source": "iana"
  },
  "application/vnd.openofficeorg.extension": {
    "source": "apache",
    "extensions": ["oxt"]
  },
  "application/vnd.openstreetmap.data+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osm"]
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pptx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    "source": "iana",
    "extensions": ["sldx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    "source": "iana",
    "extensions": ["ppsx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    "source": "iana",
    "extensions": ["potx"]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    "source": "iana",
    "compressible": false,
    "extensions": ["xlsx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    "source": "iana",
    "extensions": ["xltx"]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    "source": "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    "source": "iana",
    "compressible": false,
    "extensions": ["docx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    "source": "iana",
    "extensions": ["dotx"]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oracle.resource+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.orange.indata": {
    "source": "iana"
  },
  "application/vnd.osa.netdeploy": {
    "source": "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    "source": "iana",
    "extensions": ["mgp"]
  },
  "application/vnd.osgi.bundle": {
    "source": "iana"
  },
  "application/vnd.osgi.dp": {
    "source": "iana",
    "extensions": ["dp"]
  },
  "application/vnd.osgi.subsystem": {
    "source": "iana",
    "extensions": ["esa"]
  },
  "application/vnd.otps.ct-kip+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.oxli.countgraph": {
    "source": "iana"
  },
  "application/vnd.pagerduty+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.palm": {
    "source": "iana",
    "extensions": ["pdb","pqa","oprc"]
  },
  "application/vnd.panoply": {
    "source": "iana"
  },
  "application/vnd.paos.xml": {
    "source": "iana"
  },
  "application/vnd.patentdive": {
    "source": "iana"
  },
  "application/vnd.patientecommsdoc": {
    "source": "iana"
  },
  "application/vnd.pawaafile": {
    "source": "iana",
    "extensions": ["paw"]
  },
  "application/vnd.pcos": {
    "source": "iana"
  },
  "application/vnd.pg.format": {
    "source": "iana",
    "extensions": ["str"]
  },
  "application/vnd.pg.osasli": {
    "source": "iana",
    "extensions": ["ei6"]
  },
  "application/vnd.piaccess.application-licence": {
    "source": "iana"
  },
  "application/vnd.picsel": {
    "source": "iana",
    "extensions": ["efif"]
  },
  "application/vnd.pmi.widget": {
    "source": "iana",
    "extensions": ["wg"]
  },
  "application/vnd.poc.group-advertisement+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.pocketlearn": {
    "source": "iana",
    "extensions": ["plf"]
  },
  "application/vnd.powerbuilder6": {
    "source": "iana",
    "extensions": ["pbd"]
  },
  "application/vnd.powerbuilder6-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7": {
    "source": "iana"
  },
  "application/vnd.powerbuilder7-s": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75": {
    "source": "iana"
  },
  "application/vnd.powerbuilder75-s": {
    "source": "iana"
  },
  "application/vnd.preminet": {
    "source": "iana"
  },
  "application/vnd.previewsystems.box": {
    "source": "iana",
    "extensions": ["box"]
  },
  "application/vnd.proteus.magazine": {
    "source": "iana",
    "extensions": ["mgz"]
  },
  "application/vnd.psfs": {
    "source": "iana"
  },
  "application/vnd.publishare-delta-tree": {
    "source": "iana",
    "extensions": ["qps"]
  },
  "application/vnd.pvi.ptid1": {
    "source": "iana",
    "extensions": ["ptid"]
  },
  "application/vnd.pwg-multiplexed": {
    "source": "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.qualcomm.brew-app-res": {
    "source": "iana"
  },
  "application/vnd.quarantainenet": {
    "source": "iana"
  },
  "application/vnd.quark.quarkxpress": {
    "source": "iana",
    "extensions": ["qxd","qxt","qwd","qwt","qxl","qxb"]
  },
  "application/vnd.quobject-quoxdocument": {
    "source": "iana"
  },
  "application/vnd.radisys.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-conf+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rainstor.data": {
    "source": "iana"
  },
  "application/vnd.rapid": {
    "source": "iana"
  },
  "application/vnd.rar": {
    "source": "iana",
    "extensions": ["rar"]
  },
  "application/vnd.realvnc.bed": {
    "source": "iana",
    "extensions": ["bed"]
  },
  "application/vnd.recordare.musicxml": {
    "source": "iana",
    "extensions": ["mxl"]
  },
  "application/vnd.recordare.musicxml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["musicxml"]
  },
  "application/vnd.renlearn.rlprint": {
    "source": "iana"
  },
  "application/vnd.restful+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.rig.cryptonote": {
    "source": "iana",
    "extensions": ["cryptonote"]
  },
  "application/vnd.rim.cod": {
    "source": "apache",
    "extensions": ["cod"]
  },
  "application/vnd.rn-realmedia": {
    "source": "apache",
    "extensions": ["rm"]
  },
  "application/vnd.rn-realmedia-vbr": {
    "source": "apache",
    "extensions": ["rmvb"]
  },
  "application/vnd.route66.link66+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["link66"]
  },
  "application/vnd.rs-274x": {
    "source": "iana"
  },
  "application/vnd.ruckus.download": {
    "source": "iana"
  },
  "application/vnd.s3sms": {
    "source": "iana"
  },
  "application/vnd.sailingtracker.track": {
    "source": "iana",
    "extensions": ["st"]
  },
  "application/vnd.sar": {
    "source": "iana"
  },
  "application/vnd.sbm.cid": {
    "source": "iana"
  },
  "application/vnd.sbm.mid2": {
    "source": "iana"
  },
  "application/vnd.scribus": {
    "source": "iana"
  },
  "application/vnd.sealed.3df": {
    "source": "iana"
  },
  "application/vnd.sealed.csf": {
    "source": "iana"
  },
  "application/vnd.sealed.doc": {
    "source": "iana"
  },
  "application/vnd.sealed.eml": {
    "source": "iana"
  },
  "application/vnd.sealed.mht": {
    "source": "iana"
  },
  "application/vnd.sealed.net": {
    "source": "iana"
  },
  "application/vnd.sealed.ppt": {
    "source": "iana"
  },
  "application/vnd.sealed.tiff": {
    "source": "iana"
  },
  "application/vnd.sealed.xls": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    "source": "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    "source": "iana"
  },
  "application/vnd.seemail": {
    "source": "iana",
    "extensions": ["see"]
  },
  "application/vnd.sema": {
    "source": "iana",
    "extensions": ["sema"]
  },
  "application/vnd.semd": {
    "source": "iana",
    "extensions": ["semd"]
  },
  "application/vnd.semf": {
    "source": "iana",
    "extensions": ["semf"]
  },
  "application/vnd.shade-save-file": {
    "source": "iana"
  },
  "application/vnd.shana.informed.formdata": {
    "source": "iana",
    "extensions": ["ifm"]
  },
  "application/vnd.shana.informed.formtemplate": {
    "source": "iana",
    "extensions": ["itp"]
  },
  "application/vnd.shana.informed.interchange": {
    "source": "iana",
    "extensions": ["iif"]
  },
  "application/vnd.shana.informed.package": {
    "source": "iana",
    "extensions": ["ipk"]
  },
  "application/vnd.shootproof+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shopkick+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.shp": {
    "source": "iana"
  },
  "application/vnd.shx": {
    "source": "iana"
  },
  "application/vnd.sigrok.session": {
    "source": "iana"
  },
  "application/vnd.simtech-mindmapper": {
    "source": "iana",
    "extensions": ["twd","twds"]
  },
  "application/vnd.siren+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.smaf": {
    "source": "iana",
    "extensions": ["mmf"]
  },
  "application/vnd.smart.notebook": {
    "source": "iana"
  },
  "application/vnd.smart.teacher": {
    "source": "iana",
    "extensions": ["teacher"]
  },
  "application/vnd.snesdev-page-table": {
    "source": "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["fo"]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    "source": "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["sdkm","sdkd"]
  },
  "application/vnd.spotfire.dxp": {
    "source": "iana",
    "extensions": ["dxp"]
  },
  "application/vnd.spotfire.sfs": {
    "source": "iana",
    "extensions": ["sfs"]
  },
  "application/vnd.sqlite3": {
    "source": "iana"
  },
  "application/vnd.sss-cod": {
    "source": "iana"
  },
  "application/vnd.sss-dtf": {
    "source": "iana"
  },
  "application/vnd.sss-ntf": {
    "source": "iana"
  },
  "application/vnd.stardivision.calc": {
    "source": "apache",
    "extensions": ["sdc"]
  },
  "application/vnd.stardivision.draw": {
    "source": "apache",
    "extensions": ["sda"]
  },
  "application/vnd.stardivision.impress": {
    "source": "apache",
    "extensions": ["sdd"]
  },
  "application/vnd.stardivision.math": {
    "source": "apache",
    "extensions": ["smf"]
  },
  "application/vnd.stardivision.writer": {
    "source": "apache",
    "extensions": ["sdw","vor"]
  },
  "application/vnd.stardivision.writer-global": {
    "source": "apache",
    "extensions": ["sgl"]
  },
  "application/vnd.stepmania.package": {
    "source": "iana",
    "extensions": ["smzip"]
  },
  "application/vnd.stepmania.stepchart": {
    "source": "iana",
    "extensions": ["sm"]
  },
  "application/vnd.street-stream": {
    "source": "iana"
  },
  "application/vnd.sun.wadl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wadl"]
  },
  "application/vnd.sun.xml.calc": {
    "source": "apache",
    "extensions": ["sxc"]
  },
  "application/vnd.sun.xml.calc.template": {
    "source": "apache",
    "extensions": ["stc"]
  },
  "application/vnd.sun.xml.draw": {
    "source": "apache",
    "extensions": ["sxd"]
  },
  "application/vnd.sun.xml.draw.template": {
    "source": "apache",
    "extensions": ["std"]
  },
  "application/vnd.sun.xml.impress": {
    "source": "apache",
    "extensions": ["sxi"]
  },
  "application/vnd.sun.xml.impress.template": {
    "source": "apache",
    "extensions": ["sti"]
  },
  "application/vnd.sun.xml.math": {
    "source": "apache",
    "extensions": ["sxm"]
  },
  "application/vnd.sun.xml.writer": {
    "source": "apache",
    "extensions": ["sxw"]
  },
  "application/vnd.sun.xml.writer.global": {
    "source": "apache",
    "extensions": ["sxg"]
  },
  "application/vnd.sun.xml.writer.template": {
    "source": "apache",
    "extensions": ["stw"]
  },
  "application/vnd.sus-calendar": {
    "source": "iana",
    "extensions": ["sus","susp"]
  },
  "application/vnd.svd": {
    "source": "iana",
    "extensions": ["svd"]
  },
  "application/vnd.swiftview-ics": {
    "source": "iana"
  },
  "application/vnd.sycle+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.symbian.install": {
    "source": "apache",
    "extensions": ["sis","sisx"]
  },
  "application/vnd.syncml+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xsm"]
  },
  "application/vnd.syncml.dm+wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["bdm"]
  },
  "application/vnd.syncml.dm+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["xdm"]
  },
  "application/vnd.syncml.dm.notification": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["ddf"]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    "source": "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true
  },
  "application/vnd.syncml.ds.notification": {
    "source": "iana"
  },
  "application/vnd.tableschema+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tao.intent-module-archive": {
    "source": "iana",
    "extensions": ["tao"]
  },
  "application/vnd.tcpdump.pcap": {
    "source": "iana",
    "extensions": ["pcap","cap","dmp"]
  },
  "application/vnd.think-cell.ppttc+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.tml": {
    "source": "iana"
  },
  "application/vnd.tmobile-livetv": {
    "source": "iana",
    "extensions": ["tmo"]
  },
  "application/vnd.tri.onesource": {
    "source": "iana"
  },
  "application/vnd.trid.tpt": {
    "source": "iana",
    "extensions": ["tpt"]
  },
  "application/vnd.triscape.mxs": {
    "source": "iana",
    "extensions": ["mxs"]
  },
  "application/vnd.trueapp": {
    "source": "iana",
    "extensions": ["tra"]
  },
  "application/vnd.truedoc": {
    "source": "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    "source": "iana"
  },
  "application/vnd.ufdl": {
    "source": "iana",
    "extensions": ["ufd","ufdl"]
  },
  "application/vnd.uiq.theme": {
    "source": "iana",
    "extensions": ["utz"]
  },
  "application/vnd.umajin": {
    "source": "iana",
    "extensions": ["umj"]
  },
  "application/vnd.unity": {
    "source": "iana",
    "extensions": ["unityweb"]
  },
  "application/vnd.uoml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uoml"]
  },
  "application/vnd.uplanet.alert": {
    "source": "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    "source": "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop": {
    "source": "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel": {
    "source": "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.list": {
    "source": "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd": {
    "source": "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    "source": "iana"
  },
  "application/vnd.uplanet.signal": {
    "source": "iana"
  },
  "application/vnd.uri-map": {
    "source": "iana"
  },
  "application/vnd.valve.source.material": {
    "source": "iana"
  },
  "application/vnd.vcx": {
    "source": "iana",
    "extensions": ["vcx"]
  },
  "application/vnd.vd-study": {
    "source": "iana"
  },
  "application/vnd.vectorworks": {
    "source": "iana"
  },
  "application/vnd.vel+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.verimatrix.vcas": {
    "source": "iana"
  },
  "application/vnd.veryant.thin": {
    "source": "iana"
  },
  "application/vnd.ves.encrypted": {
    "source": "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    "source": "iana"
  },
  "application/vnd.visio": {
    "source": "iana",
    "extensions": ["vsd","vst","vss","vsw"]
  },
  "application/vnd.visionary": {
    "source": "iana",
    "extensions": ["vis"]
  },
  "application/vnd.vividence.scriptfile": {
    "source": "iana"
  },
  "application/vnd.vsf": {
    "source": "iana",
    "extensions": ["vsf"]
  },
  "application/vnd.wap.sic": {
    "source": "iana"
  },
  "application/vnd.wap.slc": {
    "source": "iana"
  },
  "application/vnd.wap.wbxml": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["wbxml"]
  },
  "application/vnd.wap.wmlc": {
    "source": "iana",
    "extensions": ["wmlc"]
  },
  "application/vnd.wap.wmlscriptc": {
    "source": "iana",
    "extensions": ["wmlsc"]
  },
  "application/vnd.webturbo": {
    "source": "iana",
    "extensions": ["wtb"]
  },
  "application/vnd.wfa.p2p": {
    "source": "iana"
  },
  "application/vnd.wfa.wsc": {
    "source": "iana"
  },
  "application/vnd.windows.devicepairing": {
    "source": "iana"
  },
  "application/vnd.wmc": {
    "source": "iana"
  },
  "application/vnd.wmf.bootstrap": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica": {
    "source": "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    "source": "iana"
  },
  "application/vnd.wolfram.player": {
    "source": "iana",
    "extensions": ["nbp"]
  },
  "application/vnd.wordperfect": {
    "source": "iana",
    "extensions": ["wpd"]
  },
  "application/vnd.wqd": {
    "source": "iana",
    "extensions": ["wqd"]
  },
  "application/vnd.wrq-hp3000-labelled": {
    "source": "iana"
  },
  "application/vnd.wt.stf": {
    "source": "iana",
    "extensions": ["stf"]
  },
  "application/vnd.wv.csp+wbxml": {
    "source": "iana"
  },
  "application/vnd.wv.csp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.wv.ssp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xacml+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xara": {
    "source": "iana",
    "extensions": ["xar"]
  },
  "application/vnd.xfdl": {
    "source": "iana",
    "extensions": ["xfdl"]
  },
  "application/vnd.xfdl.webform": {
    "source": "iana"
  },
  "application/vnd.xmi+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/vnd.xmpie.cpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.dpkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.plan": {
    "source": "iana"
  },
  "application/vnd.xmpie.ppkg": {
    "source": "iana"
  },
  "application/vnd.xmpie.xlim": {
    "source": "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    "source": "iana",
    "extensions": ["hvd"]
  },
  "application/vnd.yamaha.hv-script": {
    "source": "iana",
    "extensions": ["hvs"]
  },
  "application/vnd.yamaha.hv-voice": {
    "source": "iana",
    "extensions": ["hvp"]
  },
  "application/vnd.yamaha.openscoreformat": {
    "source": "iana",
    "extensions": ["osf"]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["osfpvg"]
  },
  "application/vnd.yamaha.remote-setup": {
    "source": "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    "source": "iana",
    "extensions": ["saf"]
  },
  "application/vnd.yamaha.smaf-phrase": {
    "source": "iana",
    "extensions": ["spf"]
  },
  "application/vnd.yamaha.through-ngn": {
    "source": "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    "source": "iana"
  },
  "application/vnd.yaoweme": {
    "source": "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    "source": "iana",
    "extensions": ["cmp"]
  },
  "application/vnd.youtube.yt": {
    "source": "iana"
  },
  "application/vnd.zul": {
    "source": "iana",
    "extensions": ["zir","zirz"]
  },
  "application/vnd.zzazz.deck+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["zaz"]
  },
  "application/voicexml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vxml"]
  },
  "application/voucher-cms+json": {
    "source": "iana",
    "compressible": true
  },
  "application/vq-rtcpxr": {
    "source": "iana"
  },
  "application/wasm": {
    "compressible": true,
    "extensions": ["wasm"]
  },
  "application/watcherinfo+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/webpush-options+json": {
    "source": "iana",
    "compressible": true
  },
  "application/whoispp-query": {
    "source": "iana"
  },
  "application/whoispp-response": {
    "source": "iana"
  },
  "application/widget": {
    "source": "iana",
    "extensions": ["wgt"]
  },
  "application/winhlp": {
    "source": "apache",
    "extensions": ["hlp"]
  },
  "application/wita": {
    "source": "iana"
  },
  "application/wordperfect5.1": {
    "source": "iana"
  },
  "application/wsdl+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wsdl"]
  },
  "application/wspolicy+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["wspolicy"]
  },
  "application/x-7z-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["7z"]
  },
  "application/x-abiword": {
    "source": "apache",
    "extensions": ["abw"]
  },
  "application/x-ace-compressed": {
    "source": "apache",
    "extensions": ["ace"]
  },
  "application/x-amf": {
    "source": "apache"
  },
  "application/x-apple-diskimage": {
    "source": "apache",
    "extensions": ["dmg"]
  },
  "application/x-arj": {
    "compressible": false,
    "extensions": ["arj"]
  },
  "application/x-authorware-bin": {
    "source": "apache",
    "extensions": ["aab","x32","u32","vox"]
  },
  "application/x-authorware-map": {
    "source": "apache",
    "extensions": ["aam"]
  },
  "application/x-authorware-seg": {
    "source": "apache",
    "extensions": ["aas"]
  },
  "application/x-bcpio": {
    "source": "apache",
    "extensions": ["bcpio"]
  },
  "application/x-bdoc": {
    "compressible": false,
    "extensions": ["bdoc"]
  },
  "application/x-bittorrent": {
    "source": "apache",
    "extensions": ["torrent"]
  },
  "application/x-blorb": {
    "source": "apache",
    "extensions": ["blb","blorb"]
  },
  "application/x-bzip": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz"]
  },
  "application/x-bzip2": {
    "source": "apache",
    "compressible": false,
    "extensions": ["bz2","boz"]
  },
  "application/x-cbr": {
    "source": "apache",
    "extensions": ["cbr","cba","cbt","cbz","cb7"]
  },
  "application/x-cdlink": {
    "source": "apache",
    "extensions": ["vcd"]
  },
  "application/x-cfs-compressed": {
    "source": "apache",
    "extensions": ["cfs"]
  },
  "application/x-chat": {
    "source": "apache",
    "extensions": ["chat"]
  },
  "application/x-chess-pgn": {
    "source": "apache",
    "extensions": ["pgn"]
  },
  "application/x-chrome-extension": {
    "extensions": ["crx"]
  },
  "application/x-cocoa": {
    "source": "nginx",
    "extensions": ["cco"]
  },
  "application/x-compress": {
    "source": "apache"
  },
  "application/x-conference": {
    "source": "apache",
    "extensions": ["nsc"]
  },
  "application/x-cpio": {
    "source": "apache",
    "extensions": ["cpio"]
  },
  "application/x-csh": {
    "source": "apache",
    "extensions": ["csh"]
  },
  "application/x-deb": {
    "compressible": false
  },
  "application/x-debian-package": {
    "source": "apache",
    "extensions": ["deb","udeb"]
  },
  "application/x-dgc-compressed": {
    "source": "apache",
    "extensions": ["dgc"]
  },
  "application/x-director": {
    "source": "apache",
    "extensions": ["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]
  },
  "application/x-doom": {
    "source": "apache",
    "extensions": ["wad"]
  },
  "application/x-dtbncx+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ncx"]
  },
  "application/x-dtbook+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["dtb"]
  },
  "application/x-dtbresource+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["res"]
  },
  "application/x-dvi": {
    "source": "apache",
    "compressible": false,
    "extensions": ["dvi"]
  },
  "application/x-envoy": {
    "source": "apache",
    "extensions": ["evy"]
  },
  "application/x-eva": {
    "source": "apache",
    "extensions": ["eva"]
  },
  "application/x-font-bdf": {
    "source": "apache",
    "extensions": ["bdf"]
  },
  "application/x-font-dos": {
    "source": "apache"
  },
  "application/x-font-framemaker": {
    "source": "apache"
  },
  "application/x-font-ghostscript": {
    "source": "apache",
    "extensions": ["gsf"]
  },
  "application/x-font-libgrx": {
    "source": "apache"
  },
  "application/x-font-linux-psf": {
    "source": "apache",
    "extensions": ["psf"]
  },
  "application/x-font-pcf": {
    "source": "apache",
    "extensions": ["pcf"]
  },
  "application/x-font-snf": {
    "source": "apache",
    "extensions": ["snf"]
  },
  "application/x-font-speedo": {
    "source": "apache"
  },
  "application/x-font-sunos-news": {
    "source": "apache"
  },
  "application/x-font-type1": {
    "source": "apache",
    "extensions": ["pfa","pfb","pfm","afm"]
  },
  "application/x-font-vfont": {
    "source": "apache"
  },
  "application/x-freearc": {
    "source": "apache",
    "extensions": ["arc"]
  },
  "application/x-futuresplash": {
    "source": "apache",
    "extensions": ["spl"]
  },
  "application/x-gca-compressed": {
    "source": "apache",
    "extensions": ["gca"]
  },
  "application/x-glulx": {
    "source": "apache",
    "extensions": ["ulx"]
  },
  "application/x-gnumeric": {
    "source": "apache",
    "extensions": ["gnumeric"]
  },
  "application/x-gramps-xml": {
    "source": "apache",
    "extensions": ["gramps"]
  },
  "application/x-gtar": {
    "source": "apache",
    "extensions": ["gtar"]
  },
  "application/x-gzip": {
    "source": "apache"
  },
  "application/x-hdf": {
    "source": "apache",
    "extensions": ["hdf"]
  },
  "application/x-httpd-php": {
    "compressible": true,
    "extensions": ["php"]
  },
  "application/x-install-instructions": {
    "source": "apache",
    "extensions": ["install"]
  },
  "application/x-iso9660-image": {
    "source": "apache",
    "extensions": ["iso"]
  },
  "application/x-java-archive-diff": {
    "source": "nginx",
    "extensions": ["jardiff"]
  },
  "application/x-java-jnlp-file": {
    "source": "apache",
    "compressible": false,
    "extensions": ["jnlp"]
  },
  "application/x-javascript": {
    "compressible": true
  },
  "application/x-keepass2": {
    "extensions": ["kdbx"]
  },
  "application/x-latex": {
    "source": "apache",
    "compressible": false,
    "extensions": ["latex"]
  },
  "application/x-lua-bytecode": {
    "extensions": ["luac"]
  },
  "application/x-lzh-compressed": {
    "source": "apache",
    "extensions": ["lzh","lha"]
  },
  "application/x-makeself": {
    "source": "nginx",
    "extensions": ["run"]
  },
  "application/x-mie": {
    "source": "apache",
    "extensions": ["mie"]
  },
  "application/x-mobipocket-ebook": {
    "source": "apache",
    "extensions": ["prc","mobi"]
  },
  "application/x-mpegurl": {
    "compressible": false
  },
  "application/x-ms-application": {
    "source": "apache",
    "extensions": ["application"]
  },
  "application/x-ms-shortcut": {
    "source": "apache",
    "extensions": ["lnk"]
  },
  "application/x-ms-wmd": {
    "source": "apache",
    "extensions": ["wmd"]
  },
  "application/x-ms-wmz": {
    "source": "apache",
    "extensions": ["wmz"]
  },
  "application/x-ms-xbap": {
    "source": "apache",
    "extensions": ["xbap"]
  },
  "application/x-msaccess": {
    "source": "apache",
    "extensions": ["mdb"]
  },
  "application/x-msbinder": {
    "source": "apache",
    "extensions": ["obd"]
  },
  "application/x-mscardfile": {
    "source": "apache",
    "extensions": ["crd"]
  },
  "application/x-msclip": {
    "source": "apache",
    "extensions": ["clp"]
  },
  "application/x-msdos-program": {
    "extensions": ["exe"]
  },
  "application/x-msdownload": {
    "source": "apache",
    "extensions": ["exe","dll","com","bat","msi"]
  },
  "application/x-msmediaview": {
    "source": "apache",
    "extensions": ["mvb","m13","m14"]
  },
  "application/x-msmetafile": {
    "source": "apache",
    "extensions": ["wmf","wmz","emf","emz"]
  },
  "application/x-msmoney": {
    "source": "apache",
    "extensions": ["mny"]
  },
  "application/x-mspublisher": {
    "source": "apache",
    "extensions": ["pub"]
  },
  "application/x-msschedule": {
    "source": "apache",
    "extensions": ["scd"]
  },
  "application/x-msterminal": {
    "source": "apache",
    "extensions": ["trm"]
  },
  "application/x-mswrite": {
    "source": "apache",
    "extensions": ["wri"]
  },
  "application/x-netcdf": {
    "source": "apache",
    "extensions": ["nc","cdf"]
  },
  "application/x-ns-proxy-autoconfig": {
    "compressible": true,
    "extensions": ["pac"]
  },
  "application/x-nzb": {
    "source": "apache",
    "extensions": ["nzb"]
  },
  "application/x-perl": {
    "source": "nginx",
    "extensions": ["pl","pm"]
  },
  "application/x-pilot": {
    "source": "nginx",
    "extensions": ["prc","pdb"]
  },
  "application/x-pkcs12": {
    "source": "apache",
    "compressible": false,
    "extensions": ["p12","pfx"]
  },
  "application/x-pkcs7-certificates": {
    "source": "apache",
    "extensions": ["p7b","spc"]
  },
  "application/x-pkcs7-certreqresp": {
    "source": "apache",
    "extensions": ["p7r"]
  },
  "application/x-pki-message": {
    "source": "iana"
  },
  "application/x-rar-compressed": {
    "source": "apache",
    "compressible": false,
    "extensions": ["rar"]
  },
  "application/x-redhat-package-manager": {
    "source": "nginx",
    "extensions": ["rpm"]
  },
  "application/x-research-info-systems": {
    "source": "apache",
    "extensions": ["ris"]
  },
  "application/x-sea": {
    "source": "nginx",
    "extensions": ["sea"]
  },
  "application/x-sh": {
    "source": "apache",
    "compressible": true,
    "extensions": ["sh"]
  },
  "application/x-shar": {
    "source": "apache",
    "extensions": ["shar"]
  },
  "application/x-shockwave-flash": {
    "source": "apache",
    "compressible": false,
    "extensions": ["swf"]
  },
  "application/x-silverlight-app": {
    "source": "apache",
    "extensions": ["xap"]
  },
  "application/x-sql": {
    "source": "apache",
    "extensions": ["sql"]
  },
  "application/x-stuffit": {
    "source": "apache",
    "compressible": false,
    "extensions": ["sit"]
  },
  "application/x-stuffitx": {
    "source": "apache",
    "extensions": ["sitx"]
  },
  "application/x-subrip": {
    "source": "apache",
    "extensions": ["srt"]
  },
  "application/x-sv4cpio": {
    "source": "apache",
    "extensions": ["sv4cpio"]
  },
  "application/x-sv4crc": {
    "source": "apache",
    "extensions": ["sv4crc"]
  },
  "application/x-t3vm-image": {
    "source": "apache",
    "extensions": ["t3"]
  },
  "application/x-tads": {
    "source": "apache",
    "extensions": ["gam"]
  },
  "application/x-tar": {
    "source": "apache",
    "compressible": true,
    "extensions": ["tar"]
  },
  "application/x-tcl": {
    "source": "apache",
    "extensions": ["tcl","tk"]
  },
  "application/x-tex": {
    "source": "apache",
    "extensions": ["tex"]
  },
  "application/x-tex-tfm": {
    "source": "apache",
    "extensions": ["tfm"]
  },
  "application/x-texinfo": {
    "source": "apache",
    "extensions": ["texinfo","texi"]
  },
  "application/x-tgif": {
    "source": "apache",
    "extensions": ["obj"]
  },
  "application/x-ustar": {
    "source": "apache",
    "extensions": ["ustar"]
  },
  "application/x-virtualbox-hdd": {
    "compressible": true,
    "extensions": ["hdd"]
  },
  "application/x-virtualbox-ova": {
    "compressible": true,
    "extensions": ["ova"]
  },
  "application/x-virtualbox-ovf": {
    "compressible": true,
    "extensions": ["ovf"]
  },
  "application/x-virtualbox-vbox": {
    "compressible": true,
    "extensions": ["vbox"]
  },
  "application/x-virtualbox-vbox-extpack": {
    "compressible": false,
    "extensions": ["vbox-extpack"]
  },
  "application/x-virtualbox-vdi": {
    "compressible": true,
    "extensions": ["vdi"]
  },
  "application/x-virtualbox-vhd": {
    "compressible": true,
    "extensions": ["vhd"]
  },
  "application/x-virtualbox-vmdk": {
    "compressible": true,
    "extensions": ["vmdk"]
  },
  "application/x-wais-source": {
    "source": "apache",
    "extensions": ["src"]
  },
  "application/x-web-app-manifest+json": {
    "compressible": true,
    "extensions": ["webapp"]
  },
  "application/x-www-form-urlencoded": {
    "source": "iana",
    "compressible": true
  },
  "application/x-x509-ca-cert": {
    "source": "iana",
    "extensions": ["der","crt","pem"]
  },
  "application/x-x509-ca-ra-cert": {
    "source": "iana"
  },
  "application/x-x509-next-ca-cert": {
    "source": "iana"
  },
  "application/x-xfig": {
    "source": "apache",
    "extensions": ["fig"]
  },
  "application/x-xliff+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/x-xpinstall": {
    "source": "apache",
    "compressible": false,
    "extensions": ["xpi"]
  },
  "application/x-xz": {
    "source": "apache",
    "extensions": ["xz"]
  },
  "application/x-zmachine": {
    "source": "apache",
    "extensions": ["z1","z2","z3","z4","z5","z6","z7","z8"]
  },
  "application/x400-bp": {
    "source": "iana"
  },
  "application/xacml+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xaml+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xaml"]
  },
  "application/xcap-att+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xav"]
  },
  "application/xcap-caps+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xca"]
  },
  "application/xcap-diff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xdf"]
  },
  "application/xcap-el+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xel"]
  },
  "application/xcap-error+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xer"]
  },
  "application/xcap-ns+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xns"]
  },
  "application/xcon-conference-info+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xcon-conference-info-diff+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xenc+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xenc"]
  },
  "application/xhtml+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xhtml","xht"]
  },
  "application/xhtml-voice+xml": {
    "source": "apache",
    "compressible": true
  },
  "application/xliff+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xlf"]
  },
  "application/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml","xsl","xsd","rng"]
  },
  "application/xml-dtd": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dtd"]
  },
  "application/xml-external-parsed-entity": {
    "source": "iana"
  },
  "application/xml-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xmpp+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/xop+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xop"]
  },
  "application/xproc+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xpl"]
  },
  "application/xslt+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xsl","xslt"]
  },
  "application/xspf+xml": {
    "source": "apache",
    "compressible": true,
    "extensions": ["xspf"]
  },
  "application/xv+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["mxml","xhvml","xvml","xvm"]
  },
  "application/yang": {
    "source": "iana",
    "extensions": ["yang"]
  },
  "application/yang-data+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-data+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+json": {
    "source": "iana",
    "compressible": true
  },
  "application/yang-patch+xml": {
    "source": "iana",
    "compressible": true
  },
  "application/yin+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["yin"]
  },
  "application/zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["zip"]
  },
  "application/zlib": {
    "source": "iana"
  },
  "application/zstd": {
    "source": "iana"
  },
  "audio/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "audio/32kadpcm": {
    "source": "iana"
  },
  "audio/3gpp": {
    "source": "iana",
    "compressible": false,
    "extensions": ["3gpp"]
  },
  "audio/3gpp2": {
    "source": "iana"
  },
  "audio/aac": {
    "source": "iana"
  },
  "audio/ac3": {
    "source": "iana"
  },
  "audio/adpcm": {
    "source": "apache",
    "extensions": ["adp"]
  },
  "audio/amr": {
    "source": "iana"
  },
  "audio/amr-wb": {
    "source": "iana"
  },
  "audio/amr-wb+": {
    "source": "iana"
  },
  "audio/aptx": {
    "source": "iana"
  },
  "audio/asc": {
    "source": "iana"
  },
  "audio/atrac-advanced-lossless": {
    "source": "iana"
  },
  "audio/atrac-x": {
    "source": "iana"
  },
  "audio/atrac3": {
    "source": "iana"
  },
  "audio/basic": {
    "source": "iana",
    "compressible": false,
    "extensions": ["au","snd"]
  },
  "audio/bv16": {
    "source": "iana"
  },
  "audio/bv32": {
    "source": "iana"
  },
  "audio/clearmode": {
    "source": "iana"
  },
  "audio/cn": {
    "source": "iana"
  },
  "audio/dat12": {
    "source": "iana"
  },
  "audio/dls": {
    "source": "iana"
  },
  "audio/dsr-es201108": {
    "source": "iana"
  },
  "audio/dsr-es202050": {
    "source": "iana"
  },
  "audio/dsr-es202211": {
    "source": "iana"
  },
  "audio/dsr-es202212": {
    "source": "iana"
  },
  "audio/dv": {
    "source": "iana"
  },
  "audio/dvi4": {
    "source": "iana"
  },
  "audio/eac3": {
    "source": "iana"
  },
  "audio/encaprtp": {
    "source": "iana"
  },
  "audio/evrc": {
    "source": "iana"
  },
  "audio/evrc-qcp": {
    "source": "iana"
  },
  "audio/evrc0": {
    "source": "iana"
  },
  "audio/evrc1": {
    "source": "iana"
  },
  "audio/evrcb": {
    "source": "iana"
  },
  "audio/evrcb0": {
    "source": "iana"
  },
  "audio/evrcb1": {
    "source": "iana"
  },
  "audio/evrcnw": {
    "source": "iana"
  },
  "audio/evrcnw0": {
    "source": "iana"
  },
  "audio/evrcnw1": {
    "source": "iana"
  },
  "audio/evrcwb": {
    "source": "iana"
  },
  "audio/evrcwb0": {
    "source": "iana"
  },
  "audio/evrcwb1": {
    "source": "iana"
  },
  "audio/evs": {
    "source": "iana"
  },
  "audio/flexfec": {
    "source": "iana"
  },
  "audio/fwdred": {
    "source": "iana"
  },
  "audio/g711-0": {
    "source": "iana"
  },
  "audio/g719": {
    "source": "iana"
  },
  "audio/g722": {
    "source": "iana"
  },
  "audio/g7221": {
    "source": "iana"
  },
  "audio/g723": {
    "source": "iana"
  },
  "audio/g726-16": {
    "source": "iana"
  },
  "audio/g726-24": {
    "source": "iana"
  },
  "audio/g726-32": {
    "source": "iana"
  },
  "audio/g726-40": {
    "source": "iana"
  },
  "audio/g728": {
    "source": "iana"
  },
  "audio/g729": {
    "source": "iana"
  },
  "audio/g7291": {
    "source": "iana"
  },
  "audio/g729d": {
    "source": "iana"
  },
  "audio/g729e": {
    "source": "iana"
  },
  "audio/gsm": {
    "source": "iana"
  },
  "audio/gsm-efr": {
    "source": "iana"
  },
  "audio/gsm-hr-08": {
    "source": "iana"
  },
  "audio/ilbc": {
    "source": "iana"
  },
  "audio/ip-mr_v2.5": {
    "source": "iana"
  },
  "audio/isac": {
    "source": "apache"
  },
  "audio/l16": {
    "source": "iana"
  },
  "audio/l20": {
    "source": "iana"
  },
  "audio/l24": {
    "source": "iana",
    "compressible": false
  },
  "audio/l8": {
    "source": "iana"
  },
  "audio/lpc": {
    "source": "iana"
  },
  "audio/melp": {
    "source": "iana"
  },
  "audio/melp1200": {
    "source": "iana"
  },
  "audio/melp2400": {
    "source": "iana"
  },
  "audio/melp600": {
    "source": "iana"
  },
  "audio/mhas": {
    "source": "iana"
  },
  "audio/midi": {
    "source": "apache",
    "extensions": ["mid","midi","kar","rmi"]
  },
  "audio/mobile-xmf": {
    "source": "iana",
    "extensions": ["mxmf"]
  },
  "audio/mp3": {
    "compressible": false,
    "extensions": ["mp3"]
  },
  "audio/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["m4a","mp4a"]
  },
  "audio/mp4a-latm": {
    "source": "iana"
  },
  "audio/mpa": {
    "source": "iana"
  },
  "audio/mpa-robust": {
    "source": "iana"
  },
  "audio/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpga","mp2","mp2a","mp3","m2a","m3a"]
  },
  "audio/mpeg4-generic": {
    "source": "iana"
  },
  "audio/musepack": {
    "source": "apache"
  },
  "audio/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["oga","ogg","spx"]
  },
  "audio/opus": {
    "source": "iana"
  },
  "audio/parityfec": {
    "source": "iana"
  },
  "audio/pcma": {
    "source": "iana"
  },
  "audio/pcma-wb": {
    "source": "iana"
  },
  "audio/pcmu": {
    "source": "iana"
  },
  "audio/pcmu-wb": {
    "source": "iana"
  },
  "audio/prs.sid": {
    "source": "iana"
  },
  "audio/qcelp": {
    "source": "iana"
  },
  "audio/raptorfec": {
    "source": "iana"
  },
  "audio/red": {
    "source": "iana"
  },
  "audio/rtp-enc-aescm128": {
    "source": "iana"
  },
  "audio/rtp-midi": {
    "source": "iana"
  },
  "audio/rtploopback": {
    "source": "iana"
  },
  "audio/rtx": {
    "source": "iana"
  },
  "audio/s3m": {
    "source": "apache",
    "extensions": ["s3m"]
  },
  "audio/silk": {
    "source": "apache",
    "extensions": ["sil"]
  },
  "audio/smv": {
    "source": "iana"
  },
  "audio/smv-qcp": {
    "source": "iana"
  },
  "audio/smv0": {
    "source": "iana"
  },
  "audio/sofa": {
    "source": "iana"
  },
  "audio/sp-midi": {
    "source": "iana"
  },
  "audio/speex": {
    "source": "iana"
  },
  "audio/t140c": {
    "source": "iana"
  },
  "audio/t38": {
    "source": "iana"
  },
  "audio/telephone-event": {
    "source": "iana"
  },
  "audio/tetra_acelp": {
    "source": "iana"
  },
  "audio/tetra_acelp_bb": {
    "source": "iana"
  },
  "audio/tone": {
    "source": "iana"
  },
  "audio/tsvcis": {
    "source": "iana"
  },
  "audio/uemclip": {
    "source": "iana"
  },
  "audio/ulpfec": {
    "source": "iana"
  },
  "audio/usac": {
    "source": "iana"
  },
  "audio/vdvi": {
    "source": "iana"
  },
  "audio/vmr-wb": {
    "source": "iana"
  },
  "audio/vnd.3gpp.iufp": {
    "source": "iana"
  },
  "audio/vnd.4sb": {
    "source": "iana"
  },
  "audio/vnd.audiokoz": {
    "source": "iana"
  },
  "audio/vnd.celp": {
    "source": "iana"
  },
  "audio/vnd.cisco.nse": {
    "source": "iana"
  },
  "audio/vnd.cmles.radio-events": {
    "source": "iana"
  },
  "audio/vnd.cns.anp1": {
    "source": "iana"
  },
  "audio/vnd.cns.inf1": {
    "source": "iana"
  },
  "audio/vnd.dece.audio": {
    "source": "iana",
    "extensions": ["uva","uvva"]
  },
  "audio/vnd.digital-winds": {
    "source": "iana",
    "extensions": ["eol"]
  },
  "audio/vnd.dlna.adts": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    "source": "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    "source": "iana"
  },
  "audio/vnd.dolby.mlp": {
    "source": "iana"
  },
  "audio/vnd.dolby.mps": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2x": {
    "source": "iana"
  },
  "audio/vnd.dolby.pl2z": {
    "source": "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    "source": "iana"
  },
  "audio/vnd.dra": {
    "source": "iana",
    "extensions": ["dra"]
  },
  "audio/vnd.dts": {
    "source": "iana",
    "extensions": ["dts"]
  },
  "audio/vnd.dts.hd": {
    "source": "iana",
    "extensions": ["dtshd"]
  },
  "audio/vnd.dts.uhd": {
    "source": "iana"
  },
  "audio/vnd.dvb.file": {
    "source": "iana"
  },
  "audio/vnd.everad.plj": {
    "source": "iana"
  },
  "audio/vnd.hns.audio": {
    "source": "iana"
  },
  "audio/vnd.lucent.voice": {
    "source": "iana",
    "extensions": ["lvp"]
  },
  "audio/vnd.ms-playready.media.pya": {
    "source": "iana",
    "extensions": ["pya"]
  },
  "audio/vnd.nokia.mobile-xmf": {
    "source": "iana"
  },
  "audio/vnd.nortel.vbk": {
    "source": "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    "source": "iana",
    "extensions": ["ecelp4800"]
  },
  "audio/vnd.nuera.ecelp7470": {
    "source": "iana",
    "extensions": ["ecelp7470"]
  },
  "audio/vnd.nuera.ecelp9600": {
    "source": "iana",
    "extensions": ["ecelp9600"]
  },
  "audio/vnd.octel.sbc": {
    "source": "iana"
  },
  "audio/vnd.presonus.multitrack": {
    "source": "iana"
  },
  "audio/vnd.qcelp": {
    "source": "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    "source": "iana"
  },
  "audio/vnd.rip": {
    "source": "iana",
    "extensions": ["rip"]
  },
  "audio/vnd.rn-realaudio": {
    "compressible": false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    "source": "iana"
  },
  "audio/vnd.vmx.cvsd": {
    "source": "iana"
  },
  "audio/vnd.wave": {
    "compressible": false
  },
  "audio/vorbis": {
    "source": "iana",
    "compressible": false
  },
  "audio/vorbis-config": {
    "source": "iana"
  },
  "audio/wav": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/wave": {
    "compressible": false,
    "extensions": ["wav"]
  },
  "audio/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["weba"]
  },
  "audio/x-aac": {
    "source": "apache",
    "compressible": false,
    "extensions": ["aac"]
  },
  "audio/x-aiff": {
    "source": "apache",
    "extensions": ["aif","aiff","aifc"]
  },
  "audio/x-caf": {
    "source": "apache",
    "compressible": false,
    "extensions": ["caf"]
  },
  "audio/x-flac": {
    "source": "apache",
    "extensions": ["flac"]
  },
  "audio/x-m4a": {
    "source": "nginx",
    "extensions": ["m4a"]
  },
  "audio/x-matroska": {
    "source": "apache",
    "extensions": ["mka"]
  },
  "audio/x-mpegurl": {
    "source": "apache",
    "extensions": ["m3u"]
  },
  "audio/x-ms-wax": {
    "source": "apache",
    "extensions": ["wax"]
  },
  "audio/x-ms-wma": {
    "source": "apache",
    "extensions": ["wma"]
  },
  "audio/x-pn-realaudio": {
    "source": "apache",
    "extensions": ["ram","ra"]
  },
  "audio/x-pn-realaudio-plugin": {
    "source": "apache",
    "extensions": ["rmp"]
  },
  "audio/x-realaudio": {
    "source": "nginx",
    "extensions": ["ra"]
  },
  "audio/x-tta": {
    "source": "apache"
  },
  "audio/x-wav": {
    "source": "apache",
    "extensions": ["wav"]
  },
  "audio/xm": {
    "source": "apache",
    "extensions": ["xm"]
  },
  "chemical/x-cdx": {
    "source": "apache",
    "extensions": ["cdx"]
  },
  "chemical/x-cif": {
    "source": "apache",
    "extensions": ["cif"]
  },
  "chemical/x-cmdf": {
    "source": "apache",
    "extensions": ["cmdf"]
  },
  "chemical/x-cml": {
    "source": "apache",
    "extensions": ["cml"]
  },
  "chemical/x-csml": {
    "source": "apache",
    "extensions": ["csml"]
  },
  "chemical/x-pdb": {
    "source": "apache"
  },
  "chemical/x-xyz": {
    "source": "apache",
    "extensions": ["xyz"]
  },
  "font/collection": {
    "source": "iana",
    "extensions": ["ttc"]
  },
  "font/otf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["otf"]
  },
  "font/sfnt": {
    "source": "iana"
  },
  "font/ttf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["ttf"]
  },
  "font/woff": {
    "source": "iana",
    "extensions": ["woff"]
  },
  "font/woff2": {
    "source": "iana",
    "extensions": ["woff2"]
  },
  "image/aces": {
    "source": "iana",
    "extensions": ["exr"]
  },
  "image/apng": {
    "compressible": false,
    "extensions": ["apng"]
  },
  "image/avci": {
    "source": "iana"
  },
  "image/avcs": {
    "source": "iana"
  },
  "image/avif": {
    "compressible": false,
    "extensions": ["avif"]
  },
  "image/bmp": {
    "source": "iana",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/cgm": {
    "source": "iana",
    "extensions": ["cgm"]
  },
  "image/dicom-rle": {
    "source": "iana",
    "extensions": ["drle"]
  },
  "image/emf": {
    "source": "iana",
    "extensions": ["emf"]
  },
  "image/fits": {
    "source": "iana",
    "extensions": ["fits"]
  },
  "image/g3fax": {
    "source": "iana",
    "extensions": ["g3"]
  },
  "image/gif": {
    "source": "iana",
    "compressible": false,
    "extensions": ["gif"]
  },
  "image/heic": {
    "source": "iana",
    "extensions": ["heic"]
  },
  "image/heic-sequence": {
    "source": "iana",
    "extensions": ["heics"]
  },
  "image/heif": {
    "source": "iana",
    "extensions": ["heif"]
  },
  "image/heif-sequence": {
    "source": "iana",
    "extensions": ["heifs"]
  },
  "image/hej2k": {
    "source": "iana",
    "extensions": ["hej2"]
  },
  "image/hsj2": {
    "source": "iana",
    "extensions": ["hsj2"]
  },
  "image/ief": {
    "source": "iana",
    "extensions": ["ief"]
  },
  "image/jls": {
    "source": "iana",
    "extensions": ["jls"]
  },
  "image/jp2": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jp2","jpg2"]
  },
  "image/jpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpeg","jpg","jpe"]
  },
  "image/jph": {
    "source": "iana",
    "extensions": ["jph"]
  },
  "image/jphc": {
    "source": "iana",
    "extensions": ["jhc"]
  },
  "image/jpm": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpm"]
  },
  "image/jpx": {
    "source": "iana",
    "compressible": false,
    "extensions": ["jpx","jpf"]
  },
  "image/jxr": {
    "source": "iana",
    "extensions": ["jxr"]
  },
  "image/jxra": {
    "source": "iana",
    "extensions": ["jxra"]
  },
  "image/jxrs": {
    "source": "iana",
    "extensions": ["jxrs"]
  },
  "image/jxs": {
    "source": "iana",
    "extensions": ["jxs"]
  },
  "image/jxsc": {
    "source": "iana",
    "extensions": ["jxsc"]
  },
  "image/jxsi": {
    "source": "iana",
    "extensions": ["jxsi"]
  },
  "image/jxss": {
    "source": "iana",
    "extensions": ["jxss"]
  },
  "image/ktx": {
    "source": "iana",
    "extensions": ["ktx"]
  },
  "image/ktx2": {
    "source": "iana",
    "extensions": ["ktx2"]
  },
  "image/naplps": {
    "source": "iana"
  },
  "image/pjpeg": {
    "compressible": false
  },
  "image/png": {
    "source": "iana",
    "compressible": false,
    "extensions": ["png"]
  },
  "image/prs.btif": {
    "source": "iana",
    "extensions": ["btif"]
  },
  "image/prs.pti": {
    "source": "iana",
    "extensions": ["pti"]
  },
  "image/pwg-raster": {
    "source": "iana"
  },
  "image/sgi": {
    "source": "apache",
    "extensions": ["sgi"]
  },
  "image/svg+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["svg","svgz"]
  },
  "image/t38": {
    "source": "iana",
    "extensions": ["t38"]
  },
  "image/tiff": {
    "source": "iana",
    "compressible": false,
    "extensions": ["tif","tiff"]
  },
  "image/tiff-fx": {
    "source": "iana",
    "extensions": ["tfx"]
  },
  "image/vnd.adobe.photoshop": {
    "source": "iana",
    "compressible": true,
    "extensions": ["psd"]
  },
  "image/vnd.airzip.accelerator.azv": {
    "source": "iana",
    "extensions": ["azv"]
  },
  "image/vnd.cns.inf2": {
    "source": "iana"
  },
  "image/vnd.dece.graphic": {
    "source": "iana",
    "extensions": ["uvi","uvvi","uvg","uvvg"]
  },
  "image/vnd.djvu": {
    "source": "iana",
    "extensions": ["djvu","djv"]
  },
  "image/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "image/vnd.dwg": {
    "source": "iana",
    "extensions": ["dwg"]
  },
  "image/vnd.dxf": {
    "source": "iana",
    "extensions": ["dxf"]
  },
  "image/vnd.fastbidsheet": {
    "source": "iana",
    "extensions": ["fbs"]
  },
  "image/vnd.fpx": {
    "source": "iana",
    "extensions": ["fpx"]
  },
  "image/vnd.fst": {
    "source": "iana",
    "extensions": ["fst"]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    "source": "iana",
    "extensions": ["mmr"]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    "source": "iana",
    "extensions": ["rlc"]
  },
  "image/vnd.globalgraphics.pgb": {
    "source": "iana"
  },
  "image/vnd.microsoft.icon": {
    "source": "iana",
    "extensions": ["ico"]
  },
  "image/vnd.mix": {
    "source": "iana"
  },
  "image/vnd.mozilla.apng": {
    "source": "iana"
  },
  "image/vnd.ms-dds": {
    "extensions": ["dds"]
  },
  "image/vnd.ms-modi": {
    "source": "iana",
    "extensions": ["mdi"]
  },
  "image/vnd.ms-photo": {
    "source": "apache",
    "extensions": ["wdp"]
  },
  "image/vnd.net-fpx": {
    "source": "iana",
    "extensions": ["npx"]
  },
  "image/vnd.pco.b16": {
    "source": "iana",
    "extensions": ["b16"]
  },
  "image/vnd.radiance": {
    "source": "iana"
  },
  "image/vnd.sealed.png": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    "source": "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    "source": "iana"
  },
  "image/vnd.svf": {
    "source": "iana"
  },
  "image/vnd.tencent.tap": {
    "source": "iana",
    "extensions": ["tap"]
  },
  "image/vnd.valve.source.texture": {
    "source": "iana",
    "extensions": ["vtf"]
  },
  "image/vnd.wap.wbmp": {
    "source": "iana",
    "extensions": ["wbmp"]
  },
  "image/vnd.xiff": {
    "source": "iana",
    "extensions": ["xif"]
  },
  "image/vnd.zbrush.pcx": {
    "source": "iana",
    "extensions": ["pcx"]
  },
  "image/webp": {
    "source": "apache",
    "extensions": ["webp"]
  },
  "image/wmf": {
    "source": "iana",
    "extensions": ["wmf"]
  },
  "image/x-3ds": {
    "source": "apache",
    "extensions": ["3ds"]
  },
  "image/x-cmu-raster": {
    "source": "apache",
    "extensions": ["ras"]
  },
  "image/x-cmx": {
    "source": "apache",
    "extensions": ["cmx"]
  },
  "image/x-freehand": {
    "source": "apache",
    "extensions": ["fh","fhc","fh4","fh5","fh7"]
  },
  "image/x-icon": {
    "source": "apache",
    "compressible": true,
    "extensions": ["ico"]
  },
  "image/x-jng": {
    "source": "nginx",
    "extensions": ["jng"]
  },
  "image/x-mrsid-image": {
    "source": "apache",
    "extensions": ["sid"]
  },
  "image/x-ms-bmp": {
    "source": "nginx",
    "compressible": true,
    "extensions": ["bmp"]
  },
  "image/x-pcx": {
    "source": "apache",
    "extensions": ["pcx"]
  },
  "image/x-pict": {
    "source": "apache",
    "extensions": ["pic","pct"]
  },
  "image/x-portable-anymap": {
    "source": "apache",
    "extensions": ["pnm"]
  },
  "image/x-portable-bitmap": {
    "source": "apache",
    "extensions": ["pbm"]
  },
  "image/x-portable-graymap": {
    "source": "apache",
    "extensions": ["pgm"]
  },
  "image/x-portable-pixmap": {
    "source": "apache",
    "extensions": ["ppm"]
  },
  "image/x-rgb": {
    "source": "apache",
    "extensions": ["rgb"]
  },
  "image/x-tga": {
    "source": "apache",
    "extensions": ["tga"]
  },
  "image/x-xbitmap": {
    "source": "apache",
    "extensions": ["xbm"]
  },
  "image/x-xcf": {
    "compressible": false
  },
  "image/x-xpixmap": {
    "source": "apache",
    "extensions": ["xpm"]
  },
  "image/x-xwindowdump": {
    "source": "apache",
    "extensions": ["xwd"]
  },
  "message/cpim": {
    "source": "iana"
  },
  "message/delivery-status": {
    "source": "iana"
  },
  "message/disposition-notification": {
    "source": "iana",
    "extensions": [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    "source": "iana"
  },
  "message/feedback-report": {
    "source": "iana"
  },
  "message/global": {
    "source": "iana",
    "extensions": ["u8msg"]
  },
  "message/global-delivery-status": {
    "source": "iana",
    "extensions": ["u8dsn"]
  },
  "message/global-disposition-notification": {
    "source": "iana",
    "extensions": ["u8mdn"]
  },
  "message/global-headers": {
    "source": "iana",
    "extensions": ["u8hdr"]
  },
  "message/http": {
    "source": "iana",
    "compressible": false
  },
  "message/imdn+xml": {
    "source": "iana",
    "compressible": true
  },
  "message/news": {
    "source": "iana"
  },
  "message/partial": {
    "source": "iana",
    "compressible": false
  },
  "message/rfc822": {
    "source": "iana",
    "compressible": true,
    "extensions": ["eml","mime"]
  },
  "message/s-http": {
    "source": "iana"
  },
  "message/sip": {
    "source": "iana"
  },
  "message/sipfrag": {
    "source": "iana"
  },
  "message/tracking-status": {
    "source": "iana"
  },
  "message/vnd.si.simp": {
    "source": "iana"
  },
  "message/vnd.wfa.wsc": {
    "source": "iana",
    "extensions": ["wsc"]
  },
  "model/3mf": {
    "source": "iana",
    "extensions": ["3mf"]
  },
  "model/e57": {
    "source": "iana"
  },
  "model/gltf+json": {
    "source": "iana",
    "compressible": true,
    "extensions": ["gltf"]
  },
  "model/gltf-binary": {
    "source": "iana",
    "compressible": true,
    "extensions": ["glb"]
  },
  "model/iges": {
    "source": "iana",
    "compressible": false,
    "extensions": ["igs","iges"]
  },
  "model/mesh": {
    "source": "iana",
    "compressible": false,
    "extensions": ["msh","mesh","silo"]
  },
  "model/mtl": {
    "source": "iana",
    "extensions": ["mtl"]
  },
  "model/obj": {
    "source": "iana",
    "extensions": ["obj"]
  },
  "model/stl": {
    "source": "iana",
    "extensions": ["stl"]
  },
  "model/vnd.collada+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["dae"]
  },
  "model/vnd.dwf": {
    "source": "iana",
    "extensions": ["dwf"]
  },
  "model/vnd.flatland.3dml": {
    "source": "iana"
  },
  "model/vnd.gdl": {
    "source": "iana",
    "extensions": ["gdl"]
  },
  "model/vnd.gs-gdl": {
    "source": "apache"
  },
  "model/vnd.gs.gdl": {
    "source": "iana"
  },
  "model/vnd.gtw": {
    "source": "iana",
    "extensions": ["gtw"]
  },
  "model/vnd.moml+xml": {
    "source": "iana",
    "compressible": true
  },
  "model/vnd.mts": {
    "source": "iana",
    "extensions": ["mts"]
  },
  "model/vnd.opengex": {
    "source": "iana",
    "extensions": ["ogex"]
  },
  "model/vnd.parasolid.transmit.binary": {
    "source": "iana",
    "extensions": ["x_b"]
  },
  "model/vnd.parasolid.transmit.text": {
    "source": "iana",
    "extensions": ["x_t"]
  },
  "model/vnd.rosette.annotated-data-model": {
    "source": "iana"
  },
  "model/vnd.usdz+zip": {
    "source": "iana",
    "compressible": false,
    "extensions": ["usdz"]
  },
  "model/vnd.valve.source.compiled-map": {
    "source": "iana",
    "extensions": ["bsp"]
  },
  "model/vnd.vtu": {
    "source": "iana",
    "extensions": ["vtu"]
  },
  "model/vrml": {
    "source": "iana",
    "compressible": false,
    "extensions": ["wrl","vrml"]
  },
  "model/x3d+binary": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3db","x3dbz"]
  },
  "model/x3d+fastinfoset": {
    "source": "iana",
    "extensions": ["x3db"]
  },
  "model/x3d+vrml": {
    "source": "apache",
    "compressible": false,
    "extensions": ["x3dv","x3dvz"]
  },
  "model/x3d+xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["x3d","x3dz"]
  },
  "model/x3d-vrml": {
    "source": "iana",
    "extensions": ["x3dv"]
  },
  "multipart/alternative": {
    "source": "iana",
    "compressible": false
  },
  "multipart/appledouble": {
    "source": "iana"
  },
  "multipart/byteranges": {
    "source": "iana"
  },
  "multipart/digest": {
    "source": "iana"
  },
  "multipart/encrypted": {
    "source": "iana",
    "compressible": false
  },
  "multipart/form-data": {
    "source": "iana",
    "compressible": false
  },
  "multipart/header-set": {
    "source": "iana"
  },
  "multipart/mixed": {
    "source": "iana"
  },
  "multipart/multilingual": {
    "source": "iana"
  },
  "multipart/parallel": {
    "source": "iana"
  },
  "multipart/related": {
    "source": "iana",
    "compressible": false
  },
  "multipart/report": {
    "source": "iana"
  },
  "multipart/signed": {
    "source": "iana",
    "compressible": false
  },
  "multipart/vnd.bint.med-plus": {
    "source": "iana"
  },
  "multipart/voice-message": {
    "source": "iana"
  },
  "multipart/x-mixed-replace": {
    "source": "iana"
  },
  "text/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "text/cache-manifest": {
    "source": "iana",
    "compressible": true,
    "extensions": ["appcache","manifest"]
  },
  "text/calendar": {
    "source": "iana",
    "extensions": ["ics","ifb"]
  },
  "text/calender": {
    "compressible": true
  },
  "text/cmd": {
    "compressible": true
  },
  "text/coffeescript": {
    "extensions": ["coffee","litcoffee"]
  },
  "text/css": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["css"]
  },
  "text/csv": {
    "source": "iana",
    "compressible": true,
    "extensions": ["csv"]
  },
  "text/csv-schema": {
    "source": "iana"
  },
  "text/directory": {
    "source": "iana"
  },
  "text/dns": {
    "source": "iana"
  },
  "text/ecmascript": {
    "source": "iana"
  },
  "text/encaprtp": {
    "source": "iana"
  },
  "text/enriched": {
    "source": "iana"
  },
  "text/flexfec": {
    "source": "iana"
  },
  "text/fwdred": {
    "source": "iana"
  },
  "text/gff3": {
    "source": "iana"
  },
  "text/grammar-ref-list": {
    "source": "iana"
  },
  "text/html": {
    "source": "iana",
    "compressible": true,
    "extensions": ["html","htm","shtml"]
  },
  "text/jade": {
    "extensions": ["jade"]
  },
  "text/javascript": {
    "source": "iana",
    "compressible": true
  },
  "text/jcr-cnd": {
    "source": "iana"
  },
  "text/jsx": {
    "compressible": true,
    "extensions": ["jsx"]
  },
  "text/less": {
    "compressible": true,
    "extensions": ["less"]
  },
  "text/markdown": {
    "source": "iana",
    "compressible": true,
    "extensions": ["markdown","md"]
  },
  "text/mathml": {
    "source": "nginx",
    "extensions": ["mml"]
  },
  "text/mdx": {
    "compressible": true,
    "extensions": ["mdx"]
  },
  "text/mizar": {
    "source": "iana"
  },
  "text/n3": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["n3"]
  },
  "text/parameters": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/parityfec": {
    "source": "iana"
  },
  "text/plain": {
    "source": "iana",
    "compressible": true,
    "extensions": ["txt","text","conf","def","list","log","in","ini"]
  },
  "text/provenance-notation": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    "source": "iana"
  },
  "text/prs.lines.tag": {
    "source": "iana",
    "extensions": ["dsc"]
  },
  "text/prs.prop.logic": {
    "source": "iana"
  },
  "text/raptorfec": {
    "source": "iana"
  },
  "text/red": {
    "source": "iana"
  },
  "text/rfc822-headers": {
    "source": "iana"
  },
  "text/richtext": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtx"]
  },
  "text/rtf": {
    "source": "iana",
    "compressible": true,
    "extensions": ["rtf"]
  },
  "text/rtp-enc-aescm128": {
    "source": "iana"
  },
  "text/rtploopback": {
    "source": "iana"
  },
  "text/rtx": {
    "source": "iana"
  },
  "text/sgml": {
    "source": "iana",
    "extensions": ["sgml","sgm"]
  },
  "text/shaclc": {
    "source": "iana"
  },
  "text/shex": {
    "extensions": ["shex"]
  },
  "text/slim": {
    "extensions": ["slim","slm"]
  },
  "text/spdx": {
    "source": "iana",
    "extensions": ["spdx"]
  },
  "text/strings": {
    "source": "iana"
  },
  "text/stylus": {
    "extensions": ["stylus","styl"]
  },
  "text/t140": {
    "source": "iana"
  },
  "text/tab-separated-values": {
    "source": "iana",
    "compressible": true,
    "extensions": ["tsv"]
  },
  "text/troff": {
    "source": "iana",
    "extensions": ["t","tr","roff","man","me","ms"]
  },
  "text/turtle": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["ttl"]
  },
  "text/ulpfec": {
    "source": "iana"
  },
  "text/uri-list": {
    "source": "iana",
    "compressible": true,
    "extensions": ["uri","uris","urls"]
  },
  "text/vcard": {
    "source": "iana",
    "compressible": true,
    "extensions": ["vcard"]
  },
  "text/vnd.a": {
    "source": "iana"
  },
  "text/vnd.abc": {
    "source": "iana"
  },
  "text/vnd.ascii-art": {
    "source": "iana"
  },
  "text/vnd.curl": {
    "source": "iana",
    "extensions": ["curl"]
  },
  "text/vnd.curl.dcurl": {
    "source": "apache",
    "extensions": ["dcurl"]
  },
  "text/vnd.curl.mcurl": {
    "source": "apache",
    "extensions": ["mcurl"]
  },
  "text/vnd.curl.scurl": {
    "source": "apache",
    "extensions": ["scurl"]
  },
  "text/vnd.debian.copyright": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.dmclientscript": {
    "source": "iana"
  },
  "text/vnd.dvb.subtitle": {
    "source": "iana",
    "extensions": ["sub"]
  },
  "text/vnd.esmertec.theme-descriptor": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.ficlab.flt": {
    "source": "iana"
  },
  "text/vnd.fly": {
    "source": "iana",
    "extensions": ["fly"]
  },
  "text/vnd.fmi.flexstor": {
    "source": "iana",
    "extensions": ["flx"]
  },
  "text/vnd.gml": {
    "source": "iana"
  },
  "text/vnd.graphviz": {
    "source": "iana",
    "extensions": ["gv"]
  },
  "text/vnd.hans": {
    "source": "iana"
  },
  "text/vnd.hgl": {
    "source": "iana"
  },
  "text/vnd.in3d.3dml": {
    "source": "iana",
    "extensions": ["3dml"]
  },
  "text/vnd.in3d.spot": {
    "source": "iana",
    "extensions": ["spot"]
  },
  "text/vnd.iptc.newsml": {
    "source": "iana"
  },
  "text/vnd.iptc.nitf": {
    "source": "iana"
  },
  "text/vnd.latex-z": {
    "source": "iana"
  },
  "text/vnd.motorola.reflex": {
    "source": "iana"
  },
  "text/vnd.ms-mediapackage": {
    "source": "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    "source": "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    "source": "iana"
  },
  "text/vnd.senx.warpscript": {
    "source": "iana"
  },
  "text/vnd.si.uricatalogue": {
    "source": "iana"
  },
  "text/vnd.sosi": {
    "source": "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    "source": "iana",
    "charset": "UTF-8",
    "extensions": ["jad"]
  },
  "text/vnd.trolltech.linguist": {
    "source": "iana",
    "charset": "UTF-8"
  },
  "text/vnd.wap.si": {
    "source": "iana"
  },
  "text/vnd.wap.sl": {
    "source": "iana"
  },
  "text/vnd.wap.wml": {
    "source": "iana",
    "extensions": ["wml"]
  },
  "text/vnd.wap.wmlscript": {
    "source": "iana",
    "extensions": ["wmls"]
  },
  "text/vtt": {
    "source": "iana",
    "charset": "UTF-8",
    "compressible": true,
    "extensions": ["vtt"]
  },
  "text/x-asm": {
    "source": "apache",
    "extensions": ["s","asm"]
  },
  "text/x-c": {
    "source": "apache",
    "extensions": ["c","cc","cxx","cpp","h","hh","dic"]
  },
  "text/x-component": {
    "source": "nginx",
    "extensions": ["htc"]
  },
  "text/x-fortran": {
    "source": "apache",
    "extensions": ["f","for","f77","f90"]
  },
  "text/x-gwt-rpc": {
    "compressible": true
  },
  "text/x-handlebars-template": {
    "extensions": ["hbs"]
  },
  "text/x-java-source": {
    "source": "apache",
    "extensions": ["java"]
  },
  "text/x-jquery-tmpl": {
    "compressible": true
  },
  "text/x-lua": {
    "extensions": ["lua"]
  },
  "text/x-markdown": {
    "compressible": true,
    "extensions": ["mkd"]
  },
  "text/x-nfo": {
    "source": "apache",
    "extensions": ["nfo"]
  },
  "text/x-opml": {
    "source": "apache",
    "extensions": ["opml"]
  },
  "text/x-org": {
    "compressible": true,
    "extensions": ["org"]
  },
  "text/x-pascal": {
    "source": "apache",
    "extensions": ["p","pas"]
  },
  "text/x-processing": {
    "compressible": true,
    "extensions": ["pde"]
  },
  "text/x-sass": {
    "extensions": ["sass"]
  },
  "text/x-scss": {
    "extensions": ["scss"]
  },
  "text/x-setext": {
    "source": "apache",
    "extensions": ["etx"]
  },
  "text/x-sfv": {
    "source": "apache",
    "extensions": ["sfv"]
  },
  "text/x-suse-ymp": {
    "compressible": true,
    "extensions": ["ymp"]
  },
  "text/x-uuencode": {
    "source": "apache",
    "extensions": ["uu"]
  },
  "text/x-vcalendar": {
    "source": "apache",
    "extensions": ["vcs"]
  },
  "text/x-vcard": {
    "source": "apache",
    "extensions": ["vcf"]
  },
  "text/xml": {
    "source": "iana",
    "compressible": true,
    "extensions": ["xml"]
  },
  "text/xml-external-parsed-entity": {
    "source": "iana"
  },
  "text/yaml": {
    "extensions": ["yaml","yml"]
  },
  "video/1d-interleaved-parityfec": {
    "source": "iana"
  },
  "video/3gpp": {
    "source": "iana",
    "extensions": ["3gp","3gpp"]
  },
  "video/3gpp-tt": {
    "source": "iana"
  },
  "video/3gpp2": {
    "source": "iana",
    "extensions": ["3g2"]
  },
  "video/bmpeg": {
    "source": "iana"
  },
  "video/bt656": {
    "source": "iana"
  },
  "video/celb": {
    "source": "iana"
  },
  "video/dv": {
    "source": "iana"
  },
  "video/encaprtp": {
    "source": "iana"
  },
  "video/flexfec": {
    "source": "iana"
  },
  "video/h261": {
    "source": "iana",
    "extensions": ["h261"]
  },
  "video/h263": {
    "source": "iana",
    "extensions": ["h263"]
  },
  "video/h263-1998": {
    "source": "iana"
  },
  "video/h263-2000": {
    "source": "iana"
  },
  "video/h264": {
    "source": "iana",
    "extensions": ["h264"]
  },
  "video/h264-rcdo": {
    "source": "iana"
  },
  "video/h264-svc": {
    "source": "iana"
  },
  "video/h265": {
    "source": "iana"
  },
  "video/iso.segment": {
    "source": "iana"
  },
  "video/jpeg": {
    "source": "iana",
    "extensions": ["jpgv"]
  },
  "video/jpeg2000": {
    "source": "iana"
  },
  "video/jpm": {
    "source": "apache",
    "extensions": ["jpm","jpgm"]
  },
  "video/mj2": {
    "source": "iana",
    "extensions": ["mj2","mjp2"]
  },
  "video/mp1s": {
    "source": "iana"
  },
  "video/mp2p": {
    "source": "iana"
  },
  "video/mp2t": {
    "source": "iana",
    "extensions": ["ts"]
  },
  "video/mp4": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mp4","mp4v","mpg4"]
  },
  "video/mp4v-es": {
    "source": "iana"
  },
  "video/mpeg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["mpeg","mpg","mpe","m1v","m2v"]
  },
  "video/mpeg4-generic": {
    "source": "iana"
  },
  "video/mpv": {
    "source": "iana"
  },
  "video/nv": {
    "source": "iana"
  },
  "video/ogg": {
    "source": "iana",
    "compressible": false,
    "extensions": ["ogv"]
  },
  "video/parityfec": {
    "source": "iana"
  },
  "video/pointer": {
    "source": "iana"
  },
  "video/quicktime": {
    "source": "iana",
    "compressible": false,
    "extensions": ["qt","mov"]
  },
  "video/raptorfec": {
    "source": "iana"
  },
  "video/raw": {
    "source": "iana"
  },
  "video/rtp-enc-aescm128": {
    "source": "iana"
  },
  "video/rtploopback": {
    "source": "iana"
  },
  "video/rtx": {
    "source": "iana"
  },
  "video/smpte291": {
    "source": "iana"
  },
  "video/smpte292m": {
    "source": "iana"
  },
  "video/ulpfec": {
    "source": "iana"
  },
  "video/vc1": {
    "source": "iana"
  },
  "video/vc2": {
    "source": "iana"
  },
  "video/vnd.cctv": {
    "source": "iana"
  },
  "video/vnd.dece.hd": {
    "source": "iana",
    "extensions": ["uvh","uvvh"]
  },
  "video/vnd.dece.mobile": {
    "source": "iana",
    "extensions": ["uvm","uvvm"]
  },
  "video/vnd.dece.mp4": {
    "source": "iana"
  },
  "video/vnd.dece.pd": {
    "source": "iana",
    "extensions": ["uvp","uvvp"]
  },
  "video/vnd.dece.sd": {
    "source": "iana",
    "extensions": ["uvs","uvvs"]
  },
  "video/vnd.dece.video": {
    "source": "iana",
    "extensions": ["uvv","uvvv"]
  },
  "video/vnd.directv.mpeg": {
    "source": "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    "source": "iana"
  },
  "video/vnd.dvb.file": {
    "source": "iana",
    "extensions": ["dvb"]
  },
  "video/vnd.fvt": {
    "source": "iana",
    "extensions": ["fvt"]
  },
  "video/vnd.hns.video": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    "source": "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    "source": "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    "source": "iana"
  },
  "video/vnd.motorola.video": {
    "source": "iana"
  },
  "video/vnd.motorola.videop": {
    "source": "iana"
  },
  "video/vnd.mpegurl": {
    "source": "iana",
    "extensions": ["mxu","m4u"]
  },
  "video/vnd.ms-playready.media.pyv": {
    "source": "iana",
    "extensions": ["pyv"]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    "source": "iana"
  },
  "video/vnd.nokia.mp4vr": {
    "source": "iana"
  },
  "video/vnd.nokia.videovoip": {
    "source": "iana"
  },
  "video/vnd.objectvideo": {
    "source": "iana"
  },
  "video/vnd.radgamettools.bink": {
    "source": "iana"
  },
  "video/vnd.radgamettools.smacker": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg1": {
    "source": "iana"
  },
  "video/vnd.sealed.mpeg4": {
    "source": "iana"
  },
  "video/vnd.sealed.swf": {
    "source": "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    "source": "iana"
  },
  "video/vnd.uvvu.mp4": {
    "source": "iana",
    "extensions": ["uvu","uvvu"]
  },
  "video/vnd.vivo": {
    "source": "iana",
    "extensions": ["viv"]
  },
  "video/vnd.youtube.yt": {
    "source": "iana"
  },
  "video/vp8": {
    "source": "iana"
  },
  "video/webm": {
    "source": "apache",
    "compressible": false,
    "extensions": ["webm"]
  },
  "video/x-f4v": {
    "source": "apache",
    "extensions": ["f4v"]
  },
  "video/x-fli": {
    "source": "apache",
    "extensions": ["fli"]
  },
  "video/x-flv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["flv"]
  },
  "video/x-m4v": {
    "source": "apache",
    "extensions": ["m4v"]
  },
  "video/x-matroska": {
    "source": "apache",
    "compressible": false,
    "extensions": ["mkv","mk3d","mks"]
  },
  "video/x-mng": {
    "source": "apache",
    "extensions": ["mng"]
  },
  "video/x-ms-asf": {
    "source": "apache",
    "extensions": ["asf","asx"]
  },
  "video/x-ms-vob": {
    "source": "apache",
    "extensions": ["vob"]
  },
  "video/x-ms-wm": {
    "source": "apache",
    "extensions": ["wm"]
  },
  "video/x-ms-wmv": {
    "source": "apache",
    "compressible": false,
    "extensions": ["wmv"]
  },
  "video/x-ms-wmx": {
    "source": "apache",
    "extensions": ["wmx"]
  },
  "video/x-ms-wvx": {
    "source": "apache",
    "extensions": ["wvx"]
  },
  "video/x-msvideo": {
    "source": "apache",
    "extensions": ["avi"]
  },
  "video/x-sgi-movie": {
    "source": "apache",
    "extensions": ["movie"]
  },
  "video/x-smv": {
    "source": "apache",
    "extensions": ["smv"]
  },
  "x-conference/x-cooltalk": {
    "source": "apache",
    "extensions": ["ice"]
  },
  "x-shader/x-fragment": {
    "compressible": true
  },
  "x-shader/x-vertex": {
    "compressible": true
  }
}`));
        }
    };
});
System.register("https://deno.land/x/media_types@v2.5.1/deps", ["https://deno.land/std@0.73.0/path/mod"], function (exports_33, context_33) {
    "use strict";
    var __moduleName = context_33 && context_33.id;
    return {
        setters: [
            function (mod_ts_8_1) {
                exports_33({
                    "extname": mod_ts_8_1["extname"]
                });
            }
        ],
        execute: function () {
        }
    };
});
/*!
 * Ported from: https://github.com/jshttp/mime-types and licensed as:
 *
 * (The MIT License)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2015 Douglas Christopher Wilson <doug@somethingdoug.com>
 * Copyright (c) 2020 the Deno authors
 * Copyright (c) 2020 the oak authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/media_types@v2.5.1/mod", ["https://deno.land/x/media_types@v2.5.1/db", "https://deno.land/x/media_types@v2.5.1/deps"], function (exports_34, context_34) {
    "use strict";
    var db_ts_1, deps_ts_1, EXTRACT_TYPE_REGEXP, TEXT_TYPE_REGEXP, extensions, types;
    var __moduleName = context_34 && context_34.id;
    function populateMaps(extensions, types) {
        const preference = ["nginx", "apache", undefined, "iana"];
        for (const type of Object.keys(db_ts_1.db)) {
            const mime = db_ts_1.db[type];
            const exts = mime.extensions;
            if (!exts || !exts.length) {
                continue;
            }
            extensions.set(type, exts);
            for (const ext of exts) {
                const current = types.get(ext);
                if (current) {
                    const from = preference.indexOf(db_ts_1.db[current].source);
                    const to = preference.indexOf(mime.source);
                    if (current !== "application/octet-stream" &&
                        (from > to ||
                            (from === to && current.substr(0, 12) === "application/"))) {
                        continue;
                    }
                }
                types.set(ext, type);
            }
        }
    }
    function charset(type) {
        const m = EXTRACT_TYPE_REGEXP.exec(type);
        if (!m) {
            return;
        }
        const [match] = m;
        const mime = db_ts_1.db[match.toLowerCase()];
        if (mime && mime.charset) {
            return mime.charset;
        }
        if (TEXT_TYPE_REGEXP.test(match)) {
            return "UTF-8";
        }
    }
    exports_34("charset", charset);
    function lookup(path) {
        const extension = deps_ts_1.extname("x." + path)
            .toLowerCase()
            .substr(1);
        return types.get(extension);
    }
    exports_34("lookup", lookup);
    function contentType(str) {
        let mime = str.includes("/") ? str : lookup(str);
        if (!mime) {
            return;
        }
        if (!mime.includes("charset")) {
            const cs = charset(mime);
            if (cs) {
                mime += `; charset=${cs.toLowerCase()}`;
            }
        }
        return mime;
    }
    exports_34("contentType", contentType);
    function extension(type) {
        const match = EXTRACT_TYPE_REGEXP.exec(type);
        if (!match) {
            return;
        }
        const exts = extensions.get(match[1].toLowerCase());
        if (!exts || !exts.length) {
            return;
        }
        return exts[0];
    }
    exports_34("extension", extension);
    return {
        setters: [
            function (db_ts_1_1) {
                db_ts_1 = db_ts_1_1;
            },
            function (deps_ts_1_1) {
                deps_ts_1 = deps_ts_1_1;
            }
        ],
        execute: function () {
            EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
            TEXT_TYPE_REGEXP = /^text\//i;
            exports_34("extensions", extensions = new Map());
            exports_34("types", types = new Map());
            populateMaps(extensions, types);
        }
    };
});
System.register("https://deno.land/x/path_to_regexp@v6.2.0/index", [], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    function lexer(str) {
        const tokens = [];
        let i = 0;
        while (i < str.length) {
            const char = str[i];
            if (char === "*" || char === "+" || char === "?") {
                tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
                continue;
            }
            if (char === "\\") {
                tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
                continue;
            }
            if (char === "{") {
                tokens.push({ type: "OPEN", index: i, value: str[i++] });
                continue;
            }
            if (char === "}") {
                tokens.push({ type: "CLOSE", index: i, value: str[i++] });
                continue;
            }
            if (char === ":") {
                let name = "";
                let j = i + 1;
                while (j < str.length) {
                    const code = str.charCodeAt(j);
                    if ((code >= 48 && code <= 57) ||
                        (code >= 65 && code <= 90) ||
                        (code >= 97 && code <= 122) ||
                        code === 95) {
                        name += str[j++];
                        continue;
                    }
                    break;
                }
                if (!name)
                    throw new TypeError(`Missing parameter name at ${i}`);
                tokens.push({ type: "NAME", index: i, value: name });
                i = j;
                continue;
            }
            if (char === "(") {
                let count = 1;
                let pattern = "";
                let j = i + 1;
                if (str[j] === "?") {
                    throw new TypeError(`Pattern cannot start with "?" at ${j}`);
                }
                while (j < str.length) {
                    if (str[j] === "\\") {
                        pattern += str[j++] + str[j++];
                        continue;
                    }
                    if (str[j] === ")") {
                        count--;
                        if (count === 0) {
                            j++;
                            break;
                        }
                    }
                    else if (str[j] === "(") {
                        count++;
                        if (str[j + 1] !== "?") {
                            throw new TypeError(`Capturing groups are not allowed at ${j}`);
                        }
                    }
                    pattern += str[j++];
                }
                if (count)
                    throw new TypeError(`Unbalanced pattern at ${i}`);
                if (!pattern)
                    throw new TypeError(`Missing pattern at ${i}`);
                tokens.push({ type: "PATTERN", index: i, value: pattern });
                i = j;
                continue;
            }
            tokens.push({ type: "CHAR", index: i, value: str[i++] });
        }
        tokens.push({ type: "END", index: i, value: "" });
        return tokens;
    }
    function parse(str, options = {}) {
        const tokens = lexer(str);
        const { prefixes = "./" } = options;
        const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
        const result = [];
        let key = 0;
        let i = 0;
        let path = "";
        const tryConsume = (type) => {
            if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
        };
        const mustConsume = (type) => {
            const value = tryConsume(type);
            if (value !== undefined)
                return value;
            const { type: nextType, index } = tokens[i];
            throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
        };
        const consumeText = () => {
            let result = "";
            let value;
            while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                result += value;
            }
            return result;
        };
        while (i < tokens.length) {
            const char = tryConsume("CHAR");
            const name = tryConsume("NAME");
            const pattern = tryConsume("PATTERN");
            if (name || pattern) {
                let prefix = char || "";
                if (prefixes.indexOf(prefix) === -1) {
                    path += prefix;
                    prefix = "";
                }
                if (path) {
                    result.push(path);
                    path = "";
                }
                result.push({
                    name: name || key++,
                    prefix,
                    suffix: "",
                    pattern: pattern || defaultPattern,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            const value = char || tryConsume("ESCAPED_CHAR");
            if (value) {
                path += value;
                continue;
            }
            if (path) {
                result.push(path);
                path = "";
            }
            const open = tryConsume("OPEN");
            if (open) {
                const prefix = consumeText();
                const name = tryConsume("NAME") || "";
                const pattern = tryConsume("PATTERN") || "";
                const suffix = consumeText();
                mustConsume("CLOSE");
                result.push({
                    name: name || (pattern ? key++ : ""),
                    pattern: name && !pattern ? defaultPattern : pattern,
                    prefix,
                    suffix,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            mustConsume("END");
        }
        return result;
    }
    exports_35("parse", parse);
    function compile(str, options) {
        return tokensToFunction(parse(str, options), options);
    }
    exports_35("compile", compile);
    function tokensToFunction(tokens, options = {}) {
        const reFlags = flags(options);
        const { encode = (x) => x, validate = true } = options;
        const matches = tokens.map(token => {
            if (typeof token === "object") {
                return new RegExp(`^(?:${token.pattern})$`, reFlags);
            }
        });
        return (data) => {
            let path = "";
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                const value = data ? data[token.name] : undefined;
                const optional = token.modifier === "?" || token.modifier === "*";
                const repeat = token.modifier === "*" || token.modifier === "+";
                if (Array.isArray(value)) {
                    if (!repeat) {
                        throw new TypeError(`Expected "${token.name}" to not repeat, but got an array`);
                    }
                    if (value.length === 0) {
                        if (optional)
                            continue;
                        throw new TypeError(`Expected "${token.name}" to not be empty`);
                    }
                    for (let j = 0; j < value.length; j++) {
                        const segment = encode(value[j], token);
                        if (validate && !matches[i].test(segment)) {
                            throw new TypeError(`Expected all "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                        }
                        path += token.prefix + segment + token.suffix;
                    }
                    continue;
                }
                if (typeof value === "string" || typeof value === "number") {
                    const segment = encode(String(value), token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError(`Expected "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                    }
                    path += token.prefix + segment + token.suffix;
                    continue;
                }
                if (optional)
                    continue;
                const typeOfMessage = repeat ? "an array" : "a string";
                throw new TypeError(`Expected "${token.name}" to be ${typeOfMessage}`);
            }
            return path;
        };
    }
    exports_35("tokensToFunction", tokensToFunction);
    function match(str, options) {
        const keys = [];
        const re = pathToRegexp(str, keys, options);
        return regexpToFunction(re, keys, options);
    }
    exports_35("match", match);
    function regexpToFunction(re, keys, options = {}) {
        const { decode = (x) => x } = options;
        return function (pathname) {
            const m = re.exec(pathname);
            if (!m)
                return false;
            const { 0: path, index } = m;
            const params = Object.create(null);
            for (let i = 1; i < m.length; i++) {
                if (m[i] === undefined)
                    continue;
                const key = keys[i - 1];
                if (key.modifier === "*" || key.modifier === "+") {
                    params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {
                        return decode(value, key);
                    });
                }
                else {
                    params[key.name] = decode(m[i], key);
                }
            }
            return { path, index, params };
        };
    }
    exports_35("regexpToFunction", regexpToFunction);
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function flags(options) {
        return options && options.sensitive ? "" : "i";
    }
    function regexpToRegexp(path, keys) {
        if (!keys)
            return path;
        const groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
        let index = 0;
        let execResult = groupsRegex.exec(path.source);
        while (execResult) {
            keys.push({
                name: execResult[1] || index++,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
            execResult = groupsRegex.exec(path.source);
        }
        return path;
    }
    function arrayToRegexp(paths, keys, options) {
        const parts = paths.map(path => pathToRegexp(path, keys, options).source);
        return new RegExp(`(?:${parts.join("|")})`, flags(options));
    }
    function stringToRegexp(path, keys, options) {
        return tokensToRegexp(parse(path, options), keys, options);
    }
    function tokensToRegexp(tokens, keys, options = {}) {
        const { strict = false, start = true, end = true, encode = (x) => x } = options;
        const endsWith = `[${escapeString(options.endsWith || "")}]|$`;
        const delimiter = `[${escapeString(options.delimiter || "/#?")}]`;
        let route = start ? "^" : "";
        for (const token of tokens) {
            if (typeof token === "string") {
                route += escapeString(encode(token));
            }
            else {
                const prefix = escapeString(encode(token.prefix));
                const suffix = escapeString(encode(token.suffix));
                if (token.pattern) {
                    if (keys)
                        keys.push(token);
                    if (prefix || suffix) {
                        if (token.modifier === "+" || token.modifier === "*") {
                            const mod = token.modifier === "*" ? "?" : "";
                            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;
                        }
                        else {
                            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                        }
                    }
                    else {
                        route += `(${token.pattern})${token.modifier}`;
                    }
                }
                else {
                    route += `(?:${prefix}${suffix})${token.modifier}`;
                }
            }
        }
        if (end) {
            if (!strict)
                route += `${delimiter}?`;
            route += !options.endsWith ? "$" : `(?=${endsWith})`;
        }
        else {
            const endToken = tokens[tokens.length - 1];
            const isEndDelimited = typeof endToken === "string"
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                :
                    endToken === undefined;
            if (!strict) {
                route += `(?:${delimiter}(?=${endsWith}))?`;
            }
            if (!isEndDelimited) {
                route += `(?=${delimiter}|${endsWith})`;
            }
        }
        return new RegExp(route, flags(options));
    }
    exports_35("tokensToRegexp", tokensToRegexp);
    function pathToRegexp(path, keys, options) {
        if (path instanceof RegExp)
            return regexpToRegexp(path, keys);
        if (Array.isArray(path))
            return arrayToRegexp(path, keys, options);
        return stringToRegexp(path, keys, options);
    }
    exports_35("pathToRegexp", pathToRegexp);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/deps", ["https://deno.land/std@0.73.0/bytes/mod", "https://deno.land/std@0.73.0/hash/sha1", "https://deno.land/std@0.73.0/hash/sha256", "https://deno.land/std@0.73.0/http/server", "https://deno.land/std@0.73.0/http/http_status", "https://deno.land/std@0.73.0/io/bufio", "https://deno.land/std@0.73.0/path/mod", "https://deno.land/std@0.73.0/testing/asserts", "https://deno.land/std@0.73.0/ws/mod", "https://deno.land/x/media_types@v2.5.1/mod", "https://deno.land/x/path_to_regexp@v6.2.0/index"], function (exports_36, context_36) {
    "use strict";
    var __moduleName = context_36 && context_36.id;
    return {
        setters: [
            function (mod_ts_9_1) {
                exports_36({
                    "copyBytes": mod_ts_9_1["copyBytes"],
                    "equal": mod_ts_9_1["equal"]
                });
            },
            function (sha1_ts_2_1) {
                exports_36({
                    "Sha1": sha1_ts_2_1["Sha1"]
                });
            },
            function (sha256_ts_1_1) {
                exports_36({
                    "HmacSha256": sha256_ts_1_1["HmacSha256"]
                });
            },
            function (server_ts_2_1) {
                exports_36({
                    "serve": server_ts_2_1["serve"],
                    "serveTLS": server_ts_2_1["serveTLS"]
                });
            },
            function (http_status_ts_2_1) {
                exports_36({
                    "Status": http_status_ts_2_1["Status"],
                    "STATUS_TEXT": http_status_ts_2_1["STATUS_TEXT"]
                });
            },
            function (bufio_ts_4_1) {
                exports_36({
                    "BufReader": bufio_ts_4_1["BufReader"],
                    "BufWriter": bufio_ts_4_1["BufWriter"]
                });
            },
            function (mod_ts_10_1) {
                exports_36({
                    "basename": mod_ts_10_1["basename"],
                    "extname": mod_ts_10_1["extname"],
                    "isAbsolute": mod_ts_10_1["isAbsolute"],
                    "join": mod_ts_10_1["join"],
                    "normalize": mod_ts_10_1["normalize"],
                    "parse": mod_ts_10_1["parse"],
                    "sep": mod_ts_10_1["sep"]
                });
            },
            function (asserts_ts_1_1) {
                exports_36({
                    "assert": asserts_ts_1_1["assert"]
                });
            },
            function (mod_ts_11_1) {
                exports_36({
                    "acceptable": mod_ts_11_1["acceptable"],
                    "acceptWebSocket": mod_ts_11_1["acceptWebSocket"]
                });
            },
            function (mod_ts_12_1) {
                exports_36({
                    "contentType": mod_ts_12_1["contentType"],
                    "extension": mod_ts_12_1["extension"],
                    "lookup": mod_ts_12_1["lookup"]
                });
            },
            function (index_ts_1_1) {
                exports_36({
                    "compile": index_ts_1_1["compile"],
                    "pathParse": index_ts_1_1["parse"],
                    "pathToRegexp": index_ts_1_1["pathToRegexp"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/tssCompare", ["https://deno.land/x/oak@v6.3.1/deps"], function (exports_37, context_37) {
    "use strict";
    var deps_ts_2;
    var __moduleName = context_37 && context_37.id;
    function compareArrayBuffer(a, b) {
        deps_ts_2.assert(a.byteLength === b.byteLength, "ArrayBuffer lengths must match.");
        const va = new DataView(a);
        const vb = new DataView(b);
        const length = va.byteLength;
        let out = 0;
        let i = -1;
        while (++i < length) {
            out |= va.getUint8(i) ^ vb.getUint8(i);
        }
        return out === 0;
    }
    function compare(a, b) {
        const key = new Uint8Array(32);
        globalThis.crypto.getRandomValues(key);
        const ah = (new deps_ts_2.HmacSha256(key)).update(a).arrayBuffer();
        const bh = (new deps_ts_2.HmacSha256(key)).update(b).arrayBuffer();
        return compareArrayBuffer(ah, bh);
    }
    exports_37("compare", compare);
    return {
        setters: [
            function (deps_ts_2_1) {
                deps_ts_2 = deps_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/keyStack", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/tssCompare"], function (exports_38, context_38) {
    "use strict";
    var deps_ts_3, tssCompare_ts_1, replacements, KeyStack;
    var __moduleName = context_38 && context_38.id;
    return {
        setters: [
            function (deps_ts_3_1) {
                deps_ts_3 = deps_ts_3_1;
            },
            function (tssCompare_ts_1_1) {
                tssCompare_ts_1 = tssCompare_ts_1_1;
            }
        ],
        execute: function () {
            replacements = {
                "/": "_",
                "+": "-",
                "=": "",
            };
            KeyStack = class KeyStack {
                constructor(keys) {
                    this.#sign = (data, key) => {
                        return btoa(String.fromCharCode.apply(undefined, new Uint8Array(new deps_ts_3.HmacSha256(key).update(data).arrayBuffer())))
                            .replace(/\/|\+|=/g, (c) => replacements[c]);
                    };
                    if (!(0 in keys)) {
                        throw new TypeError("keys must contain at least one value");
                    }
                    this.#keys = keys;
                }
                #keys;
                #sign;
                sign(data) {
                    return this.#sign(data, this.#keys[0]);
                }
                verify(data, digest) {
                    return this.indexOf(data, digest) > -1;
                }
                indexOf(data, digest) {
                    for (let i = 0; i < this.#keys.length; i++) {
                        if (tssCompare_ts_1.compare(digest, this.#sign(data, this.#keys[i]))) {
                            return i;
                        }
                    }
                    return -1;
                }
            };
            exports_38("KeyStack", KeyStack);
        }
    };
});
/*!
 * Adapted directly from http-errors at https://github.com/jshttp/http-errors
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jonathan Ong me@jongleberry.com
 * Copyright (c) 2016 Douglas Christopher Wilson doug@somethingdoug.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/httpError", ["https://deno.land/x/oak@v6.3.1/deps"], function (exports_39, context_39) {
    "use strict";
    var deps_ts_4, errorStatusMap, HttpError, httpErrors;
    var __moduleName = context_39 && context_39.id;
    function createHttpErrorConstructor(status) {
        const name = `${deps_ts_4.Status[status]}Error`;
        const Ctor = class extends HttpError {
            constructor(message) {
                super();
                this.message = message || deps_ts_4.STATUS_TEXT.get(status);
                this.status = status;
                this.expose = status >= 400 && status < 500 ? true : false;
                Object.defineProperty(this, "name", {
                    configurable: true,
                    enumerable: false,
                    value: name,
                    writable: true,
                });
            }
        };
        return Ctor;
    }
    function createHttpError(status = 500, message) {
        return new httpErrors[deps_ts_4.Status[status]](message);
    }
    exports_39("createHttpError", createHttpError);
    function isHttpError(value) {
        return value instanceof HttpError;
    }
    exports_39("isHttpError", isHttpError);
    return {
        setters: [
            function (deps_ts_4_1) {
                deps_ts_4 = deps_ts_4_1;
            }
        ],
        execute: function () {
            errorStatusMap = {
                "BadRequest": 400,
                "Unauthorized": 401,
                "PaymentRequired": 402,
                "Forbidden": 403,
                "NotFound": 404,
                "MethodNotAllowed": 405,
                "NotAcceptable": 406,
                "ProxyAuthRequired": 407,
                "RequestTimeout": 408,
                "Conflict": 409,
                "Gone": 410,
                "LengthRequired": 411,
                "PreconditionFailed": 412,
                "RequestEntityTooLarge": 413,
                "RequestURITooLong": 414,
                "UnsupportedMediaType": 415,
                "RequestedRangeNotSatisfiable": 416,
                "ExpectationFailed": 417,
                "Teapot": 418,
                "MisdirectedRequest": 421,
                "UnprocessableEntity": 422,
                "Locked": 423,
                "FailedDependency": 424,
                "UpgradeRequired": 426,
                "PreconditionRequired": 428,
                "TooManyRequests": 429,
                "RequestHeaderFieldsTooLarge": 431,
                "UnavailableForLegalReasons": 451,
                "InternalServerError": 500,
                "NotImplemented": 501,
                "BadGateway": 502,
                "ServiceUnavailable": 503,
                "GatewayTimeout": 504,
                "HTTPVersionNotSupported": 505,
                "VariantAlsoNegotiates": 506,
                "InsufficientStorage": 507,
                "LoopDetected": 508,
                "NotExtended": 510,
                "NetworkAuthenticationRequired": 511,
            };
            HttpError = class HttpError extends Error {
                constructor() {
                    super(...arguments);
                    this.expose = false;
                    this.status = deps_ts_4.Status.InternalServerError;
                }
            };
            exports_39("HttpError", HttpError);
            exports_39("httpErrors", httpErrors = {});
            for (const [key, value] of Object.entries(errorStatusMap)) {
                httpErrors[key] = createHttpErrorConstructor(value);
            }
        }
    };
});
/*!
 * Adapted directly from media-typer at https://github.com/jshttp/media-typer/
 * which is licensed as follows:
 *
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak@v6.3.1/mediaTyper", [], function (exports_40, context_40) {
    "use strict";
    var SUBTYPE_NAME_REGEXP, TYPE_NAME_REGEXP, TYPE_REGEXP, MediaType;
    var __moduleName = context_40 && context_40.id;
    function format(obj) {
        const { subtype, suffix, type } = obj;
        if (!TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("Invalid type.");
        }
        if (!SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("Invalid subtype.");
        }
        let str = `${type}/${subtype}`;
        if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
                throw new TypeError("Invalid suffix.");
            }
            str += `+${suffix}`;
        }
        return str;
    }
    exports_40("format", format);
    function parse(str) {
        const match = TYPE_REGEXP.exec(str.toLowerCase());
        if (!match) {
            throw new TypeError("Invalid media type.");
        }
        let [, type, subtype] = match;
        let suffix;
        const idx = subtype.lastIndexOf("+");
        if (idx !== -1) {
            suffix = subtype.substr(idx + 1);
            subtype = subtype.substr(0, idx);
        }
        return new MediaType(type, subtype, suffix);
    }
    exports_40("parse", parse);
    return {
        setters: [],
        execute: function () {
            SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
            TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
            TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
            MediaType = class MediaType {
                constructor(type, subtype, suffix) {
                    this.type = type;
                    this.subtype = subtype;
                    this.suffix = suffix;
                }
            };
        }
    };
});
/*!
 * Adapted directly from type-is at https://github.com/jshttp/type-is/
 * which is licensed as follows:
 *
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://deno.land/x/oak@v6.3.1/isMediaType", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/mediaTyper"], function (exports_41, context_41) {
    "use strict";
    var deps_ts_5, mediaTyper_ts_1;
    var __moduleName = context_41 && context_41.id;
    function mimeMatch(expected, actual) {
        if (expected === undefined) {
            return false;
        }
        const actualParts = actual.split("/");
        const expectedParts = expected.split("/");
        if (actualParts.length !== 2 || expectedParts.length !== 2) {
            return false;
        }
        const [actualType, actualSubtype] = actualParts;
        const [expectedType, expectedSubtype] = expectedParts;
        if (expectedType !== "*" && expectedType !== actualType) {
            return false;
        }
        if (expectedSubtype.substr(0, 2) === "*+") {
            return (expectedSubtype.length <= actualSubtype.length + 1 &&
                expectedSubtype.substr(1) ===
                    actualSubtype.substr(1 - expectedSubtype.length));
        }
        if (expectedSubtype !== "*" && expectedSubtype !== actualSubtype) {
            return false;
        }
        return true;
    }
    function normalize(type) {
        if (type === "urlencoded") {
            return "application/x-www-form-urlencoded";
        }
        else if (type === "multipart") {
            return "multipart/*";
        }
        else if (type[0] === "+") {
            return `*/*${type}`;
        }
        return type.includes("/") ? type : deps_ts_5.lookup(type);
    }
    function normalizeType(value) {
        try {
            const val = value.split(";");
            const type = mediaTyper_ts_1.parse(val[0]);
            return mediaTyper_ts_1.format(type);
        }
        catch {
            return;
        }
    }
    function isMediaType(value, types) {
        const val = normalizeType(value);
        if (!val) {
            return false;
        }
        if (!types.length) {
            return val;
        }
        for (const type of types) {
            if (mimeMatch(normalize(type), val)) {
                return type[0] === "+" || type.includes("*") ? val : type;
            }
        }
        return false;
    }
    exports_41("isMediaType", isMediaType);
    return {
        setters: [
            function (deps_ts_5_1) {
                deps_ts_5 = deps_ts_5_1;
            },
            function (mediaTyper_ts_1_1) {
                mediaTyper_ts_1 = mediaTyper_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/util", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError"], function (exports_42, context_42) {
    "use strict";
    var deps_ts_6, httpError_ts_1, ENCODE_CHARS_REGEXP, HTAB, SPACE, CR, LF, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, UP_PATH_REGEXP;
    var __moduleName = context_42 && context_42.id;
    function decodeComponent(text) {
        try {
            return decodeURIComponent(text);
        }
        catch {
            return text;
        }
    }
    exports_42("decodeComponent", decodeComponent);
    function encodeUrl(url) {
        return String(url)
            .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
            .replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
    exports_42("encodeUrl", encodeUrl);
    function getRandomFilename(prefix = "", extension = "") {
        return `${prefix}${new deps_ts_6.Sha1().update(crypto.getRandomValues(new Uint8Array(256))).hex()}${extension ? `.${extension}` : ""}`;
    }
    exports_42("getRandomFilename", getRandomFilename);
    function isErrorStatus(value) {
        return [
            deps_ts_6.Status.BadRequest,
            deps_ts_6.Status.Unauthorized,
            deps_ts_6.Status.PaymentRequired,
            deps_ts_6.Status.Forbidden,
            deps_ts_6.Status.NotFound,
            deps_ts_6.Status.MethodNotAllowed,
            deps_ts_6.Status.NotAcceptable,
            deps_ts_6.Status.ProxyAuthRequired,
            deps_ts_6.Status.RequestTimeout,
            deps_ts_6.Status.Conflict,
            deps_ts_6.Status.Gone,
            deps_ts_6.Status.LengthRequired,
            deps_ts_6.Status.PreconditionFailed,
            deps_ts_6.Status.RequestEntityTooLarge,
            deps_ts_6.Status.RequestURITooLong,
            deps_ts_6.Status.UnsupportedMediaType,
            deps_ts_6.Status.RequestedRangeNotSatisfiable,
            deps_ts_6.Status.ExpectationFailed,
            deps_ts_6.Status.Teapot,
            deps_ts_6.Status.MisdirectedRequest,
            deps_ts_6.Status.UnprocessableEntity,
            deps_ts_6.Status.Locked,
            deps_ts_6.Status.FailedDependency,
            deps_ts_6.Status.UpgradeRequired,
            deps_ts_6.Status.PreconditionRequired,
            deps_ts_6.Status.TooManyRequests,
            deps_ts_6.Status.RequestHeaderFieldsTooLarge,
            deps_ts_6.Status.UnavailableForLegalReasons,
            deps_ts_6.Status.InternalServerError,
            deps_ts_6.Status.NotImplemented,
            deps_ts_6.Status.BadGateway,
            deps_ts_6.Status.ServiceUnavailable,
            deps_ts_6.Status.GatewayTimeout,
            deps_ts_6.Status.HTTPVersionNotSupported,
            deps_ts_6.Status.VariantAlsoNegotiates,
            deps_ts_6.Status.InsufficientStorage,
            deps_ts_6.Status.LoopDetected,
            deps_ts_6.Status.NotExtended,
            deps_ts_6.Status.NetworkAuthenticationRequired,
        ].includes(value);
    }
    exports_42("isErrorStatus", isErrorStatus);
    function isRedirectStatus(value) {
        return [
            deps_ts_6.Status.MultipleChoices,
            deps_ts_6.Status.MovedPermanently,
            deps_ts_6.Status.Found,
            deps_ts_6.Status.SeeOther,
            deps_ts_6.Status.UseProxy,
            deps_ts_6.Status.TemporaryRedirect,
            deps_ts_6.Status.PermanentRedirect,
        ].includes(value);
    }
    exports_42("isRedirectStatus", isRedirectStatus);
    function isHtml(value) {
        return /^\s*<(?:!DOCTYPE|html|body)/i.test(value);
    }
    exports_42("isHtml", isHtml);
    function skipLWSPChar(u8) {
        const result = new Uint8Array(u8.length);
        let j = 0;
        for (let i = 0; i < u8.length; i++) {
            if (u8[i] === SPACE || u8[i] === HTAB)
                continue;
            result[j++] = u8[i];
        }
        return result.slice(0, j);
    }
    exports_42("skipLWSPChar", skipLWSPChar);
    function stripEol(value) {
        if (value[value.byteLength - 1] == LF) {
            let drop = 1;
            if (value.byteLength > 1 && value[value.byteLength - 2] === CR) {
                drop = 2;
            }
            return value.subarray(0, value.byteLength - drop);
        }
        return value;
    }
    exports_42("stripEol", stripEol);
    function resolvePath(rootPath, relativePath) {
        let path = relativePath;
        let root = rootPath;
        if (relativePath === undefined) {
            path = rootPath;
            root = ".";
        }
        if (path == null) {
            throw new TypeError("Argument relativePath is required.");
        }
        if (path.includes("\0")) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        if (deps_ts_6.isAbsolute(path)) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        if (UP_PATH_REGEXP.test(deps_ts_6.normalize("." + deps_ts_6.sep + path))) {
            throw httpError_ts_1.createHttpError(403);
        }
        return deps_ts_6.normalize(deps_ts_6.join(root, path));
    }
    exports_42("resolvePath", resolvePath);
    return {
        setters: [
            function (deps_ts_6_1) {
                deps_ts_6 = deps_ts_6_1;
            },
            function (httpError_ts_1_1) {
                httpError_ts_1 = httpError_ts_1_1;
            }
        ],
        execute: function () {
            ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
            UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
            UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/buf_reader", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/util"], function (exports_43, context_43) {
    "use strict";
    var deps_ts_7, util_ts_1, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, BufReader;
    var __moduleName = context_43 && context_43.id;
    return {
        setters: [
            function (deps_ts_7_1) {
                deps_ts_7 = deps_ts_7_1;
            },
            function (util_ts_1_1) {
                util_ts_1 = util_ts_1_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_43("BufferFullError", BufferFullError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.#posRead = 0;
                    this.#posWrite = 0;
                    this.#eof = false;
                    this.#fill = async () => {
                        if (this.#posRead > 0) {
                            this.#buffer.copyWithin(0, this.#posRead, this.#posWrite);
                            this.#posWrite -= this.#posRead;
                            this.#posRead = 0;
                        }
                        if (this.#posWrite >= this.#buffer.byteLength) {
                            throw Error("bufio: tried to fill full buffer");
                        }
                        for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                            const rr = await this.#reader.read(this.#buffer.subarray(this.#posWrite));
                            if (rr === null) {
                                this.#eof = true;
                                return;
                            }
                            deps_ts_7.assert(rr >= 0, "negative read");
                            this.#posWrite += rr;
                            if (rr > 0) {
                                return;
                            }
                        }
                        throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                    };
                    this.#reset = (buffer, reader) => {
                        this.#buffer = buffer;
                        this.#reader = reader;
                        this.#eof = false;
                    };
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this.#reset(new Uint8Array(size), rd);
                }
                #buffer;
                #reader;
                #posRead;
                #posWrite;
                #eof;
                #fill;
                #reset;
                buffered() {
                    return this.#posWrite - this.#posRead;
                }
                async readLine(strip = true) {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        deps_ts_7.assert(partial instanceof Uint8Array, "Caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.#eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            deps_ts_7.assert(this.#posRead > 0, "Tried to rewind past start of buffer");
                            this.#posRead--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { bytes: partial, eol: this.#eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { bytes: line, eol: true };
                    }
                    if (strip) {
                        line = util_ts_1.stripEol(line);
                    }
                    return { bytes: line, eol: true };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.#buffer.subarray(this.#posRead + s, this.#posWrite).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.#buffer.subarray(this.#posRead, this.#posRead + i + 1);
                            this.#posRead += i + 1;
                            break;
                        }
                        if (this.#eof) {
                            if (this.#posRead === this.#posWrite) {
                                return null;
                            }
                            slice = this.#buffer.subarray(this.#posRead, this.#posWrite);
                            this.#posRead = this.#posWrite;
                            break;
                        }
                        if (this.buffered() >= this.#buffer.byteLength) {
                            this.#posRead = this.#posWrite;
                            const oldbuf = this.#buffer;
                            const newbuf = this.#buffer.slice(0);
                            this.#buffer = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.#posWrite - this.#posRead;
                        try {
                            await this.#fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
            };
            exports_43("BufReader", BufReader);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/headers", ["https://deno.land/x/oak@v6.3.1/httpError"], function (exports_44, context_44) {
    "use strict";
    var httpError_ts_2, COLON, HTAB, SPACE, decoder;
    var __moduleName = context_44 && context_44.id;
    function toParamRegExp(attributePattern, flags) {
        return new RegExp(`(?:^|;)\\s*${attributePattern}\\s*=\\s*` +
            `(` +
            `[^";\\s][^;\\s]*` +
            `|` +
            `"(?:[^"\\\\]|\\\\"?)+"?` +
            `)`, flags);
    }
    exports_44("toParamRegExp", toParamRegExp);
    async function readHeaders(body) {
        const headers = {};
        let readResult = await body.readLine();
        while (readResult) {
            const { bytes } = readResult;
            if (!bytes.length) {
                return headers;
            }
            let i = bytes.indexOf(COLON);
            if (i === -1) {
                throw new httpError_ts_2.httpErrors.BadRequest(`Malformed header: ${decoder.decode(bytes)}`);
            }
            const key = decoder.decode(bytes.subarray(0, i)).trim().toLowerCase();
            if (key === "") {
                throw new httpError_ts_2.httpErrors.BadRequest("Invalid header key.");
            }
            i++;
            while (i < bytes.byteLength && (bytes[i] === SPACE || bytes[i] === HTAB)) {
                i++;
            }
            const value = decoder.decode(bytes.subarray(i)).trim();
            headers[key] = value;
            readResult = await body.readLine();
        }
        throw new httpError_ts_2.httpErrors.BadRequest("Unexpected end of body reached.");
    }
    exports_44("readHeaders", readHeaders);
    function unquote(value) {
        if (value.startsWith(`"`)) {
            const parts = value.slice(1).split(`\\"`);
            for (let i = 0; i < parts.length; ++i) {
                const quoteIndex = parts[i].indexOf(`"`);
                if (quoteIndex !== -1) {
                    parts[i] = parts[i].slice(0, quoteIndex);
                    parts.length = i + 1;
                }
                parts[i] = parts[i].replace(/\\(.)/g, "$1");
            }
            value = parts.join(`"`);
        }
        return value;
    }
    exports_44("unquote", unquote);
    return {
        setters: [
            function (httpError_ts_2_1) {
                httpError_ts_2 = httpError_ts_2_1;
            }
        ],
        execute: function () {
            COLON = ":".charCodeAt(0);
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            decoder = new TextDecoder();
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/content_disposition", ["https://deno.land/x/oak@v6.3.1/headers"], function (exports_45, context_45) {
    "use strict";
    var headers_ts_1, needsEncodingFixup, FILENAME_STAR_REGEX, FILENAME_START_ITER_REGEX, FILENAME_REGEX;
    var __moduleName = context_45 && context_45.id;
    function fixupEncoding(value) {
        if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textDecode("utf-8", value);
            if (needsEncodingFixup) {
                value = textDecode("iso-8859-1", value);
            }
        }
        return value;
    }
    function rfc2047decode(value) {
        if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
            return value;
        }
        return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (_, charset, encoding, text) => {
            if (encoding === "q" || encoding === "Q") {
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
                return textDecode(charset, text);
            }
            try {
                text = atob(text);
            }
            catch { }
            return textDecode(charset, text);
        });
    }
    function rfc2231getParam(header) {
        const matches = [];
        let match;
        while ((match = FILENAME_START_ITER_REGEX.exec(header))) {
            const [, ns, quote, part] = match;
            const n = parseInt(ns, 10);
            if (n in matches) {
                if (n === 0) {
                    break;
                }
                continue;
            }
            matches[n] = [quote, part];
        }
        const parts = [];
        for (let n = 0; n < matches.length; ++n) {
            if (!(n in matches)) {
                break;
            }
            let [quote, part] = matches[n];
            part = headers_ts_1.unquote(part);
            if (quote) {
                part = unescape(part);
                if (n === 0) {
                    part = rfc5987decode(part);
                }
            }
            parts.push(part);
        }
        return parts.join("");
    }
    function rfc5987decode(value) {
        const encodingEnd = value.indexOf(`'`);
        if (encodingEnd === -1) {
            return value;
        }
        const encoding = value.slice(0, encodingEnd);
        const langValue = value.slice(encodingEnd + 1);
        return textDecode(encoding, langValue.replace(/^[^']*'/, ""));
    }
    function textDecode(encoding, value) {
        if (encoding) {
            try {
                const decoder = new TextDecoder(encoding, { fatal: true });
                const bytes = Array.from(value, (c) => c.charCodeAt(0));
                if (bytes.every((code) => code <= 0xFF)) {
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                }
            }
            catch { }
        }
        return value;
    }
    function getFilename(header) {
        needsEncodingFixup = true;
        let matches = FILENAME_STAR_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(rfc5987decode(unescape(headers_ts_1.unquote(filename)))));
        }
        const filename = rfc2231getParam(header);
        if (filename) {
            return fixupEncoding(rfc2047decode(filename));
        }
        matches = FILENAME_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(headers_ts_1.unquote(filename)));
        }
        return "";
    }
    exports_45("getFilename", getFilename);
    return {
        setters: [
            function (headers_ts_1_1) {
                headers_ts_1 = headers_ts_1_1;
            }
        ],
        execute: function () {
            needsEncodingFixup = false;
            FILENAME_STAR_REGEX = headers_ts_1.toParamRegExp("filename\\*", "i");
            FILENAME_START_ITER_REGEX = headers_ts_1.toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
            FILENAME_REGEX = headers_ts_1.toParamRegExp("filename", "i");
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/multipart", ["https://deno.land/x/oak@v6.3.1/buf_reader", "https://deno.land/x/oak@v6.3.1/content_disposition", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/headers", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/util"], function (exports_46, context_46) {
    "use strict";
    var buf_reader_ts_1, content_disposition_ts_1, deps_ts_8, headers_ts_2, httpError_ts_3, util_ts_2, decoder, encoder, BOUNDARY_PARAM_REGEX, DEFAULT_BUFFER_SIZE, DEFAULT_MAX_FILE_SIZE, DEFAULT_MAX_SIZE, NAME_PARAM_REGEX, FormDataReader;
    var __moduleName = context_46 && context_46.id;
    function append(a, b) {
        const ab = new Uint8Array(a.length + b.length);
        ab.set(a, 0);
        ab.set(b, a.length);
        return ab;
    }
    function isEqual(a, b) {
        return deps_ts_8.equal(util_ts_2.skipLWSPChar(a), b);
    }
    async function readToStartOrEnd(body, start, end) {
        let lineResult;
        while ((lineResult = await body.readLine())) {
            if (isEqual(lineResult.bytes, start)) {
                return true;
            }
            if (isEqual(lineResult.bytes, end)) {
                return false;
            }
        }
        throw new httpError_ts_3.httpErrors.BadRequest("Unable to find multi-part boundary.");
    }
    async function* parts({ body, final, part, maxFileSize, maxSize, outPath, prefix }) {
        async function getFile(contentType) {
            const ext = deps_ts_8.extension(contentType);
            if (!ext) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Invalid media type for part: ${ext}`);
            }
            if (!outPath) {
                outPath = await Deno.makeTempDir();
            }
            const filename = `${outPath}/${util_ts_2.getRandomFilename(prefix, ext)}`;
            const file = await Deno.open(filename, { write: true, createNew: true });
            return [filename, file];
        }
        while (true) {
            const headers = await headers_ts_2.readHeaders(body);
            const contentType = headers["content-type"];
            const contentDisposition = headers["content-disposition"];
            if (!contentDisposition) {
                throw new httpError_ts_3.httpErrors.BadRequest("Form data part missing content-disposition header");
            }
            if (!contentDisposition.match(/^form-data;/i)) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unexpected content-disposition header: "${contentDisposition}"`);
            }
            const matches = NAME_PARAM_REGEX.exec(contentDisposition);
            if (!matches) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unable to determine name of form body part`);
            }
            let [, name] = matches;
            name = headers_ts_2.unquote(name);
            if (contentType) {
                const originalName = content_disposition_ts_1.getFilename(contentDisposition);
                let byteLength = 0;
                let file;
                let filename;
                let buf;
                if (maxSize) {
                    buf = new Uint8Array();
                }
                else {
                    const result = await getFile(contentType);
                    filename = result[0];
                    file = result[1];
                }
                while (true) {
                    const readResult = await body.readLine(false);
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    let { bytes } = readResult;
                    const strippedBytes = util_ts_2.stripEol(bytes);
                    if (isEqual(strippedBytes, part) || isEqual(strippedBytes, final)) {
                        if (file) {
                            file.close();
                        }
                        yield [
                            name,
                            {
                                content: buf,
                                contentType,
                                name,
                                filename,
                                originalName,
                            },
                        ];
                        if (isEqual(strippedBytes, final)) {
                            return;
                        }
                        break;
                    }
                    byteLength += bytes.byteLength;
                    if (byteLength > maxFileSize) {
                        if (file) {
                            file.close();
                        }
                        throw new httpError_ts_3.httpErrors.RequestEntityTooLarge(`File size exceeds limit of ${maxFileSize} bytes.`);
                    }
                    if (buf) {
                        if (byteLength > maxSize) {
                            const result = await getFile(contentType);
                            filename = result[0];
                            file = result[1];
                            await Deno.writeAll(file, buf);
                            buf = undefined;
                        }
                        else {
                            buf = append(buf, bytes);
                        }
                    }
                    if (file) {
                        await Deno.writeAll(file, bytes);
                    }
                }
            }
            else {
                const lines = [];
                while (true) {
                    const readResult = await body.readLine();
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    const { bytes } = readResult;
                    if (isEqual(bytes, part) || isEqual(bytes, final)) {
                        yield [name, lines.join("\n")];
                        if (isEqual(bytes, final)) {
                            return;
                        }
                        break;
                    }
                    lines.push(decoder.decode(bytes));
                }
            }
        }
    }
    return {
        setters: [
            function (buf_reader_ts_1_1) {
                buf_reader_ts_1 = buf_reader_ts_1_1;
            },
            function (content_disposition_ts_1_1) {
                content_disposition_ts_1 = content_disposition_ts_1_1;
            },
            function (deps_ts_8_1) {
                deps_ts_8 = deps_ts_8_1;
            },
            function (headers_ts_2_1) {
                headers_ts_2 = headers_ts_2_1;
            },
            function (httpError_ts_3_1) {
                httpError_ts_3 = httpError_ts_3_1;
            },
            function (util_ts_2_1) {
                util_ts_2 = util_ts_2_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
            BOUNDARY_PARAM_REGEX = headers_ts_2.toParamRegExp("boundary", "i");
            DEFAULT_BUFFER_SIZE = 1048576;
            DEFAULT_MAX_FILE_SIZE = 10485760;
            DEFAULT_MAX_SIZE = 0;
            NAME_PARAM_REGEX = headers_ts_2.toParamRegExp("name", "i");
            FormDataReader = class FormDataReader {
                constructor(contentType, body) {
                    this.#reading = false;
                    const matches = contentType.match(BOUNDARY_PARAM_REGEX);
                    if (!matches) {
                        throw new httpError_ts_3.httpErrors.BadRequest(`Content type "${contentType}" does not contain a valid boundary.`);
                    }
                    let [, boundary] = matches;
                    boundary = headers_ts_2.unquote(boundary);
                    this.#boundaryPart = encoder.encode(`--${boundary}`);
                    this.#boundaryFinal = encoder.encode(`--${boundary}--`);
                    this.#body = body;
                }
                #body;
                #boundaryFinal;
                #boundaryPart;
                #reading;
                async read(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = DEFAULT_BUFFER_SIZE, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    const result = { fields: {} };
                    if (!(await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal))) {
                        return result;
                    }
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            const [key, value] = part;
                            if (typeof value === "string") {
                                result.fields[key] = value;
                            }
                            else {
                                if (!result.files) {
                                    result.files = [];
                                }
                                result.files.push(value);
                            }
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                    return result;
                }
                async *stream(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = 32000, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    if (!(await readToStartOrEnd(body, this.#boundaryPart, this.#boundaryFinal))) {
                        return;
                    }
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            yield part;
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                }
            };
            exports_46("FormDataReader", FormDataReader);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/body", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/isMediaType", "https://deno.land/x/oak@v6.3.1/multipart"], function (exports_47, context_47) {
    "use strict";
    var deps_ts_9, httpError_ts_4, isMediaType_ts_1, multipart_ts_1, defaultBodyContentTypes, decoder, RequestBody;
    var __moduleName = context_47 && context_47.id;
    return {
        setters: [
            function (deps_ts_9_1) {
                deps_ts_9 = deps_ts_9_1;
            },
            function (httpError_ts_4_1) {
                httpError_ts_4 = httpError_ts_4_1;
            },
            function (isMediaType_ts_1_1) {
                isMediaType_ts_1 = isMediaType_ts_1_1;
            },
            function (multipart_ts_1_1) {
                multipart_ts_1 = multipart_ts_1_1;
            }
        ],
        execute: function () {
            defaultBodyContentTypes = {
                json: ["json", "application/*+json", "application/csp-report"],
                form: ["urlencoded"],
                formData: ["multipart"],
                text: ["text"],
            };
            decoder = new TextDecoder();
            RequestBody = class RequestBody {
                constructor(request) {
                    this.#valuePromise = () => {
                        return this.#readAllBody ?? (this.#readAllBody = Deno.readAll(this.#body));
                    };
                    const { body, headers } = request;
                    this.#body = body;
                    this.#headers = headers;
                }
                #body;
                #formDataReader;
                #has;
                #headers;
                #readAllBody;
                #type;
                #valuePromise;
                get({ type, contentTypes }) {
                    if (type === "reader" && this.#type && this.#type !== "reader") {
                        throw new TypeError("Body already consumed and cannot be returned as a reader.");
                    }
                    if (type === "form-data" && this.#type && this.#type !== "form-data") {
                        throw new TypeError("Body already consumed and cannot be returned as form data.");
                    }
                    if (this.#type === "reader" && type !== "reader") {
                        throw new TypeError("Body already consumed as a reader and can only be returned as a reader.");
                    }
                    if (this.#type === "form-data" && type !== "form-data") {
                        throw new TypeError("Body already consumed as form data and can only be returned as form data.");
                    }
                    if (type && contentTypes) {
                        throw new TypeError(`"type" and "contentTypes" cannot be specified at the same time`);
                    }
                    if (type === "reader") {
                        this.#type = "reader";
                        return { type, value: this.#body };
                    }
                    if (!this.has()) {
                        this.#type = "undefined";
                    }
                    else if (!this.#type) {
                        const encoding = this.#headers.get("content-encoding") ?? "identity";
                        if (encoding !== "identity") {
                            throw new httpError_ts_4.httpErrors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
                        }
                    }
                    if (this.#type === "undefined") {
                        if (type) {
                            throw new TypeError(`Body is undefined and cannot be returned as "${type}".`);
                        }
                        return { type: "undefined", value: undefined };
                    }
                    if (!type) {
                        const contentType = this.#headers.get("content-type");
                        deps_ts_9.assert(contentType);
                        contentTypes = contentTypes ?? {};
                        const contentTypesJson = [
                            ...defaultBodyContentTypes.json,
                            ...(contentTypes.json ?? []),
                        ];
                        const contentTypesForm = [
                            ...defaultBodyContentTypes.form,
                            ...(contentTypes.form ?? []),
                        ];
                        const contentTypesFormData = [
                            ...defaultBodyContentTypes.formData,
                            ...(contentTypes.formData ?? []),
                        ];
                        const contentTypesText = [
                            ...defaultBodyContentTypes.text,
                            ...(contentTypes.text ?? []),
                        ];
                        if (contentTypes.raw && isMediaType_ts_1.isMediaType(contentType, contentTypes.raw)) {
                            type = "raw";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesJson)) {
                            type = "json";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesForm)) {
                            type = "form";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesFormData)) {
                            type = "form-data";
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesText)) {
                            type = "text";
                        }
                        else {
                            type = "raw";
                        }
                    }
                    deps_ts_9.assert(type);
                    let value;
                    switch (type) {
                        case "form":
                            this.#type = "raw";
                            value = async () => new URLSearchParams(decoder.decode(await this.#valuePromise()).replace(/\+/g, " "));
                            break;
                        case "form-data":
                            this.#type = "form-data";
                            value = () => {
                                const contentType = this.#headers.get("content-type");
                                deps_ts_9.assert(contentType);
                                return this.#formDataReader ??
                                    (this.#formDataReader = new multipart_ts_1.FormDataReader(contentType, this.#body));
                            };
                            break;
                        case "json":
                            this.#type = "raw";
                            value = async () => JSON.parse(decoder.decode(await this.#valuePromise()));
                            break;
                        case "raw":
                            this.#type = "raw";
                            value = () => this.#valuePromise();
                            break;
                        case "text":
                            this.#type = "raw";
                            value = async () => decoder.decode(await this.#valuePromise());
                            break;
                        default:
                            throw new TypeError(`Invalid body type: "${type}"`);
                    }
                    return {
                        type,
                        get value() {
                            return value();
                        },
                    };
                }
                has() {
                    return this.#has !== undefined
                        ? this.#has
                        : (this.#has = this.#headers.get("transfer-encoding") !== null ||
                            !!parseInt(this.#headers.get("content-length") ?? "", 10));
                }
            };
            exports_47("RequestBody", RequestBody);
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/common", [], function (exports_48, context_48) {
    "use strict";
    var __moduleName = context_48 && context_48.id;
    function compareSpecs(a, b) {
        return (b.q - a.q ||
            (b.s ?? 0) - (a.s ?? 0) ||
            (a.o ?? 0) - (b.o ?? 0) ||
            a.i - b.i ||
            0);
    }
    exports_48("compareSpecs", compareSpecs);
    function isQuality(spec) {
        return spec.q > 0;
    }
    exports_48("isQuality", isQuality);
    return {
        setters: [],
        execute: function () {
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/charset", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_49, context_49) {
    "use strict";
    var common_ts_2, SIMPLE_CHARSET_REGEXP;
    var __moduleName = context_49 && context_49.id;
    function parseCharset(str, i) {
        const match = SIMPLE_CHARSET_REGEXP.exec(str);
        if (!match) {
            return;
        }
        const [, charset] = match;
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { charset, q, i };
    }
    function parseAcceptCharset(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const charset = parseCharset(accepts[i].trim(), i);
            if (charset) {
                result.push(charset);
            }
        }
        return result;
    }
    function specify(charset, spec, i) {
        let s = 0;
        if (spec.charset.toLowerCase() === charset.toLocaleLowerCase()) {
            s |= 1;
        }
        else if (spec.charset !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getCharsetPriority(charset, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(charset, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredCharsets(accept = "*", provided) {
        const accepts = parseAcceptCharset(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_2.isQuality)
                .sort(common_ts_2.compareSpecs)
                .map((spec) => spec.charset);
        }
        const priorities = provided
            .map((type, index) => getCharsetPriority(type, accepts, index));
        return priorities
            .filter(common_ts_2.isQuality)
            .sort(common_ts_2.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_49("preferredCharsets", preferredCharsets);
    return {
        setters: [
            function (common_ts_2_1) {
                common_ts_2 = common_ts_2_1;
            }
        ],
        execute: function () {
            SIMPLE_CHARSET_REGEXP = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/encoding", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_50, context_50) {
    "use strict";
    var common_ts_3, simpleEncodingRegExp;
    var __moduleName = context_50 && context_50.id;
    function parseEncoding(str, i) {
        const match = simpleEncodingRegExp.exec(str);
        if (!match) {
            return undefined;
        }
        const encoding = match[1];
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const p = param.trim().split("=");
                if (p[0] === "q") {
                    q = parseFloat(p[1]);
                    break;
                }
            }
        }
        return { encoding, q, i };
    }
    function specify(encoding, spec, i = -1) {
        if (!spec.encoding) {
            return;
        }
        let s = 0;
        if (spec.encoding.toLocaleLowerCase() === encoding.toLocaleLowerCase()) {
            s = 1;
        }
        else if (spec.encoding !== "*") {
            return;
        }
        return {
            i,
            o: spec.i,
            q: spec.q,
            s,
        };
    }
    function parseAcceptEncoding(accept) {
        const accepts = accept.split(",");
        const parsedAccepts = [];
        let hasIdentity = false;
        let minQuality = 1;
        for (let i = 0; i < accepts.length; i++) {
            const encoding = parseEncoding(accepts[i].trim(), i);
            if (encoding) {
                parsedAccepts.push(encoding);
                hasIdentity = hasIdentity || !!specify("identity", encoding);
                minQuality = Math.min(minQuality, encoding.q || 1);
            }
        }
        if (!hasIdentity) {
            parsedAccepts.push({
                encoding: "identity",
                q: minQuality,
                i: accepts.length - 1,
            });
        }
        return parsedAccepts;
    }
    function getEncodingPriority(encoding, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: 0 };
        for (const s of accepted) {
            const spec = specify(encoding, s, index);
            if (spec &&
                (priority.s - spec.s || priority.q - spec.q ||
                    priority.o - spec.o) <
                    0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredEncodings(accept, provided) {
        const accepts = parseAcceptEncoding(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_3.isQuality)
                .sort(common_ts_3.compareSpecs)
                .map((spec) => spec.encoding);
        }
        const priorities = provided.map((type, index) => getEncodingPriority(type, accepts, index));
        return priorities
            .filter(common_ts_3.isQuality)
            .sort(common_ts_3.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_50("preferredEncodings", preferredEncodings);
    return {
        setters: [
            function (common_ts_3_1) {
                common_ts_3 = common_ts_3_1;
            }
        ],
        execute: function () {
            simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/language", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_51, context_51) {
    "use strict";
    var common_ts_4, SIMPLE_LANGUAGE_REGEXP;
    var __moduleName = context_51 && context_51.id;
    function parseLanguage(str, i) {
        const match = SIMPLE_LANGUAGE_REGEXP.exec(str);
        if (!match) {
            return undefined;
        }
        const [, prefix, suffix] = match;
        const full = suffix ? `${prefix}-${suffix}` : prefix;
        let q = 1;
        if (match[3]) {
            const params = match[3].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { prefix, suffix, full, q, i };
    }
    function parseAcceptLanguage(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const language = parseLanguage(accepts[i].trim(), i);
            if (language) {
                result.push(language);
            }
        }
        return result;
    }
    function specify(language, spec, i) {
        const p = parseLanguage(language, i);
        if (!p) {
            return undefined;
        }
        let s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
            s |= 4;
        }
        else if (spec.prefix.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 2;
        }
        else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 1;
        }
        else if (spec.full !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getLanguagePriority(language, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(language, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredLanguages(accept = "*", provided) {
        const accepts = parseAcceptLanguage(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_4.isQuality)
                .sort(common_ts_4.compareSpecs)
                .map((spec) => spec.full);
        }
        const priorities = provided
            .map((type, index) => getLanguagePriority(type, accepts, index));
        return priorities
            .filter(common_ts_4.isQuality)
            .sort(common_ts_4.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_51("preferredLanguages", preferredLanguages);
    return {
        setters: [
            function (common_ts_4_1) {
                common_ts_4 = common_ts_4_1;
            }
        ],
        execute: function () {
            SIMPLE_LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/oak@v6.3.1/negotiation/mediaType", ["https://deno.land/x/oak@v6.3.1/negotiation/common"], function (exports_52, context_52) {
    "use strict";
    var common_ts_5, simpleMediaTypeRegExp;
    var __moduleName = context_52 && context_52.id;
    function quoteCount(str) {
        let count = 0;
        let index = 0;
        while ((index = str.indexOf(`"`, index)) !== -1) {
            count++;
            index++;
        }
        return count;
    }
    function splitMediaTypes(accept) {
        const accepts = accept.split(",");
        let j = 0;
        for (let i = 1; i < accepts.length; i++) {
            if (quoteCount(accepts[j]) % 2 === 0) {
                accepts[++j] = accepts[i];
            }
            else {
                accepts[j] += `,${accepts[i]}`;
            }
        }
        accepts.length = j + 1;
        return accepts;
    }
    function splitParameters(str) {
        const parameters = str.split(";");
        let j = 0;
        for (let i = 1; i < parameters.length; i++) {
            if (quoteCount(parameters[j]) % 2 === 0) {
                parameters[++j] = parameters[i];
            }
            else {
                parameters[j] += `;${parameters[i]}`;
            }
        }
        parameters.length = j + 1;
        return parameters.map((p) => p.trim());
    }
    function splitKeyValuePair(str) {
        const [key, value] = str.split("=");
        return [key.toLowerCase(), value];
    }
    function parseMediaType(str, i) {
        const match = simpleMediaTypeRegExp.exec(str);
        if (!match) {
            return;
        }
        const params = Object.create(null);
        let q = 1;
        const [, type, subtype, parameters] = match;
        if (parameters) {
            const kvps = splitParameters(parameters).map(splitKeyValuePair);
            for (const [key, val] of kvps) {
                const value = val && val[0] === `"` && val[val.length - 1] === `"`
                    ? val.substr(1, val.length - 2)
                    : val;
                if (key === "q" && value) {
                    q = parseFloat(value);
                    break;
                }
                params[key] = value;
            }
        }
        return { type, subtype, params, q, i };
    }
    function parseAccept(accept) {
        const accepts = splitMediaTypes(accept);
        const mediaTypes = [];
        for (let i = 0; i < accepts.length; i++) {
            const mediaType = parseMediaType(accepts[i].trim(), i);
            if (mediaType) {
                mediaTypes.push(mediaType);
            }
        }
        return mediaTypes;
    }
    function getFullType(spec) {
        return `${spec.type}/${spec.subtype}`;
    }
    function specify(type, spec, index) {
        const p = parseMediaType(type, index);
        if (!p) {
            return;
        }
        let s = 0;
        if (spec.type.toLowerCase() === p.type.toLowerCase()) {
            s |= 4;
        }
        else if (spec.type !== "*") {
            return;
        }
        if (spec.subtype.toLowerCase() === p.subtype.toLowerCase()) {
            s |= 2;
        }
        else if (spec.subtype !== "*") {
            return;
        }
        const keys = Object.keys(spec.params);
        if (keys.length) {
            if (keys.every((key) => (spec.params[key] || "").toLowerCase() ===
                (p.params[key] || "").toLowerCase())) {
                s |= 1;
            }
            else {
                return;
            }
        }
        return {
            i: index,
            o: spec.o,
            q: spec.q,
            s,
        };
    }
    function getMediaTypePriority(type, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: index };
        for (const accepts of accepted) {
            const spec = specify(type, accepts, index);
            if (spec &&
                ((priority.s || 0) - (spec.s || 0) ||
                    (priority.q || 0) - (spec.q || 0) ||
                    (priority.o || 0) - (spec.o || 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredMediaTypes(accept, provided) {
        const accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
        if (!provided) {
            return accepts
                .filter(common_ts_5.isQuality)
                .sort(common_ts_5.compareSpecs)
                .map(getFullType);
        }
        const priorities = provided.map((type, index) => {
            return getMediaTypePriority(type, accepts, index);
        });
        return priorities
            .filter(common_ts_5.isQuality)
            .sort(common_ts_5.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_52("preferredMediaTypes", preferredMediaTypes);
    return {
        setters: [
            function (common_ts_5_1) {
                common_ts_5 = common_ts_5_1;
            }
        ],
        execute: function () {
            simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/request", ["https://deno.land/x/oak@v6.3.1/body", "https://deno.land/x/oak@v6.3.1/negotiation/charset", "https://deno.land/x/oak@v6.3.1/negotiation/encoding", "https://deno.land/x/oak@v6.3.1/negotiation/language", "https://deno.land/x/oak@v6.3.1/negotiation/mediaType"], function (exports_53, context_53) {
    "use strict";
    var body_ts_1, charset_ts_1, encoding_ts_1, language_ts_1, mediaType_ts_1, decoder, Request;
    var __moduleName = context_53 && context_53.id;
    return {
        setters: [
            function (body_ts_1_1) {
                body_ts_1 = body_ts_1_1;
            },
            function (charset_ts_1_1) {
                charset_ts_1 = charset_ts_1_1;
            },
            function (encoding_ts_1_1) {
                encoding_ts_1 = encoding_ts_1_1;
            },
            function (language_ts_1_1) {
                language_ts_1 = language_ts_1_1;
            },
            function (mediaType_ts_1_1) {
                mediaType_ts_1 = mediaType_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            Request = class Request {
                constructor(serverRequest, proxy = false, secure = false) {
                    this.#proxy = proxy;
                    this.#secure = secure;
                    this.#serverRequest = serverRequest;
                    this.#body = new body_ts_1.RequestBody(serverRequest);
                }
                #body;
                #proxy;
                #secure;
                #serverRequest;
                #url;
                get hasBody() {
                    return this.#body.has();
                }
                get headers() {
                    return this.#serverRequest.headers;
                }
                get ip() {
                    return this.#proxy
                        ? this.ips[0]
                        : this.#serverRequest.conn.remoteAddr.hostname;
                }
                get ips() {
                    return this.#proxy
                        ? (this.#serverRequest.headers.get("x-forwarded-for") ??
                            this.#serverRequest.conn.remoteAddr.hostname).split(/\s*,\s*/)
                        : [];
                }
                get method() {
                    return this.#serverRequest.method;
                }
                get secure() {
                    return this.#secure;
                }
                get serverRequest() {
                    return this.#serverRequest;
                }
                get url() {
                    if (!this.#url) {
                        const serverRequest = this.#serverRequest;
                        let proto;
                        let host;
                        if (this.#proxy) {
                            proto = serverRequest
                                .headers.get("x-forwarded-proto")?.split(/\s*,\s*/, 1)[0] ??
                                "http";
                            host = serverRequest.headers.get("x-forwarded-host") ??
                                serverRequest.headers.get("host") ?? "";
                        }
                        else {
                            proto = this.#secure ? "https" : "http";
                            host = serverRequest.headers.get("host") ?? "";
                        }
                        this.#url = new URL(`${proto}://${host}${serverRequest.url}`);
                    }
                    return this.#url;
                }
                accepts(...types) {
                    const acceptValue = this.#serverRequest.headers.get("Accept");
                    if (!acceptValue) {
                        return;
                    }
                    if (types.length) {
                        return mediaType_ts_1.preferredMediaTypes(acceptValue, types)[0];
                    }
                    return mediaType_ts_1.preferredMediaTypes(acceptValue);
                }
                acceptsCharsets(...charsets) {
                    const acceptCharsetValue = this.#serverRequest.headers.get("Accept-Charset");
                    if (!acceptCharsetValue) {
                        return;
                    }
                    if (charsets.length) {
                        return charset_ts_1.preferredCharsets(acceptCharsetValue, charsets)[0];
                    }
                    return charset_ts_1.preferredCharsets(acceptCharsetValue);
                }
                acceptsEncodings(...encodings) {
                    const acceptEncodingValue = this.#serverRequest.headers.get("Accept-Encoding");
                    if (!acceptEncodingValue) {
                        return;
                    }
                    if (encodings.length) {
                        return encoding_ts_1.preferredEncodings(acceptEncodingValue, encodings)[0];
                    }
                    return encoding_ts_1.preferredEncodings(acceptEncodingValue);
                }
                acceptsLanguages(...langs) {
                    const acceptLanguageValue = this.#serverRequest.headers.get("Accept-Language");
                    if (!acceptLanguageValue) {
                        return;
                    }
                    if (langs.length) {
                        return language_ts_1.preferredLanguages(acceptLanguageValue, langs)[0];
                    }
                    return language_ts_1.preferredLanguages(acceptLanguageValue);
                }
                body(options = {}) {
                    return this.#body.get(options);
                }
            };
            exports_53("Request", Request);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/response", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/util"], function (exports_54, context_54) {
    "use strict";
    var deps_ts_10, util_ts_3, REDIRECT_BACK, BODY_TYPES, encoder, Response;
    var __moduleName = context_54 && context_54.id;
    function isReader(value) {
        return value && typeof value === "object" && "read" in value &&
            typeof value.read === "function";
    }
    async function convertBody(body, type) {
        let result;
        if (BODY_TYPES.includes(typeof body)) {
            const bodyText = String(body);
            result = encoder.encode(bodyText);
            type = type ?? (util_ts_3.isHtml(bodyText) ? "html" : "text/plain");
        }
        else if (body instanceof Uint8Array || isReader(body)) {
            result = body;
        }
        else if (body && typeof body === "object") {
            result = encoder.encode(JSON.stringify(body));
            type = type ?? "json";
        }
        else if (typeof body === "function") {
            const result = body.call(null);
            return convertBody(await result, type);
        }
        else if (body) {
            throw new TypeError("Response body was set but could not convert.");
        }
        return [result, type];
    }
    return {
        setters: [
            function (deps_ts_10_1) {
                deps_ts_10 = deps_ts_10_1;
            },
            function (util_ts_3_1) {
                util_ts_3 = util_ts_3_1;
            }
        ],
        execute: function () {
            exports_54("REDIRECT_BACK", REDIRECT_BACK = Symbol("redirect backwards"));
            BODY_TYPES = ["string", "number", "bigint", "boolean", "symbol"];
            encoder = new TextEncoder();
            Response = class Response {
                constructor(request) {
                    this.#headers = new Headers();
                    this.#resources = [];
                    this.#writable = true;
                    this.#getBody = async () => {
                        const [body, type] = await convertBody(this.body, this.type);
                        this.type = type;
                        return body;
                    };
                    this.#setContentType = () => {
                        if (this.type) {
                            const contentTypeString = deps_ts_10.contentType(this.type);
                            if (contentTypeString && !this.headers.has("Content-Type")) {
                                this.headers.append("Content-Type", contentTypeString);
                            }
                        }
                    };
                    this.#request = request;
                }
                #body;
                #headers;
                #request;
                #resources;
                #serverResponse;
                #status;
                #type;
                #writable;
                #getBody;
                #setContentType;
                get body() {
                    return this.#body;
                }
                set body(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#body = value;
                }
                get headers() {
                    return this.#headers;
                }
                set headers(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#headers = value;
                }
                get status() {
                    if (this.#status) {
                        return this.#status;
                    }
                    const typeofbody = typeof this.body;
                    return this.body &&
                        (BODY_TYPES.includes(typeofbody) || typeofbody === "object")
                        ? deps_ts_10.Status.OK
                        : deps_ts_10.Status.NotFound;
                }
                set status(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#status = value;
                }
                get type() {
                    return this.#type;
                }
                set type(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#type = value;
                }
                get writable() {
                    return this.#writable;
                }
                addResource(rid) {
                    this.#resources.push(rid);
                }
                destroy() {
                    this.#writable = false;
                    this.#body = undefined;
                    this.#serverResponse = undefined;
                    for (const rid of this.#resources) {
                        Deno.close(rid);
                    }
                }
                redirect(url, alt = "/") {
                    if (url === REDIRECT_BACK) {
                        url = this.#request.headers.get("Referrer") ?? String(alt);
                    }
                    else if (typeof url === "object") {
                        url = String(url);
                    }
                    this.headers.set("Location", util_ts_3.encodeUrl(url));
                    if (!this.status || !util_ts_3.isRedirectStatus(this.status)) {
                        this.status = deps_ts_10.Status.Found;
                    }
                    if (this.#request.accepts("html")) {
                        url = encodeURI(url);
                        this.type = "text/html; charset=utf-8";
                        this.body = `Redirecting to <a href="${url}">${url}</a>.`;
                        return;
                    }
                    this.type = "text/plain; charset=utf-8";
                    this.body = `Redirecting to ${url}.`;
                }
                async toServerResponse() {
                    if (this.#serverResponse) {
                        return this.#serverResponse;
                    }
                    const body = await this.#getBody();
                    this.#setContentType();
                    const { headers } = this;
                    if (!(body ||
                        headers.has("Content-Type") ||
                        headers.has("Content-Length"))) {
                        headers.append("Content-Length", "0");
                    }
                    this.#writable = false;
                    return this.#serverResponse = {
                        status: this.#status ?? (body ? deps_ts_10.Status.OK : deps_ts_10.Status.NotFound),
                        body,
                        headers,
                    };
                }
            };
            exports_54("Response", Response);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/cookies", [], function (exports_55, context_55) {
    "use strict";
    var matchCache, FIELD_CONTENT_REGEXP, KEY_REGEXP, SAME_SITE_REGEXP, Cookie, Cookies;
    var __moduleName = context_55 && context_55.id;
    function getPattern(name) {
        if (name in matchCache) {
            return matchCache[name];
        }
        return matchCache[name] = new RegExp(`(?:^|;) *${name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}=([^;]*)`);
    }
    function pushCookie(headers, cookie) {
        if (cookie.overwrite) {
            for (let i = headers.length - 1; i >= 0; i--) {
                if (headers[i].indexOf(`${cookie.name}=`) === 0) {
                    headers.splice(i, 1);
                }
            }
        }
        headers.push(cookie.toHeader());
    }
    function validateCookieProperty(key, value) {
        if (value && !FIELD_CONTENT_REGEXP.test(value)) {
            throw new TypeError(`The ${key} of the cookie (${value}) is invalid.`);
        }
    }
    return {
        setters: [],
        execute: function () {
            matchCache = {};
            FIELD_CONTENT_REGEXP = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
            KEY_REGEXP = /(?:^|;) *([^=]*)=[^;]*/g;
            SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
            Cookie = class Cookie {
                constructor(name, value, attributes) {
                    this.httpOnly = true;
                    this.overwrite = false;
                    this.path = "/";
                    this.sameSite = false;
                    this.secure = false;
                    validateCookieProperty("name", name);
                    validateCookieProperty("value", value);
                    this.name = name;
                    this.value = value ?? "";
                    Object.assign(this, attributes);
                    if (!this.value) {
                        this.expires = new Date(0);
                        this.maxAge = undefined;
                    }
                    validateCookieProperty("path", this.path);
                    validateCookieProperty("domain", this.domain);
                    if (this.sameSite && typeof this.sameSite === "string" &&
                        !SAME_SITE_REGEXP.test(this.sameSite)) {
                        throw new TypeError(`The sameSite of the cookie ("${this.sameSite}") is invalid.`);
                    }
                }
                toHeader() {
                    let header = this.toString();
                    if (this.maxAge) {
                        this.expires = new Date(Date.now() + (this.maxAge * 1000));
                    }
                    if (this.path) {
                        header += `; path=${this.path}`;
                    }
                    if (this.expires) {
                        header += `; expires=${this.expires.toUTCString()}`;
                    }
                    if (this.domain) {
                        header += `; domain=${this.domain}`;
                    }
                    if (this.sameSite) {
                        header += `; samesite=${this.sameSite === true ? "strict" : this.sameSite.toLowerCase()}`;
                    }
                    if (this.secure) {
                        header += "; secure";
                    }
                    if (this.httpOnly) {
                        header += "; httponly";
                    }
                    return header;
                }
                toString() {
                    return `${this.name}=${this.value}`;
                }
            };
            Cookies = class Cookies {
                constructor(request, response, options = {}) {
                    this.#requestKeys = () => {
                        if (this.#cookieKeys) {
                            return this.#cookieKeys;
                        }
                        const result = this.#cookieKeys = [];
                        const header = this.#request.headers.get("cookie");
                        if (!header) {
                            return result;
                        }
                        let matches;
                        while ((matches = KEY_REGEXP.exec(header))) {
                            const [, key] = matches;
                            result.push(key);
                        }
                        return result;
                    };
                    const { keys, secure } = options;
                    this.#keys = keys;
                    this.#request = request;
                    this.#response = response;
                    this.#secure = secure;
                }
                #cookieKeys;
                #keys;
                #request;
                #response;
                #secure;
                #requestKeys;
                delete(name, options = {}) {
                    this.set(name, null, options);
                    return true;
                }
                *entries() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
                forEach(callback, thisArg = null) {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            callback.call(thisArg, key, value, this);
                        }
                    }
                }
                get(name, options = {}) {
                    const signed = options.signed ?? !!this.#keys;
                    const nameSig = `${name}.sig`;
                    const header = this.#request.headers.get("cookie");
                    if (!header) {
                        return;
                    }
                    const match = header.match(getPattern(name));
                    if (!match) {
                        return;
                    }
                    const [, value] = match;
                    if (!signed) {
                        return value;
                    }
                    const digest = this.get(nameSig, { signed: false });
                    if (!digest) {
                        return;
                    }
                    const data = `${name}=${value}`;
                    if (!this.#keys) {
                        throw new TypeError("keys required for signed cookies");
                    }
                    const index = this.#keys.indexOf(data, digest);
                    if (index < 0) {
                        this.delete(nameSig, { path: "/", signed: false });
                    }
                    else {
                        if (index) {
                            this.set(nameSig, this.#keys.sign(data), { signed: false });
                        }
                        return value;
                    }
                }
                *keys() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield key;
                        }
                    }
                }
                set(name, value, options = {}) {
                    const request = this.#request;
                    const response = this.#response;
                    let headers = response.headers.get("Set-Cookie") ?? [];
                    if (typeof headers === "string") {
                        headers = [headers];
                    }
                    const secure = this.#secure !== undefined ? this.#secure : request.secure;
                    const signed = options.signed ?? !!this.#keys;
                    if (!secure && options.secure) {
                        throw new TypeError("Cannot send secure cookie over unencrypted connection.");
                    }
                    const cookie = new Cookie(name, value, options);
                    cookie.secure = options.secure ?? secure;
                    pushCookie(headers, cookie);
                    if (signed) {
                        if (!this.#keys) {
                            throw new TypeError(".keys required for signed cookies.");
                        }
                        cookie.value = this.#keys.sign(cookie.toString());
                        cookie.name += ".sig";
                        pushCookie(headers, cookie);
                    }
                    for (const header of headers) {
                        response.headers.append("Set-Cookie", header);
                    }
                    return this;
                }
                *values() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield value;
                        }
                    }
                }
                *[Symbol.iterator]() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
            };
            exports_55("Cookies", Cookies);
        }
    };
});
/*!
 * Adapted from koa-send at https://github.com/koajs/send and which is licensed
 * with the MIT license.
 */
System.register("https://deno.land/x/oak@v6.3.1/send", ["https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/util"], function (exports_56, context_56) {
    "use strict";
    var httpError_ts_5, deps_ts_11, util_ts_4;
    var __moduleName = context_56 && context_56.id;
    function isHidden(path) {
        const pathArr = path.split("/");
        for (const segment of pathArr) {
            if (segment[0] === "." && segment !== "." && segment !== "..") {
                return true;
            }
            return false;
        }
    }
    async function exists(path) {
        try {
            return (await Deno.stat(path)).isFile;
        }
        catch {
            return false;
        }
    }
    async function send({ request, response }, path, options = { root: "" }) {
        const { brotli = true, extensions, format = true, gzip = true, hidden = false, immutable = false, index, maxage = 0, root, } = options;
        const trailingSlash = path[path.length - 1] === "/";
        path = util_ts_4.decodeComponent(path.substr(deps_ts_11.parse(path).root.length));
        if (index && trailingSlash) {
            path += index;
        }
        if (!hidden && isHidden(path)) {
            throw httpError_ts_5.createHttpError(403);
        }
        path = util_ts_4.resolvePath(root, path);
        let encodingExt = "";
        if (brotli &&
            request.acceptsEncodings("br", "identity") === "br" &&
            (await exists(`${path}.br`))) {
            path = `${path}.br`;
            response.headers.set("Content-Encoding", "br");
            response.headers.delete("Content-Length");
            encodingExt = ".br";
        }
        else if (gzip &&
            request.acceptsEncodings("gzip", "identity") === "gzip" &&
            (await exists(`${path}.gz`))) {
            path = `${path}.gz`;
            response.headers.set("Content-Encoding", "gzip");
            response.headers.delete("Content-Length");
            encodingExt = ".gz";
        }
        if (extensions && !/\.[^/]*$/.exec(path)) {
            for (let ext of extensions) {
                if (!/^\./.exec(ext)) {
                    ext = `.${ext}`;
                }
                if (await exists(`${path}${ext}`)) {
                    path += ext;
                    break;
                }
            }
        }
        let stats;
        try {
            stats = await Deno.stat(path);
            if (stats.isDirectory) {
                if (format && index) {
                    path += `/${index}`;
                    stats = await Deno.stat(path);
                }
                else {
                    return;
                }
            }
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                throw httpError_ts_5.createHttpError(404, err.message);
            }
            throw httpError_ts_5.createHttpError(500, err.message);
        }
        response.headers.set("Content-Length", String(stats.size));
        if (!response.headers.has("Last-Modified") && stats.mtime) {
            response.headers.set("Last-Modified", stats.mtime.toUTCString());
        }
        if (!response.headers.has("Cache-Control")) {
            const directives = [`max-age=${(maxage / 1000) | 0}`];
            if (immutable) {
                directives.push("immutable");
            }
            response.headers.set("Cache-Control", directives.join(","));
        }
        if (!response.type) {
            response.type = encodingExt !== ""
                ? deps_ts_11.extname(deps_ts_11.basename(path, encodingExt))
                : deps_ts_11.extname(path);
        }
        const file = await Deno.open(path, { read: true });
        response.addResource(file.rid);
        response.body = file;
        return path;
    }
    exports_56("send", send);
    return {
        setters: [
            function (httpError_ts_5_1) {
                httpError_ts_5 = httpError_ts_5_1;
            },
            function (deps_ts_11_1) {
                deps_ts_11 = deps_ts_11_1;
            },
            function (util_ts_4_1) {
                util_ts_4 = util_ts_4_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/server_sent_event", ["https://deno.land/x/oak@v6.3.1/deps"], function (exports_57, context_57) {
    "use strict";
    var deps_ts_12, encoder, CloseEvent, ServerSentEvent, response, responseHeaders, ServerSentEventTarget;
    var __moduleName = context_57 && context_57.id;
    return {
        setters: [
            function (deps_ts_12_1) {
                deps_ts_12 = deps_ts_12_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            CloseEvent = class CloseEvent extends Event {
                constructor(eventInit) {
                    super("close", eventInit);
                }
            };
            ServerSentEvent = class ServerSentEvent extends Event {
                constructor(type, data, { replacer, space, ...eventInit } = {}) {
                    super(type, eventInit);
                    this.#type = type;
                    try {
                        this.#data = typeof data === "string"
                            ? data
                            : JSON.stringify(data, replacer, space);
                    }
                    catch (e) {
                        deps_ts_12.assert(e instanceof Error);
                        throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
                    }
                    const { id } = eventInit;
                    this.#id = id;
                }
                #data;
                #id;
                #type;
                get data() {
                    return this.#data;
                }
                get id() {
                    return this.#id;
                }
                toString() {
                    const data = `data: ${this.#data.split("\n").join("\ndata: ")}\n`;
                    return `${this.#type === "__message" ? "" : `event: ${this.#type}\n`}${this.#id ? `id: ${String(this.#id)}\n` : ""}${data}\n`;
                }
            };
            exports_57("ServerSentEvent", ServerSentEvent);
            response = `HTTP/1.1 200 OK\n`;
            responseHeaders = new Headers([
                ["Connection", "Keep-Alive"],
                ["Content-Type", "text/event-stream"],
                ["Cache-Control", "no-cache"],
                ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
            ]);
            ServerSentEventTarget = class ServerSentEventTarget extends EventTarget {
                constructor(app, serverRequest, { headers } = {}) {
                    super();
                    this.#closed = false;
                    this.#prev = Promise.resolve();
                    this.#send = async (payload, prev) => {
                        if (this.#closed) {
                            return;
                        }
                        if (this.#ready !== true) {
                            await this.#ready;
                            this.#ready = true;
                        }
                        try {
                            await prev;
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                        }
                    };
                    this.#setup = async (overrideHeaders) => {
                        const headers = new Headers(responseHeaders);
                        if (overrideHeaders) {
                            for (const [key, value] of overrideHeaders) {
                                headers.set(key, value);
                            }
                        }
                        let payload = response;
                        for (const [key, value] of headers) {
                            payload += `${key}: ${value}\n`;
                        }
                        payload += `\n`;
                        try {
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                            throw error;
                        }
                    };
                    this.#app = app;
                    this.#serverRequest = serverRequest;
                    this.#writer = this.#serverRequest.w;
                    this.addEventListener("close", () => {
                        this.#closed = true;
                        try {
                            this.#serverRequest.conn.close();
                        }
                        catch (error) {
                            if (!(error instanceof Deno.errors.BadResource)) {
                                const errorEvent = new ErrorEvent("error", { error });
                                this.dispatchEvent(errorEvent);
                                this.#app.dispatchEvent(errorEvent);
                            }
                        }
                    });
                    this.#ready = this.#setup(headers);
                }
                #app;
                #closed;
                #prev;
                #ready;
                #serverRequest;
                #writer;
                #send;
                #setup;
                get closed() {
                    return this.#closed;
                }
                async close() {
                    if (this.#ready !== true) {
                        await this.#ready;
                    }
                    await this.#prev;
                    this.dispatchEvent(new CloseEvent({ cancelable: false }));
                }
                dispatchComment(comment) {
                    this.#prev = this.#send(`: ${comment.split("\n").join("\n: ")}\n\n`, this.#prev);
                    return true;
                }
                dispatchMessage(data) {
                    const event = new ServerSentEvent("__message", data);
                    return this.dispatchEvent(event);
                }
                dispatchEvent(event) {
                    let dispatched = super.dispatchEvent(event);
                    if (dispatched && event instanceof ServerSentEvent) {
                        this.#prev = this.#send(String(event), this.#prev);
                    }
                    return dispatched;
                }
            };
            exports_57("ServerSentEventTarget", ServerSentEventTarget);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/context", ["https://deno.land/x/oak@v6.3.1/cookies", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/request", "https://deno.land/x/oak@v6.3.1/response", "https://deno.land/x/oak@v6.3.1/send", "https://deno.land/x/oak@v6.3.1/server_sent_event"], function (exports_58, context_58) {
    "use strict";
    var cookies_ts_1, deps_ts_13, httpError_ts_6, request_ts_1, response_ts_1, send_ts_1, server_sent_event_ts_1, Context;
    var __moduleName = context_58 && context_58.id;
    return {
        setters: [
            function (cookies_ts_1_1) {
                cookies_ts_1 = cookies_ts_1_1;
            },
            function (deps_ts_13_1) {
                deps_ts_13 = deps_ts_13_1;
            },
            function (httpError_ts_6_1) {
                httpError_ts_6 = httpError_ts_6_1;
            },
            function (request_ts_1_1) {
                request_ts_1 = request_ts_1_1;
            },
            function (response_ts_1_1) {
                response_ts_1 = response_ts_1_1;
            },
            function (send_ts_1_1) {
                send_ts_1 = send_ts_1_1;
            },
            function (server_sent_event_ts_1_1) {
                server_sent_event_ts_1 = server_sent_event_ts_1_1;
            }
        ],
        execute: function () {
            Context = class Context {
                constructor(app, serverRequest, secure = false) {
                    this.app = app;
                    this.state = app.state;
                    this.request = new request_ts_1.Request(serverRequest, app.proxy, secure);
                    this.respond = true;
                    this.response = new response_ts_1.Response(this.request);
                    this.cookies = new cookies_ts_1.Cookies(this.request, this.response, {
                        keys: this.app.keys,
                        secure: this.request.secure,
                    });
                }
                #socket;
                #sse;
                get isUpgradable() {
                    return deps_ts_13.acceptable(this.request);
                }
                get socket() {
                    return this.#socket;
                }
                assert(condition, errorStatus = 500, message, props) {
                    if (condition) {
                        return;
                    }
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                send(options) {
                    const { path = this.request.url.pathname, ...sendOptions } = options;
                    return send_ts_1.send(this, path, sendOptions);
                }
                sendEvents(options) {
                    if (this.#sse) {
                        return this.#sse;
                    }
                    this.respond = false;
                    return this.#sse = new server_sent_event_ts_1.ServerSentEventTarget(this.app, this.request.serverRequest, options);
                }
                throw(errorStatus, message, props) {
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                async upgrade() {
                    if (this.#socket) {
                        return this.#socket;
                    }
                    const { conn, r: bufReader, w: bufWriter, headers } = this.request.serverRequest;
                    this.#socket = await deps_ts_13.acceptWebSocket({ conn, bufReader, bufWriter, headers });
                    this.respond = false;
                    return this.#socket;
                }
            };
            exports_58("Context", Context);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/middleware", [], function (exports_59, context_59) {
    "use strict";
    var __moduleName = context_59 && context_59.id;
    function compose(middleware) {
        return function composedMiddleware(context, next) {
            let index = -1;
            async function dispatch(i) {
                if (i <= index) {
                    throw new Error("next() called multiple times.");
                }
                index = i;
                let fn = middleware[i];
                if (i === middleware.length) {
                    fn = next;
                }
                if (!fn) {
                    return;
                }
                await fn(context, dispatch.bind(null, i + 1));
            }
            return dispatch(0);
        };
    }
    exports_59("compose", compose);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/application", ["https://deno.land/x/oak@v6.3.1/context", "https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/keyStack", "https://deno.land/x/oak@v6.3.1/middleware"], function (exports_60, context_60) {
    "use strict";
    var context_ts_1, deps_ts_14, keyStack_ts_1, middleware_ts_1, ADDR_REGEXP, ApplicationErrorEvent, ApplicationListenEvent, Application;
    var __moduleName = context_60 && context_60.id;
    function isOptionsTls(options) {
        return options.secure === true;
    }
    return {
        setters: [
            function (context_ts_1_1) {
                context_ts_1 = context_ts_1_1;
            },
            function (deps_ts_14_1) {
                deps_ts_14 = deps_ts_14_1;
            },
            function (keyStack_ts_1_1) {
                keyStack_ts_1 = keyStack_ts_1_1;
            },
            function (middleware_ts_1_1) {
                middleware_ts_1 = middleware_ts_1_1;
            }
        ],
        execute: function () {
            ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
            ApplicationErrorEvent = class ApplicationErrorEvent extends ErrorEvent {
                constructor(eventInitDict) {
                    super("error", eventInitDict);
                    this.context = eventInitDict.context;
                }
            };
            exports_60("ApplicationErrorEvent", ApplicationErrorEvent);
            ApplicationListenEvent = class ApplicationListenEvent extends Event {
                constructor(eventInitDict) {
                    super("listen", eventInitDict);
                    this.hostname = eventInitDict.hostname;
                    this.port = eventInitDict.port;
                    this.secure = eventInitDict.secure;
                }
            };
            exports_60("ApplicationListenEvent", ApplicationListenEvent);
            Application = class Application extends EventTarget {
                constructor(options = {}) {
                    super();
                    this.#middleware = [];
                    this.#getComposed = () => {
                        if (!this.#composedMiddleware) {
                            this.#composedMiddleware = middleware_ts_1.compose(this.#middleware);
                        }
                        return this.#composedMiddleware;
                    };
                    this.#handleError = (context, error) => {
                        if (!(error instanceof Error)) {
                            error = new Error(`non-error thrown: ${JSON.stringify(error)}`);
                        }
                        const { message } = error;
                        this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
                        if (!context.response.writable) {
                            return;
                        }
                        for (const key of context.response.headers.keys()) {
                            context.response.headers.delete(key);
                        }
                        if (error.headers && error.headers instanceof Headers) {
                            for (const [key, value] of error.headers) {
                                context.response.headers.set(key, value);
                            }
                        }
                        context.response.type = "text";
                        const status = context.response.status =
                            error instanceof Deno.errors.NotFound
                                ? 404
                                : error.status && typeof error.status === "number"
                                    ? error.status
                                    : 500;
                        context.response.body = error.expose
                            ? error.message
                            : deps_ts_14.STATUS_TEXT.get(status);
                    };
                    this.#handleRequest = async (request, secure, state) => {
                        const context = new context_ts_1.Context(this, request, secure);
                        let resolve;
                        const handlingPromise = new Promise((res) => resolve = res);
                        state.handling.add(handlingPromise);
                        if (!state.closing && !state.closed) {
                            try {
                                await this.#getComposed()(context);
                            }
                            catch (err) {
                                this.#handleError(context, err);
                            }
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            resolve();
                            state.handling.delete(handlingPromise);
                            return;
                        }
                        try {
                            await request.respond(await context.response.toServerResponse());
                            if (state.closing) {
                                state.server.close();
                                state.closed = true;
                            }
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                        finally {
                            context.response.destroy();
                            resolve();
                            state.handling.delete(handlingPromise);
                        }
                    };
                    this.handle = async (request, secure = false) => {
                        if (!this.#middleware.length) {
                            throw new TypeError("There is no middleware to process requests.");
                        }
                        const context = new context_ts_1.Context(this, request, secure);
                        try {
                            await this.#getComposed()(context);
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            return;
                        }
                        try {
                            const response = await context.response.toServerResponse();
                            context.response.destroy();
                            return response;
                        }
                        catch (err) {
                            this.#handleError(context, err);
                            throw err;
                        }
                    };
                    const { state, keys, proxy, serve = deps_ts_14.serve, serveTls = deps_ts_14.serveTLS, } = options;
                    this.proxy = proxy ?? false;
                    this.keys = keys;
                    this.state = state ?? {};
                    this.#serve = serve;
                    this.#serveTls = serveTls;
                }
                #composedMiddleware;
                #keys;
                #middleware;
                #serve;
                #serveTls;
                get keys() {
                    return this.#keys;
                }
                set keys(keys) {
                    if (!keys) {
                        this.#keys = undefined;
                        return;
                    }
                    else if (Array.isArray(keys)) {
                        this.#keys = new keyStack_ts_1.KeyStack(keys);
                    }
                    else {
                        this.#keys = keys;
                    }
                }
                #getComposed;
                #handleError;
                #handleRequest;
                addEventListener(type, listener, options) {
                    super.addEventListener(type, listener, options);
                }
                async listen(options) {
                    if (!this.#middleware.length) {
                        throw new TypeError("There is no middleware to process requests.");
                    }
                    if (typeof options === "string") {
                        const match = ADDR_REGEXP.exec(options);
                        if (!match) {
                            throw TypeError(`Invalid address passed: "${options}"`);
                        }
                        const [, hostname, portStr] = match;
                        options = { hostname, port: parseInt(portStr, 10) };
                    }
                    const server = isOptionsTls(options)
                        ? this.#serveTls(options)
                        : this.#serve(options);
                    const { signal } = options;
                    const state = {
                        closed: false,
                        closing: false,
                        handling: new Set(),
                        server,
                    };
                    if (signal) {
                        signal.addEventListener("abort", () => {
                            if (!state.handling.size) {
                                server.close();
                                state.closed = true;
                            }
                            state.closing = true;
                        });
                    }
                    const { hostname, port, secure = false } = options;
                    this.dispatchEvent(new ApplicationListenEvent({ hostname, port, secure }));
                    try {
                        for await (const request of server) {
                            this.#handleRequest(request, secure, state);
                        }
                        await Promise.all(state.handling);
                    }
                    catch (error) {
                        const message = error instanceof Error
                            ? error.message
                            : "Application Error";
                        this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
                    }
                }
                use(...middleware) {
                    this.#middleware.push(...middleware);
                    this.#composedMiddleware = undefined;
                    return this;
                }
            };
            exports_60("Application", Application);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/router", ["https://deno.land/x/oak@v6.3.1/deps", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/middleware", "https://deno.land/x/oak@v6.3.1/util"], function (exports_61, context_61) {
    "use strict";
    var deps_ts_15, httpError_ts_7, middleware_ts_2, util_ts_5, Layer, Router;
    var __moduleName = context_61 && context_61.id;
    function toUrl(url, params = {}, options) {
        const tokens = deps_ts_15.pathParse(url);
        let replace = {};
        if (tokens.some((token) => typeof token === "object")) {
            replace = params;
        }
        else {
            options = params;
        }
        const toPath = deps_ts_15.compile(url, options);
        let replaced = toPath(replace);
        if (options && options.query) {
            const url = new URL(replaced, "http://oak");
            if (typeof options.query === "string") {
                url.search = options.query;
            }
            else {
                url.search = String(options.query instanceof URLSearchParams
                    ? options.query
                    : new URLSearchParams(options.query));
            }
            return `${url.pathname}${url.search}${url.hash}`;
        }
        return replaced;
    }
    return {
        setters: [
            function (deps_ts_15_1) {
                deps_ts_15 = deps_ts_15_1;
            },
            function (httpError_ts_7_1) {
                httpError_ts_7 = httpError_ts_7_1;
            },
            function (middleware_ts_2_1) {
                middleware_ts_2 = middleware_ts_2_1;
            },
            function (util_ts_5_1) {
                util_ts_5 = util_ts_5_1;
            }
        ],
        execute: function () {
            Layer = class Layer {
                constructor(path, methods, middleware, { name, ...opts } = {}) {
                    this.#paramNames = [];
                    this.#opts = opts;
                    this.name = name;
                    this.methods = [...methods];
                    if (this.methods.includes("GET")) {
                        this.methods.unshift("HEAD");
                    }
                    this.stack = Array.isArray(middleware) ? middleware : [middleware];
                    this.path = path;
                    this.#regexp = deps_ts_15.pathToRegexp(path, this.#paramNames, this.#opts);
                }
                #opts;
                #paramNames;
                #regexp;
                match(path) {
                    return this.#regexp.test(path);
                }
                params(captures, existingParams = {}) {
                    const params = existingParams;
                    for (let i = 0; i < captures.length; i++) {
                        if (this.#paramNames[i]) {
                            const c = captures[i];
                            params[this.#paramNames[i].name] = c ? util_ts_5.decodeComponent(c) : c;
                        }
                    }
                    return params;
                }
                captures(path) {
                    if (this.#opts.ignoreCaptures) {
                        return [];
                    }
                    return path.match(this.#regexp)?.slice(1) ?? [];
                }
                url(params = {}, options) {
                    const url = this.path.replace(/\(\.\*\)/g, "");
                    return toUrl(url, params, options);
                }
                param(param, fn) {
                    const stack = this.stack;
                    const params = this.#paramNames;
                    const middleware = function (ctx, next) {
                        const p = ctx.params[param];
                        deps_ts_15.assert(p);
                        return fn.call(this, p, ctx, next);
                    };
                    middleware.param = param;
                    const names = params.map((p) => p.name);
                    const x = names.indexOf(param);
                    if (x >= 0) {
                        for (let i = 0; i < stack.length; i++) {
                            const fn = stack[i];
                            if (!fn.param || names.indexOf(fn.param) > x) {
                                stack.splice(i, 0, middleware);
                                break;
                            }
                        }
                    }
                    return this;
                }
                setPrefix(prefix) {
                    if (this.path) {
                        this.path = this.path !== "/" || this.#opts.strict === true
                            ? `${prefix}${this.path}`
                            : prefix;
                        this.#paramNames = [];
                        this.#regexp = deps_ts_15.pathToRegexp(this.path, this.#paramNames, this.#opts);
                    }
                    return this;
                }
                toJSON() {
                    return {
                        methods: [...this.methods],
                        middleware: [...this.stack],
                        paramNames: this.#paramNames.map((key) => key.name),
                        path: this.path,
                        regexp: this.#regexp,
                        options: { ...this.#opts },
                    };
                }
            };
            Router = class Router {
                constructor(opts = {}) {
                    this.#params = {};
                    this.#stack = [];
                    this.#match = (path, method) => {
                        const matches = {
                            path: [],
                            pathAndMethod: [],
                            route: false,
                        };
                        for (const route of this.#stack) {
                            if (route.match(path)) {
                                matches.path.push(route);
                                if (route.methods.length === 0 || route.methods.includes(method)) {
                                    matches.pathAndMethod.push(route);
                                    if (route.methods.length) {
                                        matches.route = true;
                                    }
                                }
                            }
                        }
                        return matches;
                    };
                    this.#register = (path, middleware, methods, options = {}) => {
                        if (Array.isArray(path)) {
                            for (const p of path) {
                                this.#register(p, middleware, methods, options);
                            }
                            return;
                        }
                        const { end, name, sensitive, strict, ignoreCaptures } = options;
                        const route = new Layer(path, methods, middleware, {
                            end: end === false ? end : true,
                            name,
                            sensitive: sensitive ?? this.#opts.sensitive ?? false,
                            strict: strict ?? this.#opts.strict ?? false,
                            ignoreCaptures,
                        });
                        if (this.#opts.prefix) {
                            route.setPrefix(this.#opts.prefix);
                        }
                        for (const [param, mw] of Object.entries(this.#params)) {
                            route.param(param, mw);
                        }
                        this.#stack.push(route);
                    };
                    this.#route = (name) => {
                        for (const route of this.#stack) {
                            if (route.name === name) {
                                return route;
                            }
                        }
                    };
                    this.#useVerb = (nameOrPath, pathOrMiddleware, middleware, methods) => {
                        let name = undefined;
                        let path;
                        if (typeof pathOrMiddleware === "string") {
                            name = nameOrPath;
                            path = pathOrMiddleware;
                        }
                        else {
                            path = nameOrPath;
                            middleware.unshift(pathOrMiddleware);
                        }
                        this.#register(path, middleware, methods, { name });
                    };
                    this.#opts = opts;
                    this.#methods = opts.methods ?? [
                        "DELETE",
                        "GET",
                        "HEAD",
                        "OPTIONS",
                        "PATCH",
                        "POST",
                        "PUT",
                    ];
                }
                #opts;
                #methods;
                #params;
                #stack;
                #match;
                #register;
                #route;
                #useVerb;
                all(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE", "GET", "POST", "PUT"]);
                    return this;
                }
                allowedMethods(options = {}) {
                    const implemented = this.#methods;
                    const allowedMethods = async (context, next) => {
                        const ctx = context;
                        await next();
                        if (!ctx.response.status || ctx.response.status === deps_ts_15.Status.NotFound) {
                            deps_ts_15.assert(ctx.matched);
                            const allowed = new Set();
                            for (const route of ctx.matched) {
                                for (const method of route.methods) {
                                    allowed.add(method);
                                }
                            }
                            const allowedStr = [...allowed].join(", ");
                            if (!implemented.includes(ctx.request.method)) {
                                if (options.throw) {
                                    throw options.notImplemented
                                        ? options.notImplemented()
                                        : new httpError_ts_7.httpErrors.NotImplemented();
                                }
                                else {
                                    ctx.response.status = deps_ts_15.Status.NotImplemented;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                            }
                            else if (allowed.size) {
                                if (ctx.request.method === "OPTIONS") {
                                    ctx.response.status = deps_ts_15.Status.OK;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                                else if (!allowed.has(ctx.request.method)) {
                                    if (options.throw) {
                                        throw options.methodNotAllowed
                                            ? options.methodNotAllowed()
                                            : new httpError_ts_7.httpErrors.MethodNotAllowed();
                                    }
                                    else {
                                        ctx.response.status = deps_ts_15.Status.MethodNotAllowed;
                                        ctx.response.headers.set("Allowed", allowedStr);
                                    }
                                }
                            }
                        }
                    };
                    return allowedMethods;
                }
                delete(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE"]);
                    return this;
                }
                *entries() {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        yield [value, value];
                    }
                }
                forEach(callback, thisArg = null) {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        callback.call(thisArg, value, value, this);
                    }
                }
                get(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["GET"]);
                    return this;
                }
                head(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["HEAD"]);
                    return this;
                }
                *keys() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                options(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["OPTIONS"]);
                    return this;
                }
                param(param, middleware) {
                    this.#params[param] = middleware;
                    for (const route of this.#stack) {
                        route.param(param, middleware);
                    }
                    return this;
                }
                patch(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PATCH"]);
                    return this;
                }
                post(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["POST"]);
                    return this;
                }
                prefix(prefix) {
                    prefix = prefix.replace(/\/$/, "");
                    this.#opts.prefix = prefix;
                    for (const route of this.#stack) {
                        route.setPrefix(prefix);
                    }
                    return this;
                }
                put(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PUT"]);
                    return this;
                }
                redirect(source, destination, status = deps_ts_15.Status.Found) {
                    if (source[0] !== "/") {
                        const s = this.url(source);
                        if (!s) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        source = s;
                    }
                    if (destination[0] !== "/") {
                        const d = this.url(destination);
                        if (!d) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        destination = d;
                    }
                    this.all(source, (ctx) => {
                        ctx.response.redirect(destination);
                        ctx.response.status = status;
                    });
                    return this;
                }
                routes() {
                    const dispatch = (context, next) => {
                        const ctx = context;
                        const { url: { pathname }, method } = ctx.request;
                        const path = this.#opts.routerPath ?? ctx.routerPath ??
                            decodeURIComponent(pathname);
                        const matches = this.#match(path, method);
                        if (ctx.matched) {
                            ctx.matched.push(...matches.path);
                        }
                        else {
                            ctx.matched = [...matches.path];
                        }
                        ctx.router = this;
                        if (!matches.route)
                            return next();
                        const { pathAndMethod: matchedRoutes } = matches;
                        const chain = matchedRoutes.reduce((prev, route) => [
                            ...prev,
                            (ctx, next) => {
                                ctx.captures = route.captures(path);
                                ctx.params = route.params(ctx.captures, ctx.params);
                                ctx.routeName = route.name;
                                return next();
                            },
                            ...route.stack,
                        ], []);
                        return middleware_ts_2.compose(chain)(ctx, next);
                    };
                    dispatch.router = this;
                    return dispatch;
                }
                url(name, params, options) {
                    const route = this.#route(name);
                    if (route) {
                        return route.url(params, options);
                    }
                }
                use(pathOrMiddleware, ...middleware) {
                    let path;
                    if (typeof pathOrMiddleware === "string" || Array.isArray(pathOrMiddleware)) {
                        path = pathOrMiddleware;
                    }
                    else {
                        middleware.unshift(pathOrMiddleware);
                    }
                    this.#register(path ?? "(.*)", middleware, [], { end: false, ignoreCaptures: !path });
                    return this;
                }
                *values() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                *[Symbol.iterator]() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                static url(path, params, options) {
                    return toUrl(path, params, options);
                }
            };
            exports_61("Router", Router);
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/helpers", [], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    function isRouterContext(value) {
        return "params" in value;
    }
    function getQuery(ctx, { mergeParams, asMap } = {}) {
        const result = {};
        if (mergeParams && isRouterContext(ctx)) {
            Object.assign(result, ctx.params);
        }
        for (const [key, value] of ctx.request.url.searchParams) {
            result[key] = value;
        }
        return asMap ? new Map(Object.entries(result)) : result;
    }
    exports_62("getQuery", getQuery);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/oak@v6.3.1/mod", ["https://deno.land/x/oak@v6.3.1/application", "https://deno.land/x/oak@v6.3.1/context", "https://deno.land/x/oak@v6.3.1/helpers", "https://deno.land/x/oak@v6.3.1/cookies", "https://deno.land/x/oak@v6.3.1/httpError", "https://deno.land/x/oak@v6.3.1/middleware", "https://deno.land/x/oak@v6.3.1/multipart", "https://deno.land/x/oak@v6.3.1/request", "https://deno.land/x/oak@v6.3.1/response", "https://deno.land/x/oak@v6.3.1/router", "https://deno.land/x/oak@v6.3.1/send", "https://deno.land/x/oak@v6.3.1/server_sent_event", "https://deno.land/x/oak@v6.3.1/util", "https://deno.land/x/oak@v6.3.1/deps"], function (exports_63, context_63) {
    "use strict";
    var __moduleName = context_63 && context_63.id;
    return {
        setters: [
            function (application_ts_1_1) {
                exports_63({
                    "Application": application_ts_1_1["Application"]
                });
            },
            function (context_ts_2_1) {
                exports_63({
                    "Context": context_ts_2_1["Context"]
                });
            },
            function (helpers_1) {
                exports_63("helpers", helpers_1);
            },
            function (cookies_ts_2_1) {
                exports_63({
                    "Cookies": cookies_ts_2_1["Cookies"]
                });
            },
            function (httpError_ts_8_1) {
                exports_63({
                    "HttpError": httpError_ts_8_1["HttpError"],
                    "httpErrors": httpError_ts_8_1["httpErrors"],
                    "isHttpError": httpError_ts_8_1["isHttpError"]
                });
            },
            function (middleware_ts_3_1) {
                exports_63({
                    "composeMiddleware": middleware_ts_3_1["compose"]
                });
            },
            function (multipart_ts_2_1) {
                exports_63({
                    "FormDataReader": multipart_ts_2_1["FormDataReader"]
                });
            },
            function (request_ts_2_1) {
                exports_63({
                    "Request": request_ts_2_1["Request"]
                });
            },
            function (response_ts_2_1) {
                exports_63({
                    "REDIRECT_BACK": response_ts_2_1["REDIRECT_BACK"],
                    "Response": response_ts_2_1["Response"]
                });
            },
            function (router_ts_1_1) {
                exports_63({
                    "Router": router_ts_1_1["Router"]
                });
            },
            function (send_ts_2_1) {
                exports_63({
                    "send": send_ts_2_1["send"]
                });
            },
            function (server_sent_event_ts_2_1) {
                exports_63({
                    "ServerSentEvent": server_sent_event_ts_2_1["ServerSentEvent"],
                    "ServerSentEventTarget": server_sent_event_ts_2_1["ServerSentEventTarget"]
                });
            },
            function (util_ts_6_1) {
                exports_63({
                    "isErrorStatus": util_ts_6_1["isErrorStatus"],
                    "isRedirectStatus": util_ts_6_1["isRedirectStatus"]
                });
            },
            function (deps_ts_16_1) {
                exports_63({
                    "Status": deps_ts_16_1["Status"],
                    "STATUS_TEXT": deps_ts_16_1["STATUS_TEXT"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/controllers/HomeController", [], function (exports_64, context_64) {
    "use strict";
    var getHome;
    var __moduleName = context_64 && context_64.id;
    return {
        setters: [],
        execute: function () {
            getHome = ({ response }) => {
                response.body = "<html><body>Hello deno</body></html>";
            };
            exports_64("getHome", getHome);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/routes/HomeRoute", ["https://deno.land/x/oak@v6.3.1/mod", "file:///home/ak/dev/backend/deno_api/practice/controllers/HomeController"], function (exports_65, context_65) {
    "use strict";
    var mod_ts_13, HomeController_ts_1, homeRouter;
    var __moduleName = context_65 && context_65.id;
    return {
        setters: [
            function (mod_ts_13_1) {
                mod_ts_13 = mod_ts_13_1;
            },
            function (HomeController_ts_1_1) {
                HomeController_ts_1 = HomeController_ts_1_1;
            }
        ],
        execute: function () {
            homeRouter = new mod_ts_13.Router();
            homeRouter.get("/", HomeController_ts_1.getHome);
            exports_65("default", homeRouter);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/controllers/NotFoundController", [], function (exports_66, context_66) {
    "use strict";
    var __moduleName = context_66 && context_66.id;
    return {
        setters: [],
        execute: function () {
            exports_66("default", ({ response }) => {
                response.status = 404;
                response.body = { err: "Service not found" };
            });
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/model/Customer", [], function (exports_67, context_67) {
    "use strict";
    var __moduleName = context_67 && context_67.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.69.0/bytes/mod", [], function (exports_68, context_68) {
    "use strict";
    var __moduleName = context_68 && context_68.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_68("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_68("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_68("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_68("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_68("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_68("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_68("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_68("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_68("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.69.0/_util/assert", [], function (exports_69, context_69) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_69 && context_69.id;
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_69("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_69("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
System.register("https://deno.land/std@0.69.0/io/bufio", ["https://deno.land/std@0.69.0/bytes/mod", "https://deno.land/std@0.69.0/_util/assert"], function (exports_70, context_70) {
    "use strict";
    var mod_ts_14, assert_ts_7, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_70 && context_70.id;
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    async function* readDelim(reader, delim) {
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_70("readDelim", readDelim);
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_70("readStringDelim", readStringDelim);
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_70("readLines", readLines);
    return {
        setters: [
            function (mod_ts_14_1) {
                mod_ts_14 = mod_ts_14_1;
            },
            function (assert_ts_7_1) {
                assert_ts_7 = assert_ts_7_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_70("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_70("PartialReadError", PartialReadError);
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0;
                    this.w = 0;
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                async _fill() {
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_7.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                }
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_7.assert(nread >= 0, "negative read");
                            return rr;
                        }
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_7.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    const copied = mod_ts_14.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    return copied;
                }
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill();
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    return c;
                }
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_7.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            assert_ts_7.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                async readSlice(delim) {
                    let s = 0;
                    let slice;
                    while (true) {
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r;
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_70("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                size() {
                    return this.buf.byteLength;
                }
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                buffered() {
                    return this.usedBufferBytes;
                }
            };
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        await Deno.writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_70("BufWriter", BufWriter);
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    try {
                        Deno.writeAllSync(this.writer, this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.buf = new Uint8Array(this.buf.length);
                    this.usedBufferBytes = 0;
                }
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = mod_ts_14.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_70("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.67.0/bytes/mod", [], function (exports_71, context_71) {
    "use strict";
    var __moduleName = context_71 && context_71.id;
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_71("findIndex", findIndex);
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_71("findLastIndex", findLastIndex);
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_71("equal", equal);
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_71("hasPrefix", hasPrefix);
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_71("hasSuffix", hasSuffix);
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_71("repeat", repeat);
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_71("concat", concat);
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_71("contains", contains);
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_71("copyBytes", copyBytes);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.69.0/async/deferred", [], function (exports_72, context_72) {
    "use strict";
    var __moduleName = context_72 && context_72.id;
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_72("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/encoding/base64", [], function (exports_73, context_73) {
    "use strict";
    var __moduleName = context_73 && context_73.id;
    function encode(data) {
        if (typeof data === "string") {
            return btoa(data);
        }
        else {
            const d = new Uint8Array(data);
            let dataString = "";
            for (let i = 0; i < d.length; ++i) {
                dataString += String.fromCharCode(d[i]);
            }
            return btoa(dataString);
        }
    }
    exports_73("encode", encode);
    function decode(data) {
        const binaryString = decodeString(data);
        const binary = new Uint8Array(binaryString.length);
        for (let i = 0; i < binary.length; ++i) {
            binary[i] = binaryString.charCodeAt(i);
        }
        return binary.buffer;
    }
    exports_73("decode", decode);
    function decodeString(data) {
        return atob(data);
    }
    exports_73("decodeString", decodeString);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/hash/_wasm/wasm", ["https://deno.land/std@0.67.0/encoding/base64"], function (exports_74, context_74) {
    "use strict";
    var base64, source, wasm, cachedTextDecoder, cachegetUint8Memory0, heap, heap_next, WASM_VECTOR_LEN, cachedTextEncoder, encodeString, cachegetInt32Memory0, DenoHash;
    var __moduleName = context_74 && context_74.id;
    function getUint8Memory0() {
        if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
            cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        }
        return cachegetUint8Memory0;
    }
    function getStringFromWasm0(ptr, len) {
        return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
    }
    function addHeapObject(obj) {
        if (heap_next === heap.length)
            heap.push(heap.length + 1);
        const idx = heap_next;
        heap_next = heap[idx];
        heap[idx] = obj;
        return idx;
    }
    function getObject(idx) { return heap[idx]; }
    function dropObject(idx) {
        if (idx < 36)
            return;
        heap[idx] = heap_next;
        heap_next = idx;
    }
    function takeObject(idx) {
        const ret = getObject(idx);
        dropObject(idx);
        return ret;
    }
    function passStringToWasm0(arg, malloc, realloc) {
        if (realloc === undefined) {
            const buf = cachedTextEncoder.encode(arg);
            const ptr = malloc(buf.length);
            getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
            WASM_VECTOR_LEN = buf.length;
            return ptr;
        }
        let len = arg.length;
        let ptr = malloc(len);
        const mem = getUint8Memory0();
        let offset = 0;
        for (; offset < len; offset++) {
            const code = arg.charCodeAt(offset);
            if (code > 0x7F)
                break;
            mem[ptr + offset] = code;
        }
        if (offset !== len) {
            if (offset !== 0) {
                arg = arg.slice(offset);
            }
            ptr = realloc(ptr, len, len = offset + arg.length * 3);
            const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
            const ret = encodeString(arg, view);
            offset += ret.written;
        }
        WASM_VECTOR_LEN = offset;
        return ptr;
    }
    function create_hash(algorithm) {
        var ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.create_hash(ptr0, len0);
        return DenoHash.__wrap(ret);
    }
    exports_74("create_hash", create_hash);
    function _assertClass(instance, klass) {
        if (!(instance instanceof klass)) {
            throw new Error(`expected instance of ${klass.name}`);
        }
        return instance.ptr;
    }
    function passArray8ToWasm0(arg, malloc) {
        const ptr = malloc(arg.length * 1);
        getUint8Memory0().set(arg, ptr / 1);
        WASM_VECTOR_LEN = arg.length;
        return ptr;
    }
    function update_hash(hash, data) {
        _assertClass(hash, DenoHash);
        var ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.update_hash(hash.ptr, ptr0, len0);
    }
    exports_74("update_hash", update_hash);
    function getInt32Memory0() {
        if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
            cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
        }
        return cachegetInt32Memory0;
    }
    function getArrayU8FromWasm0(ptr, len) {
        return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
    }
    function digest_hash(hash) {
        _assertClass(hash, DenoHash);
        wasm.digest_hash(8, hash.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        var v0 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v0;
    }
    exports_74("digest_hash", digest_hash);
    async function load(module, imports) {
        if (typeof Response === 'function' && module instanceof Response) {
            if (typeof WebAssembly.instantiateStreaming === 'function') {
                try {
                    return await WebAssembly.instantiateStreaming(module, imports);
                }
                catch (e) {
                    if (module.headers.get('Content-Type') != 'application/wasm') {
                        console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
                    }
                    else {
                        throw e;
                    }
                }
            }
            const bytes = await module.arrayBuffer();
            return await WebAssembly.instantiate(bytes, imports);
        }
        else {
            const instance = await WebAssembly.instantiate(module, imports);
            if (instance instanceof WebAssembly.Instance) {
                return { instance, module };
            }
            else {
                return instance;
            }
        }
    }
    async function init(input) {
        if (typeof input === 'undefined') {
            input = context_74.meta.url.replace(/\.js$/, '_bg.wasm');
        }
        const imports = {};
        imports.wbg = {};
        imports.wbg.__wbindgen_string_new = function (arg0, arg1) {
            var ret = getStringFromWasm0(arg0, arg1);
            return addHeapObject(ret);
        };
        imports.wbg.__wbindgen_throw = function (arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        };
        imports.wbg.__wbindgen_rethrow = function (arg0) {
            throw takeObject(arg0);
        };
        if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
            input = fetch(input);
        }
        const { instance, module } = await load(await input, imports);
        wasm = instance.exports;
        init.__wbindgen_wasm_module = module;
        return wasm;
    }
    return {
        setters: [
            function (base64_1) {
                base64 = base64_1;
            }
        ],
        execute: function () {
            exports_74("source", source = base64.decode("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gAEQfSIBIAEpAwAiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AwAgASABKQMIIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwMIIAEgASkDECIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDECABIAEpAxgiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AxggASABKQMgIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwMgIAEgASkDKCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDKCABIAEpAzAiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AzAgASABKQM4IgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwM4IAEgASkDQCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAH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NwIAIANBJGogBSkDADcCACADQSxqIAspAwA3AgAgA0E0aiAKKQMANwIAIANBPGogCSkDADcCACADQcQAaiAIKQMANwIAIANBzABqIAcpAwA3AgBBhIDAACEEQQAhBQwNCyACQYIEakIANwEAIAJBigRqQQA7AQAgAkGMBGpCADcCACACQZQEakIANwIAIAJBnARqQgA3AgAgAkGkBGpCADcCACACQawEakIANwIAIAJBtARqQQA6AAAgAkG1BGpBADYAACACQbkEakEAOwAAIAJBuwRqQQA6AAAgAkHAADYC+AMgAkEAOwH8AyACQQA2Af4DIAJBmAFqIAJB+ANqQcQAEH0aIAJBmANqIgQgAkHUAWopAgA3AwAgAkGQA2oiBSACQcwBaikCADcDACACQYgDaiIGIAJBxAFqKQIANwMAIAJBgANqIgcgAkG8AWopAgA3AwAgAkH4AmoiCCACQbQBaikCADcDACACQfACaiIJIAJBrAFqKQIANwMAIAJB6AJqIgogAkGkAWopAgA3AwAgAiACKQKcATcD4AJB4ABBCBCYASIDRQ0TIANBADYCCCADQgA3AwAgAyACKQPgAjcCDCADQRRqIAopAwA3AgAgA0EcaiAJKQMANwIAIANBJGogCCkDADcCACADQSxqIAcpAwA3AgAgA0E0aiAGKQMANwIAIANBPGogBSkDADcCACADQcQAaiAEKQMANwIAIANB1ABqQeCXwAApAwA3AgAgA0HYl8AAKQMANwJMQayAwAAhBEEAIQUMDAsgAkGYAWpBAEHEABCCAUHgAEEIEJgBIgNFDRIgA0IANwMAIANBkJjAACkDADcDCCADQRBqQZiYwAApAwA3AwAgA0EYakGgmMAAKAIANgIAIANBHGogAkGYAWpBxAAQfRpBhIHAACEEDAsLIAJBmAFqQQBBxAAQggFB+ABBCBCYASIDRQ0MIANCADcDACADQeiXwAApAwA3AwggA0EQakHwl8AAKQMANwMAIANBGGpB+JfAACkDADcDACADQSBqQYCYwAApAwA3AwAgA0EoakGImMAAKQMANwMAIANBMGogAkGYAWpBxAAQfRpBtIHAACEEDAoLIAJBmAFqQQBBzAAQggEgAkH8AWpBvJjAACkCADcCACACQfQBakG0mMAAKQIANwIAIAJB7AFqQayYwAApAgA3AgAgAkGkmMAAKQIANwLkAUHwAEEIEJgBIgNFDREgAyACQZgBakHwABB9GkGIgsAAIQQMCQsgAkGYAWpBAEHMABCCASACQfwBakHcmMAAKQIANwIAIAJB9AFqQdSYwAApAgA3AgAgAkHsAWpBzJjAACkCADcCACACQcSYwAApAgA3AuQBQfAAQQgQmAEiA0UNECADIAJBmAFqQfAAEH0aQbSCwAAhBAwICyACQZgBakEAQYABEIIBIAJBgARqQgA3AwAgAkGQBGpB8JjAACkDADcDACACQZgEakH4mMAAKQMANwMAIAJBoARqQYCZwAApAwA3AwAgAkGoBGpBiJnAACkDADcDACACQbAEakGQmcAAKQMANwMAIAJBuARqQZiZwAApAwA3AwAgAkHABGpBoJnAACkDADcDACACQgA3A/gDIAJB6JjAACkDADcDiAQgAkHgAmogAkH4A2pB0AAQfRpB2AFBCBCYASIDRQ0QIAMgAkHgAmpB0AAQfSIEQQA2AlAgBEHUAGogAkGYAWpBgAEQfRpB4ILAACEEDAcLIAJBmAFqQQBByAEQggEgAkEANgLgAkEEIQMDQCACQeACaiADakEAOgAAIAIgAigC4AJBAWo2AuACIANBAWoiA0GUAUcNAAsgAkH4A2ogAkHgAmpBlAEQfRogAkEIaiACQfgDakEEckGQARB9GkHgAkEIEJgBIgNFDRAgAyACQZgBakHIARB9IgRBADYCyAEgBEHMAWogAkEIakGQARB9GkG4g8AAIQQMBgsgAkGYAWpBAEHIARCCASACQQA2AuACQQQhAwNAIAJB4AJqIANqQQA6AAAgAiACKALgAkEBajYC4AIgA0EBaiIDQYwBRw0ACyACQfgDaiACQeACakGMARB9GiACQQhqIAJB+ANqQQRyQYgBEH0aQdgCQQgQmAEiA0UNECADIAJBmAFqQcgBEH0iBEEANgLIASAEQcwBaiACQQhqQYgBEH0aQeSDwAAhBAwFCyACQZgBakEAQcgBEIIBIAJBADYC4AJBBCEDA0AgAkHgAmogA2pBADoAACACIAIoAuACQQFqNgLgAiADQQFqIgNB7ABHDQALIAJB+ANqIAJB4AJqQewAEH0aIAJBCGogAkH4A2pBBHJB6AAQfRpBuAJBCBCYASIDRQ0QIAMgAkGYAWpByAEQfSIEQQA2AsgBIARBzAFqIAJBCGpB6AAQfRpBkITAACEEDAQLIAJBmAFqQQBByAEQggEgAkEANgLgAkEEIQMDQCACQeACaiADakEAOgAAIAIgAigC4AJBAWo2AuACIANBAWoiA0GUAUcNAAsgAkH4A2ogAkHgAmpBlAEQfRogAkEIaiACQfgDakEEckGQARB9GkHgAkEIEJgBIgNFDQ0gAyACQZgBakHIARB9IgRBADYCyAEgBEHMAWogAkEIakGQARB9GkHshMAAIQQMAwsgAkGYAWpBAEHIARCCASACQQA2AuACQQQhAwNAIAJB4AJqIANqQQA6AAAgAiACKALgAkEBajYC4AIgA0EBaiIDQYwBRw0ACyACQfgDaiACQeACakGMARB9GiACQQhqIAJB+ANqQQRyQYgBEH0aQdgCQQgQmAEiA0UNDSADIAJBmAFqQcgBEH0iBEEANgLIASAEQcwBaiACQQhqQYgBEH0aQZyFwAAhBAwCCyACQZgBakEAQcgBEIIBIAJBADYC4AJBBCEDA0AgAkHgAmogA2pBADoAACACIAIoAuACQQFqNgLgAiADQQFqIgNB7ABHDQALIAJB+ANqIAJB4AJqQewAEH0aIAJBCGogAkH4A2pBBHJB6AAQfRpBuAJBCBCYASIDRQ0NIAMgAkGYAWpByAEQfSIEQQA2AsgBIARBzAFqIAJBCGpB6AAQfRpBzIXAACEEDAELIAJBATYC5AIgAiACNgLgAkE4QQEQmAEiA0UNAyACQjg3AvwDIAIgAzYC+AMgAiACQfgDajYCCCACQawBakEBNgIAIAJCATcCnAEgAkG8hsAANgKYASACIAJB4AJqNgKoASACQQhqIAJBmAFqEBkNBCACKAL8AyEEIAIoAvgDIgYgAigCgAQQACEDQQEhBSAEBEAgBhASCwsgAQRAIAAQEgsgBQ0EQQxBBBCYASIARQ0FIAAgBDYCCCAAIAM2AgQgAEEANgIAIAJBkAVqJAAgAA8LQdQAQQRBrKLAACgCACIAQQIgABsRAAAAC0H4AEEIQayiwAAoAgAiAEECIAAbEQAAAAtBOBCFAQALQZiHwABBMyACQZgBakHMh8AAQdyHwAAQagALIAMQAgALQQxBBEGsosAAKAIAIgBBAiAAGxEAAAALQeAAQQhBrKLAACgCACIAQQIgABsRAAAAC0HwAEEIQayiwAAoAgAiAEECIAAbEQAAAAtB2AFBCEGsosAAKAIAIgBBAiAAGxEAAAALQeACQQhBrKLAACgCACIAQQIgABsRAAAAC0HYAkEIQayiwAAoAgAiAEECIAAbEQAAAAtBuAJBCEGsosAAKAIAIgBBAiAAGxEAAAALQZgCQQhBrKLAACgCACIAQQIgABsRAAAAC6wcAgR/An4jAEGAAWsiBSQAIAAgACkDCCIHIAKtQgOGfCIINwMIIAggB1QEQCAAIAApAwBCAXw3AwALIABBEGohBgJAAkACQAJAIABB0ABqKAIAIgNFDQBBgAEgA2siBCACSw0AIANBgQFPDQEgAyAAQdQAaiIDaiABIAQQfRogAEEANgJQIAUgA0GAARB9IgMgAykDACIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDACADIAMpAwgiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AwggAyADKQMQIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwMQIAMgAykDGCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDGCADIAMpAyAiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AyAgAyADKQMoIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwMoIAMgAykDMCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDMCADIAMpAzgiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AzggAyADKQNAIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwNAIAMgAykDSCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDSCADIAMpA1AiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3A1AgAyADKQNYIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwNYIAMgAykDYCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDYCADIAMpA2giB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3A2ggAyADKQNwIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwNwIAMgAykDeCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDeCAGIAMQAyACIARrIQIgASAEaiEBCyACQYABTwRAIAIhAwNAIAUgAUGAARB9IgQgBCkDACIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDACAEIAQpAwgiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AwggBCAEKQMQIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwMQIAQgBCkDGCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDGCAEIAQpAyAiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AyAgBCAEKQMoIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwMoIAQgBCkDMCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDMCAEIAQpAzgiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3AzggBCAEKQNAIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwNAIAQgBCkDSCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDSCAEIAQpA1AiB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3A1AgBCAEKQNYIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwNYIAQgBCkDYCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcDYCAEIAQpA2giB0I4hiAHQiiGQoCAgICAgMD/AIOEIAdCGIZCgICAgIDgP4MgB0IIhkKAgICA8B+DhIQgB0IIiEKAgID4D4MgB0IYiEKAgPwHg4QgB0IoiEKA/gODIAdCOIiEhIQ3A2ggBCAEKQNwIgdCOIYgB0IohkKAgICAgIDA/wCDhCAHQhiGQoCAgICA4D+DIAdCCIZCgICAgPAfg4SEIAdCCIhCgICA+A+DIAdCGIhCgID8B4OEIAdCKIhCgP4DgyAHQjiIhISENwNwIAQgBCkDeCIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4Mg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BgEEfyAAIAFqIQICQAJAAkACQAJAIABBBGooAgAiA0EBcQ0AIANBA3FFDQEgACgCACIDIAFqIQEgACADayIAQfChwAAoAgBGBEAgAigCBEEDcUEDRw0BQeihwAAgATYCACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAIgATYCAA8LIAAgAxA7CwJAIAJBBGooAgAiA0ECcQRAIAJBBGogA0F+cTYCACAAIAFBAXI2AgQgACABaiABNgIADAELAkAgAkH0ocAAKAIARwRAQfChwAAoAgAgAkYNASACIANBeHEiAhA7IAAgASACaiIBQQFyNgIEIAAgAWogATYCACAAQfChwAAoAgBHDQJB6KHAACABNgIADwtB9KHAACAANgIAQeyhwABB7KHAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQfChwAAoAgBHDQJB6KHAAEEANgIAQfChwABBADYCAA8LQfChwAAgADYCAEHoocAAQeihwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIADwsgAUGAAkkNAyAAQgA3AhAgAEEcagJ/QQAgAUEIdiIDRQ0AGkEfIAFB////B0sNABogAUEGIANnIgJrQR9xdkEBcSACQQF0a0E+agsiAjYCACACQQJ0QeigwABqIQMCQAJAQdyewAAoAgAiBEEBIAJBH3F0IgVxBEAgAygCACIDQQRqKAIAQXhxIAFHDQEgAyECDAILQdyewAAgBCAFcjYCACADIAA2AgAMBAsgAUEAQRkgAkEBdmtBH3EgAkEfRht0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAkUNAyAEQQF0IQQgAiEDIAJBBGooAgBBeHEgAUcNAAsLIAIoAggiASAANgIMIAIgADYCCCAAQRhqQQA2AgAgACACNgIMIAAgATYCCAsPCyAFIAA2AgALIABBGGogAzYCACAAIAA2AgwgACAANgIIDwsgAUEDdiICQQN0QeCewABqIQECf0HYnsAAKAIAIgNBASACQR9xdCICcQRAIAEoAggMAQtB2J7AACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC6wGAQt/IwBBMGsiAyQAIANBJGpBgIfAADYCACADQQM6ACggA0KAgICAgAQ3AwggAyAANgIgIANBADYCGCADQQA2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aiAGKQMANwMAIAJBGGogBCkDADcDACACQSBqIAUpAwA3AwAgAkEoaiADKQMANwMAIAJBNGogAikDoAE3AgAgAkE8aiACQagBaikDADcCACACQcQAaiACQbABaikDADcCACACQcwAaiACQbgBaikDADcCACACQdQAaiACQcABaikDADcCACACQdwAaiACQcgBaikDADcCACACQeQAaiACQdABaikDADcCACACQewAaiACQdgBaikDADcCACACIAc3AwAgAiACKQN4NwMIIAIgASgCMDYCMCACQaABaiACEEMCQAJAQShBARCYASIDBEAgAkIoNwIEIAIgAzYCACACIAJBoAFqQSgQVCACKAIAIQQCQCACKAIEIgUgAigCCCIDRgRAIAUhAwwBCyAFIANJDQIgBUUNACADRQRAIAQQEkEBIQQMAQsgBCAFQQEgAxCMASIERQ0DCyABQgA3AwAgAUEANgIwIAFBCGoiAUHol8AAKQMANwMAIAFBCGpB8JfAACkDADcDACABQRBqQfiXwAApAwA3AwAgAUEYakGAmMAAKQMANwMAIAFBIGpBiJjAACkDADcDACAAIAM2AgQgACAENgIAIAJB4AFqJAAPC0EoEIUBAAtB34vAAEEkQYSMwAAQegALIANBAUGsosAAKAIAIgBBAiAAGxEAAAAL0gQCBX8BfiABQSBqIQMgAUEIaiEEIAEpAwAhBwJAAkAgAUEcaiIFKAIAIgJBwABGBEAgBCADEAdBACECIAVBADYCAAwBCyACQT9LDQELIAFBHGoiBSACakEEakGAAToAACABIAEoAhwiBkEBaiICNgIcAkAgAkHBAEkEQCACIAVqQQRqQQBBPyAGaxCCAUHAACABKAIca0EHTQRAIAQgAxAHIAFBHGooAgAiAkHBAE8NAiABQSBqQQAgAhCCAQsgAUHYAGogB0IDhiIHQjiGIAdCKIZCgICAgICAwP8Ag4QgB0IYhkKAgICAgOA/gyAHQgiGQoCAgIDwH4OEhCAHQgiIQoCAgPgPgyAHQhiIQoCA/AeDhCAHQiiIQoD+A4MgB0I4iISEhDcCACAEIAMQByABQQA2AhwgAEEQaiABQRhqKAIAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZycjYAACAAQQxqIAFBFGooAgAiAkEYdCACQQh0QYCA/Adx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IAAgAzYCBCAAIAU2AgAgAkHAAWokAA8LQRQQhQEAC0Hfi8AAQSRBhIzAABB6AAsgA0EBQayiwAAoAgAiAEECIAAbEQAAAAuEBAEEfyMAQeACayICJAAgAkHIAGogAUGYAhB9GgJAAkACQCACKAKQAiIDQcgASQRAIAJBkAJqIANqIgVBBGpBBjoAACAFQQVqQQBBxwAgA2sQggEgAkHbAmoiAyADLQAAQYABcjoAACACQQA2ApACA0AgAkHIAGogBGoiAyADLQAAIANBzAFqLQAAczoAACAEQQFqIgRByABHDQALIAJByABqEBEgAkFAayACQYABaikDADcDACACQThqIAJB+ABqKQMANwMAIAJBMGogAkHwAGopAwA3AwAgAkEoaiACQegAaikDADcDACACQSBqIAJB4ABqKQMANwMAIAJBGGogAkHYAGopAwA3AwAgAkEQaiACQdAAaikDADcDACACIAIpA0g3AwhBwABBARCYASIERQ0BIAJCwAA3AkwgAiAENgJIIAJByABqIAJBCGpBwAAQVCACKAJIIQUCQCACKAJMIgMgAigCUCIERgRAIAMhBAwBCyADIARJDQMgA0UNACAERQRAIAUQEkEBIQUMAQsgBSADQQEgBBCMASIFRQ0ECyABEBIgACAENgIEIAAgBTYCACACQeACaiQADwtBmJrAAEEXIAJBCGpBsJrAAEGIncAAEGoAC0HAABCFAQALQd+LwABBJEGEjMAAEHoACyAEQQFBrKLAACgCACIAQQIgABsRAAAAC4QEAQR/IwBB4AJrIgIkACACQcgAaiABQZgCEH0aAkACQAJAIAIoApACIgNByABJBEAgAkGQAmogA2oiBUEEakEBOgAAIAVBBWpBAEHHACADaxCCASACQdsCaiIDIAMtAABBgAFyOgAAIAJBADYCkAIDQCACQcgAaiAEaiIDIAMtAAAgA0HMAWotAABzOgAAIARBAWoiBEHIAEcNAAsgAkHIAGoQESACQUBrIAJBgAFqKQMANwMAIAJBOGogAkH4AGopAwA3AwAgAkEwaiACQfAAaikDADcDACACQShqIAJB6ABqKQMANwMAIAJBIGogAkHgAGopAwA3AwAgAkEYaiACQdgAaikDADcDACACQRBqIAJB0ABqKQMANwMAIAIgAikDSDcDCEHAAEEBEJgBIgRFDQEgAkLAADcCTCACIAQ2AkggAkHIAGogAkEIakHAABBUIAIoAkghBQJAIAIoAkwiAyACKAJQIgRGBEAgAyEEDAELIAMgBEkNAyADRQ0AIARFBEAgBRASQQEhBQwBCyAFIANBASAEEIwBIgVFDQQLIAEQEiAAIAQ2AgQgACAFNgIAIAJB4AJqJAAPC0GYmsAAQRcgAkEIakGwmsAAQcicwAAQagALQcAAEIUBAAtB34vAAEEkQYSMwAAQegALIARBAUGsosAAKAIAIgBBAiAAGxEAAAALqAQBBH8jAEHgAmsiAyQAIAMgAUHIARB9IgJBmAJqIAFBzAFqEF4gAiABKALIASIENgLIASACQcwBaiACQZgCakHIABB9GgJAAkACQCAEQcgASQRAIAJByAFqIARqIgVBBGpBAToAAEEAIQMgBUEFakEAQccAIARrEIIBIAJBkwJqIgQgBC0AAEGAAXI6AAAgAkEANgLIAQNAIAIgA2oiBCAELQAAIARBzAFqLQAAczoAACADQQFqIgNByABHDQALIAIQESACQdACaiACQThqKQMANwMAIAJByAJqIAJBMGopAwA3AwAgAkHAAmogAkEoaikDADcDACACQbgCaiACQSBqKQMANwMAIAJBsAJqIAJBGGopAwA3AwAgAkGoAmogAkEQaikDADcDACACQaACaiACQQhqKQMANwMAIAIgAikDADcDmAJBwABBARCYASIDRQ0BIAJCwAA3AgQgAiADNgIAIAIgAkGYAmpBwAAQVCACKAIAIQUCQCACKAIEIgQgAigCCCIDRgRAIAQhAwwBCyAEIANJDQMgBEUNACADRQRAIAUQEkEBIQUMAQsgBSAEQQEgAxCMASIFRQ0ECyABQQBBzAEQggEgACADNgIEIAAgBTYCACACQeACaiQADwtBmJrAAEEXIAJBmAJqQbCawABByJzAABBqAAtBwAAQhQEAC0Hfi8AAQSRBhIzAABB6AAsgA0EBQayiwAAoAgAiAEECIAAbEQAAAAuoBAEEfyMAQeACayIDJAAgAyABQcgBEH0iAkGYAmogAUHMAWoQXiACIAEoAsgBIgQ2AsgBIAJBzAFqIAJBmAJqQcgAEH0aAkACQAJAIARByABJBEAgAkHIAWogBGoiBUEEakEGOgAAQQAhAyAFQQVqQQBBxwAgBGsQggEgAkGTAmoiBCAELQAAQYABcjoAACACQQA2AsgBA0AgAiADaiIEIAQtAAAgBEHMAWotAABzOgAAIANBAWoiA0HIAEcNAAsgAhARIAJB0AJqIAJBOGopAwA3AwAgAkHIAmogAkEwaikDADcDACACQcACaiACQShqKQMANwMAIAJBuAJqIAJBIGopAwA3AwAgAkGwAmogAkEYaikDADcDACACQagCaiACQRBqKQMANwMAIAJBoAJqIAJBCGopAwA3AwAgAiACKQMANwOYAkHAAEEBEJgBIgNFDQEgAkLAADcCBCACIAM2AgAgAiACQZgCakHAABBUIAIoAgAhBQJAIAIoAgQiBCACKAIIIgNGBEAgBCEDDAELIAQgA0kNAyAERQ0AIANFBEAgBRASQQEhBQwBCyAFIARBASADEIwBIgVFDQQLIAFBAEHMARCCASAAIAM2AgQgACAFNgIAIAJB4AJqJAAPC0GYmsAAQRcgAkGYAmpBsJrAAEGIncAAEGoAC0HAABCFAQALQd+LwABBJEGEjMAAEHoACyADQQFBrKLAACgCACIAQQIgABsRAAAAC4IEAQR/IwBBoANrIgMkACADIAFByAEQfSICQbgCaiABQcwBahBgIAIgASgCyAEiBDYCyAEgAkHMAWogAkG4AmpB6AAQfRoCQAJAAkAgBEHoAEkEQCACQcgBaiAEaiIFQQRqQQY6AABBACEDIAVBBWpBAEHnACAEaxCCASACQbMCaiIEIAQtAABBgAFyOgAAIAJBADYCyAEDQCACIANqIgQgBC0AACAEQcwBai0AAHM6AAAgA0EBaiIDQegARw0ACyACEBEgAkHgAmogAkEoaikDADcDACACQdgCaiACQSBqKQMANwMAIAJB0AJqIAJBGGopAwA3AwAgAkHIAmogAkEQaikDADcDACACQcACaiACQQhqKQMANwMAIAIgAikDADcDuAJBMEEBEJgBIgNFDQEgAkIwNwIEIAIgAzYCACACIAJBuAJqQTAQVCACKAIAIQUCQCACKAIEIgQgAigCCCIDRgRAIAQhAwwBCyAEIANJDQMgBEUNACADRQRAIAUQEkEBIQUMAQsgBSAEQQEgAxCMASIFRQ0ECyABQQBBzAEQggEgACADNgIEIAAgBTYCACACQaADaiQADwtBmJrAAEEXIAJBuAJqQbCawABB+JzAABBqAAtBMBCFAQALQd+LwABBJEGE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QCACQShqIARqIgMgAy0AACADQcwBai0AAHM6AAAgBEEBaiIEQYgBRw0ACyACQShqEBEgAkEgaiACQUBrKQMANwMAIAJBGGogAkE4aikDADcDACACQRBqIAJBMGopAwA3AwAgAiACKQMoNwMIQSBBARCYASIERQ0BIAJCIDcCLCACIAQ2AiggAkEoaiACQQhqQSAQVCACKAIoIQUCQCACKAIsIgMgAigCMCIERgRAIAMhBAwBCyADIARJDQMgA0UNACAERQRAIAUQEkEBIQUMAQsgBSADQQEgBBCMASIFRQ0ECyABEBIgACAENgIEIAAgBTYCACACQYADaiQADwtBmJrAAEEXIAJBCGpBsJrAAEGonMAAEGoAC0EgEIUBAAtB34vAAEEkQYSMwAAQegALIARBAUGsosAAKAIAIgBBAiAAGxEAAAALtQMBBH8jAEGAA2siAiQAIAJBKGogAUHYAhB9GgJAAkACQCACKALwASIDQYgBSQRAIAJB8AFqIANqIgVBBGpBBjoAACAFQQVqQQBBhwEgA2sQggEgAkH7AmoiAyADLQAAQYABcjoAACACQQA2AvABA0AgAkEoaiAEaiIDIAMtAAAgA0HMAWotAABzOgAAIARBAWoiBEGIAUcNAAsgAkEoahARIAJBIGogAkFAaykDADcDACACQRhqIAJBOGopAwA3AwAgAkEQaiACQTBqKQMANwMAIAIgAikDKDcDCEEgQQEQmAEiBEUNASACQiA3AiwgAiAENgIoIAJBKGogAkEIakEgEFQgAigCKCEFAkAgAigCLCIDIAIoAjAiBEYEQCADIQQMAQsgAyAESQ0DIANFDQAgBEUEQCAFEBJBASEFDAELIAUgA0EBIAQQjAEiBUUNBAsgARASIAAgBDYCBCAAIAU2AgAgAkGAA2okAA8LQZiawABBFyACQQhqQbCawABB6JzAABBqAAtBIBCFAQALQd+LwABBJEGEjMAAEHoACyAEQQFBrKLAACgCACIAQQIgABsRAAAAC84DAgR/AX4jAEGgAWsiAiQAIAEpAwAhBiACQeAAaiABQQxqEFYgAkEMaiACKQNgNwIAIAJBFGogAkHoAGopAwA3AgAgAkEcaiACQfAAaikDADcCACACQSRqIAJB+ABqKQMANwIAIAJBLGogAkGAAWopAwA3AgAgAkE0aiACQYgBaikDADcCACACQTxqIAJBkAFqKQMANwIAIAJBxABqIAJBmAFqKQMANwIAIAIgBjcDACACIAEoAgg2AgggAkHUAGogAUHUAGopAgA3AgAgAiABKQJMNwJMIAJB4ABqIAIQSQJAAkBBEEEBEJgBIgMEQCACQhA3AgQgAiADNgIAIAIgAkHgAGpBEBBUIAIoAgAhBAJAIAIoAgQiBSACKAIIIgNGBEAgBSEDDAELIAUgA0kNAiAFRQ0AIANFBEAgBBASQQEhBAwBCyAEIAVBASADEIwBIgRFDQMLIAFCADcDACABQQA2AgggAUHMAGoiAUEIakHgl8AAKQMANwIAIAFB2JfAACkDADcCACAAIAM2AgQgACAENgIAIAJBoAFqJAAPC0EQEIUBAAtB34vAAEEkQYSMwAAQegALIANBAUGsosAAKAIAIgBBAiAAGxEAAAALzgMCBH8BfiMAQaABayICJAAgASkDACEGIAJB4ABqIAFBDGoQViACQQxqIAIpA2A3AgAgAkEUaiACQegAaikDADcCACACQRxqIAJB8ABqKQMANwIAIAJBJGogAkH4AGopAwA3AgAgAkEsaiACQYABaikDADcCACACQTRqIAJBiAFqKQMANwIAIAJBPGogAkGQAWopAwA3AgAgAkHEAGogAkGYAWopAwA3AgAgAiAGNwMAIAIgASgCCDYCCCACQdQAaiABQdQAaikCADcCACACIAEpAkw3AkwgAkHgAGogAhBKAkACQEEQQQEQmAEiAwRAIAJCEDcCBCACIAM2AgAgAiACQeAAakEQEFQgAigCACEEAkAgAigCBCIFIAIoAggiA0YEQCAFIQMMAQsgBSADSQ0CIAVFDQAgA0UEQCAEEBJBASEEDAELIAQgBUEBIAMQjAEiBEUNAwsgAUIANwMAIAFBADYCCCABQcwAaiIBQQhqQeCXwAApAwA3AgAgAUHYl8AAKQMANwIAIAAgAzYCBCAAIAQ2AgAgAkGgAWokAA8LQRAQhQEAC0Hfi8AAQSRBhIzAABB6AAsgA0EBQayiwAAoAgAiAEECIAAbEQAAAAuvAwEEfyMAQYADayICJAAgAkEgaiABQeACEH0aAkACQAJAIAIoAugBIgNBkAFJBEAgAkHoAWogA2oiBUEEakEBOgAAIAVBBWpBAEGPASADaxCCASACQfsCaiIDIAMtAABBgAFyOgAAIAJBADYC6AEDQCACQSBqIARqIgMgAy0AACADQcwBai0AAHM6AAAgBEEBaiIEQZABRw0ACyACQSBqEBEgAkEYaiACQThqKAIANgIAIAJBEGogAkEwaikDADcDACACQQhqIAJBKGopAwA3AwAgAiACKQMgNwMAQRxBARCYASIERQ0BIAJCHDcCJCACIAQ2AiAgAkEgaiACQRwQVCACKAIgIQUCQCACKAIkIgMgAigCKCIERgRAIAMhBAwBCyADIARJDQMgA0UNACAERQRAIAUQEkEBIQUMAQsgBSADQQEgBBCMASIFRQ0ECyABEBIgACAENgIEIAAgBTYCACACQYADaiQADwtBmJrAAEEXIAJBsJrAAEHAmsAAEGoAC0EcEIUBAAtB34vAAEEkQYSMwAAQegALIARBAUGsosAAKAIAIgBBAiAAGxEAAAALrwMBBH8jAEGAA2siAiQAIAJBIGogAUHgAhB9GgJAAkACQCACKALoASIDQZABSQRAIAJB6AFqIANqIgVBBGpBBjoAACAFQQVqQQBBjwEgA2sQggEgAkH7AmoiAyADLQAAQYABcjoAACACQQA2AugBA0AgAkEgaiAEaiIDIAMtAAAgA0HMAWotAABzOgAAIARBAWoiBEGQAUcNAAsgAkEgahARIAJBGGogAkE4aigCADYCACACQRBqIAJBMGopAwA3AwAgAkEIaiACQShqKQMANwMAIAIgAikDIDcDAEEcQQEQmAEiBEUNASACQhw3AiQgAiAENgIgIAJBIGogAkEcEFQgAigCICEFAkAgAigCJCIDIAIoAigiBEYEQCADIQQMAQsgAyAESQ0DIANFDQAgBEUEQCAFEBJBASEFDAELIAUgA0EBIAQQjAEiBUUNBAsgARASIAAgBDYCBCAAIAU2AgAgAkGAA2okAA8LQZiawABBFyACQbCawABB2JzAABBqAAtBHBCFAQALQd+LwABBJEGEjMAAEHoACyAEQQFBrKLAACgCACIAQQIgABsRAAAAC+gCAQV/AkBBzf97IABBECAAQRBLGyIAayABTQ0AIABBECABQQtqQXhxIAFBC0kbIgRqQQxqEAkiAkUNACACQXhqIQECQCAAQX9qIgMgAnFFBEAgASEADAELIAJBfGoiBSgCACIGQXhxIAIgA2pBACAAa3FBeGoiAiAAIAJqIAIgAWtBEEsbIgAgAWsiAmshAyAGQQNxBEAgACADIAAoAgRBAXFyQQJyNgIEIAAgA2oiAyADKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACAAIAAoAgRBAXI2AgQgASACEBgMAQsgASgCACEBIAAgAzYCBCAAIAEgAmo2AgALAkAgAEEEaigCACIBQQNxRQ0AIAFBeHEiAiAEQRBqTQ0AIABBBGogBCABQQFxckECcjYCACAAIARqIgEgAiAEayIEQQNyNgIEIAAgAmoiAiACKAIEQQFyNgIEIAEgBBAYCyAAQQhqIQMLIAMLiwMCBn8BfiMAQfAAayICJAAgAkHQAGoiAyABQRBqKQMANwMAIAJB2ABqIgQgAUEYaikDADcDACACQeAAaiIFIAFBIGopAwA3AwAgAkHoAGoiBiABQShqKQMANwMAIAIgASkDCDcDSCABKQMAIQggAkEIaiABQTRqEFYgASgCMCEHQfgAQQgQmAEiAUUEQEH4AEEIQayiwAAoAgAiAEECIAAbEQAAAAsgASAINwMAIAEgAikDSDcDCCABIAc2AjAgASACKQMINwI0IAFBEGogAykDADcDACABQRhqIAQpAwA3AwAgAUEgaiAFKQMANwMAIAFBKGogBikDADcDACABQTxqIAJBEGopAwA3AgAgAUHEAGogAkEYaikDADcCACABQcwAaiACQSBqKQMANwIAIAFB1ABqIAJBKGopAwA3AgAgAUHcAGogAkEwaikDADcCACABQeQAaiACQThqKQMANwIAIAFB7ABqIAJBQGspAwA3AgAgAEGUjMAANgIEIAAgATYCACACQfAAaiQAC4wDAgl/An4jAEHAAWsiAiQAIAFBCGopAwAhCyABKQMAIQwgAiABQdQAahBfIAJBiAFqIgMgAUEYaikDADcDACACQZABaiIEIAFBIGopAwA3AwAgAkGYAWoiBSABQShqKQMANwMAIAJBoAFqIgYgAUEwaikDADcDACACQagBaiIHIAFBOGopAwA3AwAgAkGwAWoiCCABQUBrKQMANwMAIAJBuAFqIgkgAUHIAGopAwA3AwAgAiABKQMQNwOAASABKAJQIQpB2AFBCBCYASIBRQRAQdgBQQhBrKLAACgCACIAQQIgABsRAAAACyABIAs3AwggASAMNwMAIAEgAikDgAE3AxAgAUEYaiADKQMANwMAIAFBIGogBCkD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BjYCCCABIAc3AwAgASACKQMgNwIMIAFBFGogAkEoaikDADcCACABQRxqIAJBMGopAwA3AgAgAUEkaiACQThqKQMANwIAIAFBLGogAkFAaykDADcCACABQTRqIAJByABqKQMANwIAIAFBPGogAkHQAGopAwA3AgAgAUHEAGogAkHYAGopAwA3AgAgAUHkAGogBSkDADcCACABQdwAaiAEKQMANwIAIAFB1ABqIAMpAwA3AgAgASACKQMANwJMIABB2JDAADYCBCAAIAE2AgAgAkHgAGokAAvIAgIEfwF+IwBB4ABrIgIkACACQdAAaiIDIAFBEGopAwA3AwAgAkHYAGoiBCABQRhqKAIANgIAIAIgASkDCDcDSCABKQMAIQYgAkEIaiABQSBqEFYgASgCHCEFQeAAQQgQmAEiAUUEQEHgAEEIQayiwAAoAgAiAEECIAAbEQAAAAsgASAGNwMAIAEgAikDSDcDCCABIAU2AhwgASACKQMINwMgIAFBEGogAykDADcDACABQRhqIAQoAgA2AgAgAUEoaiACQRBqKQMANwMAIAFBMGogAkEYaikDADcDACABQThqIAJBIGopAwA3AwAgAUFAayACQShqKQMANwMAIAFByABqIAJBMGopAwA3AwAgAUHQAGogAkE4aikDADcDACABQdgAaiACQUBrKQMANwMAIABBuIzAADYCBCAAIAE2AgAgAkHgAGokAAvIAgIEfwF+IwBB4ABrIgIkACACQdAAaiIDIAFBEGopAwA3AwAgAkHYAGoiBCABQRhqKAIANgIAIAIgASkDCDcDSCABKQMAIQYgAkEIaiABQSBqEFYgASgCHCEFQeAAQQgQmAEiAUUEQEHgAEEIQayiwAAoAgAiAEECIAAbEQAAAAsgASAGNwMAIAEgAikDSDcDCCABIAU2AhwgASACKQMINwMgIAFBEGogAykDADcDACABQRhqIAQoAgA2AgAgAUEoaiACQRBqKQMANwMAIAFBMGogAkEYaikDADcDACABQThqIAJBIGopAwA3AwAgAUFAayACQShqKQMANwMAIAFByABqIAJBMGopAwA3AwAgAUHQAGogAkE4aikDADcDACABQdgAaiACQUBrKQMANwMAIABB3IzAADYCBCAAIAE2AgAgAkHgAGokAAvdAgIFfwF+IABBDGohAiAAQcwAaiEDIAApAwAhBgJAAkAgAEEIaiIEKAIAIgFBwABGBEAgAyACEARBACEBIARBADYCAAwBCyABQT9LDQELIABBCGoiBCABakEEakGAAToAACAAIAAoAggiBUEBaiIBNgIIAkAgAUHBAEkEQCABIARqQQRqQQBBPyAFaxCCAUHAACAAKAIIa0EISQRAIAMgAhAEIABBCGooAgAiAUHBAE8NAiAAQQxqQQAgARCCAQsgAEHEAGogBkIohkKAgICAgIDA/wCDIAZCOIaEIAZCGIZCgICAgIDgP4MgBkIIhkKAgICA8B+DhIQgBkIIiEKAgID4D4MgBkIYiEKAgPwHg4QgBkIoiEKA/gODIAZCOIiEhIQ3AgAgAyACEAQgAEEANgIIDwsgAUHAAEHomcAAEG8ACyABQcAAQfiZwAAQbgALIAFBwABBiJrAABBtAAu3AgIFfwF+IwBBMGsiBCQAQSchAgJAIABCkM4AVARAIAAhBwwBCwNAIARBCWogAmoiA0F8aiAAIABCkM4AgCIHQvCxf358pyIFQf//A3FB5ABuIgZBAXRB2ojAAGovAAA7AAAgA0F+aiAGQZx/bCAFakH//wNxQQF0QdqIwABqLwAAOwAAIAJBfGohAiAAQv/B1y9WIAchAA0ACwsgB6ciA0HjAEoEQCACQX5qIgIgBEEJamogB6ciBUH//wNxQeQAbiIDQZx/bCAFakH//wNxQQF0QdqIwABqLwAAOwAACwJAIANBCk4EQCACQX5qIgIgBEEJamogA0EBdEHaiMAAai8AADsAAAwBCyACQX9qIgIgBEEJamogA0EwajoAAAsgASAEQQlqIAJqQScgAmsQHCAEQTBqJAALzgICBX8BfiABQTRqIQQgAUEIaiEDIAEpAwAhBwJAAkAgAUEwaiIFKAIAIgJBwABGBEAgAyAEEAVBACECIAVBADYCAAwBCyACQT9LDQELIAFBMGoiBSACakEEakGAAToAACABIAEoAjAiBkEBaiICNgIwAkAgAkHBAEkEQCACIAVqQQRqQQBBPyAGaxCCAUHAACABKAIwa0EHTQRAIAMgBBAFIAFBMGooAgAiAkHBAE8NAiABQTRqQQAgAhCCAQsgAUHsAGogB0IDhjcCACADIAQQBSABQQA2AjAgACADKQAANwAAIABBCGogA0EIaikAADcAACAAQRBqIANBEGopAAA3AAAgAEEYaiADQRhqKQAANwAAIABBIGogA0EgaikAADcAAA8LIAJBwABB6JnAABBvAAsgAkHAAEH4mcAAEG4ACyACQcAAQYiawAAQbQALvwIBA38CQAJAAkACQCAAQcgBaigCACIDRQ0AQcgAIANrIgQgAksNACADQckATw0BIAAgA2pBzAFqIAEgBBB9GkEAIQMgAEEANgLIASABIARqIQEDQCAAIANqIgUgBS0AACAFQcwBai0AAHM6AAAgA0EBaiIDQcgARw0ACyAAEBEgAiAEayECCyACQcgATwRAA0BBACEDA0AgACADaiIEIAQtAAAgASADai0AAHM6AAAgA0EBaiIDQcgARw0ACyAAEBEgAUHIAGohASACQbh/aiICQcgATw0ACwsgAEHIAWooAgAiAyACaiIEIANJDQEgBEHIAEsNAiAAIANqQcwBaiABIAIQfRogACAAKALIASACajYCyAEPCyADQcgAQaibwAAQbwALIAMgBEG4m8AAEG8ACyAEQcgAQbibwAAQbgALvwIBA38CQAJAAkACQCAAQcgBaigCACIDRQ0AQYgBIANrIgQgAksNACADQYkBTw0BIAAgA2pBzAFqIAEgBBB9GkEAIQMgAEEANgLIASABIARqIQEDQCAAIANqIgUgBS0AACAFQcwBai0AAHM6AAAgA0EBaiIDQYgBRw0ACyAAEBEgAiAEayECCyACQYgBTwRAA0BBACEDA0AgACADaiIEIAQtAAAgASADai0AAHM6AAAgA0EBaiIDQYgBRw0ACyAAEBEgAUGIAWohASACQfh+aiICQYgBTw0ACwsgAEHIAWooAgAiAyACaiIEIANJDQEgBEGIAUsNAiAAIANqQcwBaiABIAIQfRogACAAKALIASACajYCyAEPCyADQYgBQaibwAAQbwALIAMgBEG4m8AAEG8ACyAEQYgBQbibwAAQbgALvwIBA38CQAJAAkACQCAAQcgBaigCACIDRQ0AQZABIANrIgQgAksNACADQZEBTw0BIAAgA2pBzAFqIAEgBBB9GkEAIQMgAEEANgLIASABIARqIQEDQCAAIANqIgUgBS0AACAFQcwBai0AAHM6AAAgA0EBaiIDQZABRw0ACyAAEBEgAiAEayECCyACQZABTwRAA0BBACEDA0AgACADaiIEIAQtAAAgASADai0AAHM6AAAgA0EBaiIDQZABRw0ACyAAEBEgAUGQAWohASACQfB+aiICQZABTw0ACwsgAEHIAWooAgAiAyACaiIEIANJDQEgBEGQAUsNAiAAIANqQcwBaiABIAIQfRogACAAKALIASACajYCyAEPCyADQZABQaibwAAQbwALIAMgBEG4m8AAEG8ACyAEQZABQbibwAAQbgALvwIBA38CQAJAAkACQCAAQcgBaigCACIDRQ0AQegAIANrIgQgAksNACADQekATw0BIAAgA2pBzAFqIAEgBBB9GkEAIQMgAEEANgLIASABIARqIQEDQCAAIANqIgUgBS0AACAFQcwBai0AAHM6AAAgA0EBaiIDQegARw0ACyAAEBEgAiAEayECCyACQegATwRAA0BBACEDA0AgACADaiIEIAQtAAAgASADai0AAHM6AAAgA0EBaiIDQegARw0ACyAAEBEgAUHoAGohASACQZh/aiICQegATw0ACwsgAEHIAWooAgAiAyACaiIEIANJDQEgBEHoAEsNAiAAIANqQcwBaiABIAIQfRogACAAKALIASACajYCyAEPCyADQegAQaibwAAQbwALIAMgBEG4m8AAEG8ACyAEQegAQbibwAAQbgALrgICBX8BfiABQSBqIQQgAUEIaiEDIAEpAwAhBwJAAkAgAUEcaiIFKAIAIgJBwABGBEAgAyAEEAZBACECIAVBADYCAAwBCyACQT9LDQELIAFBHGoiBSACakEEakGAAToAACABIAEoAhwiBkEBaiICNgIcAkAgAkHBAEkEQCACIAVqQQRqQQBBPyAGaxCCAUHAACABKAIca0EHTQRAIAMgBBAGIAFBHGooAgAiAkHBAE8NAiABQSBqQQAgAhCCAQsgAUHYAGogB0IDhjcCACADIAQQBiABQQA2AhwgACADKQAANwAAIABBCGogA0EIaikAADcAACAAQRBqIANBEGooAAA2AAAPCyACQcAAQeiZwAAQbwALIAJBwABB+JnAABBuAAsgAkHAAEGImsAAEG0AC58CAgV/AX4gAUEMaiEEIAFBzABqIQMgASkDACEHAkACQCABQQhqIgUoAgAiAkHAAEYEQCADIAQQDEEAIQIgBUEANgIADAELIAJBP0sNAQsgAUEIaiIFIAJqQQRqQYABOgAAIAEgASgCCCIGQQFqIgI2AggCQCACQcEASQRAIAIgBWpBBGpBAEE/IAZrEIIBQcAAIAEoAghrQQdNBEAgAyAEEAwgAUEIaigCACICQcEATw0CIAFBDGpBACACEIIBCyABQcQAaiAHQgOGNwIAIAMgBBAMIAFBADYCCCAAIAMpAAA3AAAgAEEIaiADQQhqKQAANwAADwsgAkHAAEHomcAAEG8ACyACQcAAQfiZwAAQbgALIAJBwABBiJrAABBtAAudAgIFfwF+IAFBDGohAyABQcwAaiEEIAEpAwAhBwJAAkAgAUEIaiIFKAIAIgJBwABGBEAgBCADEA5BACECIAVBADYCAAwBCyACQT9LDQELIAFBCGoiBSACakEEakGAAToAACABIAEoAggiBkEBaiICNgIIAkAgAkHBAEkEQCACIAVqQQRqQQBBPyAGaxCCAUHAACABKAIIa0EHTQRAIAQgAxAOIAFBCGooAgAiAkHBAE8NAiABQQxqQQAgAhCCAQsgAUHEAGogB0IDhjcCACAEIAMQDiABQQA2AgggACABQdQAaikCADcACCAAIAEpAkw3AAAPCyACQcAAQeiZwAAQbwALIAJBwABB+JnAABBuAAsgAkHAAEGImsAAEG0AC6gCAgN/AX4jAEHQAGsiAiQAIAEpAwAhBSACQRBqIAFBDGoQViACQQhqIgMgAUHUAGopAgA3AwAgAiABKQJMNwMAIAEoAgghBEHgAEEIEJgBIgFFBEBB4ABBCEGsosAAKAIAIgBBAiAAGxEAAAALIAEgBDYCCCABIAU3AwAgASACKQMQNwIMIAFBFGogAkEYaikDADcCACABQRxqIAJBIGopAwA3AgAgAUEkaiACQShqKQMANwIAIAFBLGogAkEwaikDADcCACABQTRqIAJBOGopAwA3AgAgAUE8aiACQUBrKQMANwIAIAFBxABqIAJByABqKQMANwIAIAFB1ABqIAMpAwA3AgAgASACKQMANwJMIABBpI3AADYCBCAAIAE2AgAgAkHQAGokAAuoAgIDfwF+IwBB0ABrIgIkACABKQMAIQUgAkEQaiABQQxqEFYgAkEIaiIDIAFB1ABqKQIANwMAIAIgASkCTDcDACABKAIIIQRB4ABBCBCYASIBRQRAQeAAQQhBrKLAACgCACIAQQIgABsRAAAACyABIAQ2AgggASAFNwMAIAEgAikDEDcCDCABQRRqIAJBGGopAwA3AgAgAUEcaiACQSBqKQMANwIAIAFBJGogAkEoaikDADcCACABQSxqIAJBMGopAwA3AgAgAUE0aiACQThqKQMANwIAIAFBPGogAkFAaykDADcCACABQcQAaiACQcgAaikDADcCACABQdQAaiADKQMANwIAIAEgAikDADcCTCAAQcSRwAA2AgQgACABNgIAIAJB0ABqJAALhwIBA38gACAAKQMAIAKtQgOGfDcDACAAQcwAaiEFAkACQAJAAkAgAEEIaigCACIDRQ0AQcAAIANrIgQgAksNACADQcEATw0BIAMgAEEMaiIDaiABIAQQfRogAEEANgIIIAUgAxAEIAIgBGshAiABIARqIQELIAJBwABPBEAgAiEDA0AgBSABEAQgAUFAayEBIANBQGoiA0HAAE8NAAsgAkE/cSECCyAAQQhqKAIAIgMgAmoiBCADSQ0BIARBwABLDQIgACADakEMaiABIAIQfRogACAAKAIIIAJqNgIIDwsgA0HAAEGom8AAEG8ACyADIARBuJvAABBvAAsgBEHAAEG4m8AAEG4AC4MCAQN/IAAgACkDACACrXw3AwAgAEEIaiEFAkACQAJAAkAgAEEwaigCACIDRQ0AQcAAIANrIgQgAksNACADQcEATw0BIAMgAEE0aiIDaiABIAQQfRogAEEANgIwIAUgAxAFIAIgBGshAiABIARqIQELIAJBwABPBEAgAiEDA0AgBSABEAUgAUFAayEBIANBQGoiA0HAAE8NAAsgAkE/cSECCyAAQTBqKAIAIgMgAmoiBCADSQ0BIARBwABLDQIgACADakE0aiABIAIQfRogACAAKAIwIAJqNgIwDwsgA0HAAEGom8AAEG8ACyADIARBuJvAABBvAAsgBEHAAEG4m8AAEG4AC4MCAQN/IAAgACkDACACrXw3AwAgAEEIaiEFAkACQAJAAkAgAEEcaigCACIDRQ0AQcAAIANrIgQgAksNACADQcEATw0BIAMgAEEgaiIDaiABIAQQfRogAEEANgIcIAUgAxAHIAIgBGshAiABIARqIQELIAJBwABPBEAgAiEDA0AgBSABEAcgAUFAayEBIANBQGoiA0HAAE8NAAsgAkE/cSECCyAAQRxqKAIAIgMgAmoiBCADSQ0BIARBwABLDQIgACADakEgaiABIAIQfRogACAAKAIcIAJqNgIcDwsgA0HAAEGom8AAEG8ACyADIARBuJvAABBvAAsgBEHAAEG4m8AAEG4AC4MCAQN/IAAgACkDACACrXw3AwAgAEEIaiEFAkACQAJAAkAgAEEcaigCACIDRQ0AQcAAIANrIgQgAksNACADQcEATw0BIAMgAEEgaiIDaiABIAQQfRogAEEANgIcIAUgAxAGIAIgBGshAiABIARqIQELIAJBwABPBEAgAiEDA0AgBSABEAYgAUFAayEBIANBQGoiA0HAAE8NAAsgAkE/cSECCyAAQRxqKAIAIgMgAmoiBCADSQ0BIARBwABLDQIgACADakEgaiABIAIQfRogACAAKAIcIAJqNgIcDwsgA0HAAEGom8AAEG8ACyADIARBuJvAABBvAAsgBEHAAEG4m8AAEG4AC4QCAQN/IAAgACkDACACrXw3AwAgAEHMAGohBQJAAkACQAJAIABBCGooAgAiA0UNAEHAACADayIEIAJLDQAgA0HBAE8NASADIABBDGoiA2ogASAEEH0aIABBADYCCCAFIAMQDCACIARrIQIgASAEaiEBCyACQcAATwRAIAIhAwNAIAUgARAMIAFBQGshASADQUBqIgNBwABPDQALIAJBP3EhAgsgAEEIaigCACIDIAJqIgQgA0kNASAEQcAASw0CIAAgA2pBDGogASACEH0aIAAgACgCCCACajYCCA8LIANBwABBqJvAABBvAAsgAyAEQbibwAAQbwALIARBwABBuJvAABBuAAuEAgEDfyAAIAApAwAgAq18NwMAIABBzABqIQUCQAJAAkACQCAAQQhqKAIAIgNFDQBBwAAgA2siBCACSw0AIANBwQBPDQEgAyAAQQxqIgNqIAEgBBB9GiAAQQA2AgggBSADEA4gAiAEayECIAEgBGohAQsgAkHAAE8EQCACIQMDQCAFIAEQDiABQUBrIQEgA0FAaiIDQcAATw0ACyACQT9xIQILIABBCGooAgAiAyACaiIEIANJDQEgBEHAAEsNAiAAIANqQQxqIAEgAhB9GiAAIAAoAgggAmo2AggPCyADQcAAQaibwAAQbwALIAMgBEG4m8AAEG8ACyAEQcAAQbibwAAQbgAL7wEBBH8CQAJAAkAgAEEEaigCACIFIABBCGooAgAiBGsgAiABayIGTwRAIAAoAgAhAgwBCyAEIAZqIgIgBEkNASAFQQF0IgMgAiADIAJLGyIDQQBIDQECQAJAIAUEQCAAKAIAIgINAQsgA0UEQEEBIQIMAgsgA0EBEJgBIgINAQwECyADIAVHBEAgAiAFQQEgAxCMASECCyACRQ0DIABBCGooAgAhBAsgACACNgIAIABBBGogAzYCAAsgAiAEaiABIAYQfRogAEEIaiAEIAZqNgIADwsQjQEACyADQQFBrKLAACgCACIAQQIgABsRAAAAC/gBAQR/AkAgAEEEaigCACIGIABBCGooAgAiA2sgAk8EQCAAKAIAIQQMAQsCQCACIANqIgUgA08EQEEAIQMgBkEBdCIEIAUgBCAFSxsiBUEASA0BAkACQCAGRQRAIAUNAUEBIQQMAgsgACgCACEEIAUgBkYNAUEBIQMgBCAGQQEgBRCMASIEDQEMAwtBASEDIAVBARCYASIERQ0CCyAAIAQ2AgAgAEEEaiAFNgIAIABBCGooAgAhAwwCC0EAIQMLIAMEQCAFIANBrKLAACgCACIAQQIgABsRAAAACxCNAQALIAMgBGogASACEH0aIABBCGogAiADajYCAAvoAQEDfyAAQRRqIQUCQAJAAkACQCAAKAIAIgNFDQBBECADayIEIAJLDQAgA0ERTw0BIAMgAEEEaiIDaiABIAQQfRogAEEANgIAIAUgAxANIAIgBGshAiABIARqIQELIAJBEE8EQCACIQMDQCAFIAEQDSABQRBqIQEgA0FwaiIDQRBPDQALIAJBD3EhAgsgACgCACIDIAJqIgQgA0kNASAEQRBLDQIgACADakEEaiABIAIQfRogACAAKAIAIAJqNgIADwsgA0EQQaibwAAQbwALIAMgBEG4m8AAEG8ACyAEQRBBuJvAABBuAAvyAQEEfyMAQZABayICJAAgAkEANgIAIAJBBHIhBQNAIAMgBWogASADai0AADoAACACIAIoAgBBAWoiBDYCACADQQFqIgNBwABHDQALIARBP00EQCAEQcAAEHAACyACQcgAaiACQcQAEH0aIABBOGogAkGEAWopAgA3AAAgAEEwaiACQfwAaikCADcAACAAQShqIAJB9ABqKQIANwAAIABBIGogAkHsAGopAgA3AAAgAEEYaiACQeQAaikCADcAACAAQRBqIAJB3ABqKQIANwAAIABBCGogAkHUAGopAgA3AAAgACACKQJMNwAAIAJBkAFqJAAL6gEBBH8jAEGAAWsiAiQAIAJBIGogAUHgABB9GiACQQhqIAJBIGoQHwJAAkBBFEEBEJgBIgMEQCACQhQ3AiQgAiADNgIgIAJBIGogAkEIakEUEFQgAigCICEEAkAgAigCJCIFIAIoAigiA0YEQCAFIQMMAQsgBSADSQ0CIAVFDQAgA0UEQCAEEBJBASEEDAELIAQgBUEBIAMQjAEiBEUNAwsgARASIAAgAzYCBCAAIAQ2AgAgAkGAAWokAA8LQRQQhQEAC0Hfi8AAQSRBhIzAABB6AAsgA0EBQayiwAAoAgAiAEECIAAbEQAAAAvqAQEEfyMAQYABayICJAAgAkEgaiABQeAAEH0aIAJBCGogAkEgahBIAkACQEEUQQEQmAEiAwRAIAJCFDcCJCACIAM2AiAgAkEgaiACQQhqQRQQVCACKAIgIQQCQCACKAIkIgUgAigCKCIDRgRAIAUhAwwBCyAFIANJDQIgBUUNACADRQRAIAQQEkEBIQQMAQsgBCAFQQEgAxCMASIERQ0DCyABEBIgACADNgIEIAAgBDYCACACQYABaiQADwtBFBCFAQALQd+LwABBJEGEjMAAEHoACyADQQFBrKLAACgCACIAQQIgABsRAAAAC+QBAQR/IwBBoAFrIgIkACACQShqIAFB+AAQfRogAiACQShqEEMCQAJAQShBARCYASIDBEAgAkIoNwIsIAIgAzYCKCACQShqIAJBKBBUIAIoAighBAJAIAIoAiwiBSACKAIwIgNGBEAgBSEDDAELIAUgA0kNAiAFRQ0AIANFBEAgBBASQQEhBAwBCyAEIAVBASADEIwBIgRFDQMLIAEQEiAAIAM2AgQgACAENgIAIAJBoAFqJAAPC0EoEIUBAAtB34vAAEEkQYSMwAAQegALIANBAUGsosAAKAIAIgBBAiAAGxEAAAAL5AEBBH8jAEHwAGsiAiQAIAJBEGogAUHgABB9GiACIAJBEGoQSQJAAkBBEEEBEJgBIgMEQCACQhA3AhQgAiADNgIQIAJBEGogAkEQEFQgAigCECEEAkAgAigCFCIFIAIoAhgiA0YEQCAFIQMMAQsgBSADSQ0CIAVFDQAgA0UEQCAEEBJBASEEDAELIAQgBUEBIAMQjAEiBEUNAwsgARASIAAgAzYCBCAAIAQ2AgAgAkHwAGokAA8LQRAQhQEAC0Hfi8AAQSRBhIzAABB6AAsgA0EBQayiwAAoAgAiAEECIAAbEQAAAAvkAQEEfyMAQfAAayICJAAgAkEQaiABQeAAEH0aIAIgAkEQahBKAkACQEEQQQEQmAEiAwRAIAJCEDcCFCACIAM2AhAgAkEQaiACQRAQVCACKAIQIQQCQCACKAIUIgUgAigCGCIDRgRAIAUhAwwBCyAFIANJDQIgBUUNACADRQRAIAQQEkEBIQQMAQsgBCAFQQEgAxCMASIERQ0DCyABEBIgACADNgIEIAAgBDYCACACQfAAaiQADwtBEBCFAQALQd+LwABBJEGEjMAAEHoACyADQQFBrKLAACgCACIAQQIgABsRAAAAC4MBAQR/IwBBsAJrIgIkACACQQA2AgAgAkEEciEFA0AgAyAFaiABIANqLQAAOgAAIAIgAigCAEEBaiIENgIAIANBAWoiA0GQAUcNAAsgBEGPAU0EQCAEQZABEHAACyACQZgBaiACQZQBEH0aIAAgAkGYAWpBBHJBkAEQfRogAkGwAmokAAuDAQEEfyMAQaACayICJAAgAkEANgIAIAJBBHIhBQNAIAMgBWogASADai0AADoAACACIAIoAgBBAWoiBDYCACADQQFqIgNBiAFHDQALIARBhwFNBEAgBEGIARBwAAsgAkGQAWogAkGMARB9GiAAIAJBkAFqQQRyQYgBEH0aIAJBoAJqJAALgwEBBH8jAEGgAWsiAiQAIAJBADYCACACQQRyIQUDQCADIAVqIAEgA2otAAA6AAAgAiACKAIAQQFqIgQ2AgAgA0EBaiIDQcgARw0ACyAEQccATQRAIARByAAQcAALIAJB0ABqIAJBzAAQfRogACACQdAAakEEckHIABB9GiACQaABaiQAC4MBAQR/IwBBkAJrIgIkACACQQA2AgAgAkEEciEFA0AgAyAFaiABIANqLQAAOgAAIAIgAigCAEEBaiIENgIAIANBAWoiA0GAAUcNAAsgBEH/AE0EQCAEQYABEHAACyACQYgBaiACQYQBEH0aIAAgAkGIAWpBBHJBgAEQfRogAkGQAmokAAuDAQEEfyMAQeABayICJAAgAkEANgIAIAJBBHIhBQNAIAMgBWogASADai0AADoAACACIAIoAgBBAWoiBDYCACADQQFqIgNB6ABHDQALIARB5wBNBEAgBEHoABBwAAsgAkHwAGogAkHsABB9GiAAIAJB8ABqQQRyQegAEH0aIAJB4AFqJAALlgEBAn8jAEHgAmsiAiQAIAJBmAFqIAFByAEQfRogAkEIaiABQcwBahBcIAEoAsgBIQNB4AJBCBCYASIBRQRAQeACQQhBrKLAACgCACIAQQIgABsRAAAACyABIAJBmAFqQcgBEH0iASADNgLIASABQcwBaiACQQhqQZABEH0aIABByI3AADYCBCAAIAE2AgAgAkHgAmokAAuWAQECfyMAQeACayICJAAgAkGYAWogAUHIARB9GiACQQhqIAFBzAFqEFwgASgCyAEhA0HgAkEIEJgBIgFFBEBB4AJBCEGsosAAKAIAIgBBAiAAGxEAAAALIAEgAkGYAWpByAEQfSIBIAM2AsgBIAFBzAFqIAJBCGpBkAEQfRogAEGQjsAANgIEIAAgATYCACACQeACaiQAC4IBAQF/IwBBMGsiAkEOaiABKAAKNgEAIAJBEmogAS8ADjsBACACIAEvAAA7AQQgAiABKQACNwEGIAJBEDYCACACQSBqIAJBCGopAwA3AwAgAkEoaiACQRBqKAIANgIAIAIgAikDADcDGCAAIAIpAhw3AAAgAEEIaiACQSRqKQIANwAAC5ABAQJ/IwBB0AJrIgIkACACQYgBaiABQcgBEH0aIAIgAUHMAWoQXSABKALIASEDQdgCQQgQmAEiAUUEQEHYAkEIQayiwAAoAgAiAEECIAAbEQAAAAsgASACQYgBakHIARB9IgEgAzYCyAEgAUHMAWogAkGIARB9GiAAQeyNwAA2AgQgACABNgIAIAJB0AJqJAALkAEBAn8jAEGwAmsiAiQAIAJB6ABqIAFByAEQfRogAiABQcwBahBgIAEoAsgBIQNBuAJBCBCYASIBRQRAQbgCQQhBrKLAACgCACIAQQIgABsRAAAACyABIAJB6ABqQcgBEH0iASADNgLIASABQcwBaiACQegAEH0aIABBtI7AADYCBCAAIAE2AgAgAkGwAmokAAuQAQECfyMAQbACayICJAAgAkHoAGogAUHIARB9GiACIAFBzAFqEGAgASgCyAEhA0G4AkEIEJgBIgFFBEBBuAJBCEGsosAAKAIAIgBBAiAAGxEAAAALIAEgAkHoAGpByAEQfSIBIAM2AsgBIAFBzAFqIAJB6AAQfRogAEHYjsAANgIEIAAgATYCACACQbACaiQAC5ABAQJ/IwBBkAJrIgIkACACQcgAaiABQcgBEH0aIAIgAUHMAWoQXiABKALIASEDQZgCQQgQmAEiAUUEQEGYAkEIQayiwAAoAgAiAEECIAAbEQAAAAsgASACQcgAakHIARB9IgEgAzYCyAEgAUHMAWogAkHIABB9GiAAQfyOwAA2AgQgACABNgIAIAJBkAJqJAALkAEBAn8jAEHQAmsiAiQAIAJBiAFqIAFByAEQfRogAiABQcwBahBdIAEoAsgBIQNB2AJBCBCYASIBRQRAQdgCQQhBrKLAACgCACIAQQIgABsRAAAACyABIAJBiAFqQcgBEH0iASADNgLIASABQcwBaiACQYgBEH0aIABBoI/AADYCBCAAIAE2AgAgAkHQAmokAAuQAQECfyMAQZACayICJAAgAkHIAGogAUHIARB9GiACIAFBzAFqEF4gASgCyAEhA0GYAkEIEJgBIgFFBEBBmAJBCEGsosAAKAIAIgBBAiAAGxEAAAALIAEgAkHIAGpByAEQfSIBIAM2AsgBIAFBzAFqIAJByAAQfRogAEHEj8AANgIEIAAgATYCACACQZACaiQAC34BAX8jAEFAaiIFJAAgBSABNgIMIAUgADYCCCAFIAM2AhQgBSACNgIQIAVBLGpBAjYCACAFQTxqQQQ2AgAgBUICNwIcIAVByIvAADYCGCAFQQE2AjQgBSAFQTBqNgIoIAUgBUEQajYCOCAFIAVBCGo2AjAgBUEYaiAEEIEBAAuYAQAgAEIANwMAIABBCGpCADcDACAAQQA2AlAgAEGomcAAKQMANwMQIABBGGpBsJnAACkDADcDACAAQSBqQbiZwAApAwA3AwAgAEEoakHAmcAAKQMANwMAIABBMGpByJnAACkDADcDACAAQThqQdCZwAApAwA3AwAgAEFAa0HYmcAAKQMANwMAIABByABqQeCZwAApAwA3AwALmAEAIABCADcDACAAQQhqQgA3AwAgAEEANgJQIABB6JjAACkDADcDECAAQRhqQfCYwAApAwA3AwAgAEEgakH4mMAAKQMANwMAIABBKGpBgJnAACkDADcDACAAQTBqQYiZwAApAwA3AwAgAEE4akGQmcAAKQMANwMAIABBQGtBmJnAACkDADcDACAAQcgAakGgmcAAKQMANwMAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEFNgIAIANCAjcCDCADQYiIwAA2AgggA0EFNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhCBAQALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQU2AgAgA0ICNwIMIANBpIrAADYCCCADQQU2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEIEBAAttAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBBTYCACADQgI3AgwgA0HcisAANgIIIANBBTYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQgQEAC3ABAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQRxqQQI2AgAgAkEsakEFNgIAIAJCAjcCDCACQeiRwAA2AgggAkEFNgIkIAIgAkEgajYCGCACIAJBBGo2AiggAiACNgIgIAJBCGpB+JHAABCBAQALVAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEaiACQQhqEBkgAkEgaiQAC2ICAX8BfiMAQRBrIgIkAAJAIAEEQCABKAIADQEgAUF/NgIAIAJBCGogASgCBCABQQhqKAIAKAIQEQAAIAIpAwghAyABQQA2AgAgACADNwIAIAJBEGokAA8LEJABAAsQkQEAC1gAIABCADcCFCAAQQA2AgAgAEHMAGpCADcCACAAQcQAakIANwIAIABBPGpCADcCACAAQTRqQgA3AgAgAEEsakIANwIAIABBJGpCADcCACAAQRxqQgA3AgALagECf0EBIQACQAJAQaCiwAAoAgBBAUcEQEGgosAAQoGAgIAQNwMADAELQaSiwABBpKLAACgCAEEBaiIANgIAIABBAksNAQtBqKLAACgCACIBQX9MDQBBqKLAACABNgIAIABBAUsNAAALAAtDAQN/AkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAEEBaiEAIAFBAWohASACQX9qIgINAQwCCwsgBCAFayEDCyADC0sBAn8CQCAABEAgACgCAA0BIABBADYCACAAKAIEIQEgACgCCCECIAAQEiABIAIoAgARBAAgAigCBARAIAEQEgsPCxCQAQALEJEBAAtIAAJAIAAEQCAAKAIADQEgAEF/NgIAIAAoAgQgASACIABBCGooAgAoAgwRAQAgAgRAIAEQEgsgAEEANgIADwsQkAEACxCRAQALSgACfyABQYCAxABHBEBBASAAKAIYIAEgAEEcaigCACgCEBECAA0BGgsgAkUEQEEADwsgACgCGCACQQAgAEEcaigCACgCDBEDAAsLXQAgAEIANwMAIABBADYCMCAAQeiXwAApAwA3AwggAEEQakHwl8AAKQMANwMAIABBGGpB+JfAACkDADcDACAAQSBqQYCYwAApAwA3AwAgAEEoakGImMAAKQMANwMAC0gBAX8jAEEgayIDJAAgA0EUakEANgIAIANBxJ3AADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEIEBAAtQACAAQgA3AwAgAEEANgIIIABBpJjAACkCADcCTCAAQdQAakGsmMAAKQIANwIAIABB3ABqQbSYwAApAgA3AgAgAEHkAGpBvJjAACkCADcCAAtQACAAQgA3AwAgAEEANgIIIABBxJjAACkCADcCTCAAQdQAakHMmMAAKQIANwIAIABB3ABqQdSYwAApAgA3AgAgAEHkAGpB3JjAACkCADcCAAszAQF/IAIEQCAAIQMDQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAALKwACQCAAQXxLDQAgAEUEQEEEDwsgACAAQX1JQQJ0EJgBIgBFDQAgAA8LAAs9ACAAQQA2AhwgAEEYakGgmMAAKAIANgIAIABBEGpBmJjAACkDADcDACAAQZCYwAApAwA3AwggAEIANwMACz0AIABCADcDACAAQQA2AhwgAEGQmMAAKQMANwMIIABBEGpBmJjAACkDADcDACAAQRhqQaCYwAAoAgA2AgALSgEBfyMAQRBrIgIkACACIAE2AgwgAiAANgIIIAJBmIjAADYCBCACQcSdwAA2AgAgAigCCEUEQEGYncAAQStBxJ3AABB6AAsQdAALIQAgAgRAA0AgACABOgAAIABBAWohACACQX9qIgINAAsLCy4AIABB1ABqQeCXwAApAwA3AgAgAEHYl8AAKQMANwJMIABBADYCCCAAQgA3AwALIAACQCABQXxLDQAgACABQQQgAhCMASIARQ0AIAAP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"));
            cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });
            cachedTextDecoder.decode();
            cachegetUint8Memory0 = null;
            heap = new Array(32).fill(undefined);
            heap.push(undefined, null, true, false);
            heap_next = heap.length;
            WASM_VECTOR_LEN = 0;
            cachedTextEncoder = new TextEncoder('utf-8');
            encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
                ? function (arg, view) {
                    return cachedTextEncoder.encodeInto(arg, view);
                }
                : function (arg, view) {
                    const buf = cachedTextEncoder.encode(arg);
                    view.set(buf);
                    return {
                        read: arg.length,
                        written: buf.length
                    };
                });
            cachegetInt32Memory0 = null;
            DenoHash = class DenoHash {
                static __wrap(ptr) {
                    const obj = Object.create(DenoHash.prototype);
                    obj.ptr = ptr;
                    return obj;
                }
                free() {
                    const ptr = this.ptr;
                    this.ptr = 0;
                    wasm.__wbg_denohash_free(ptr);
                }
            };
            exports_74("DenoHash", DenoHash);
            exports_74("default", init);
        }
    };
});
System.register("https://deno.land/std@0.67.0/encoding/hex", [], function (exports_75, context_75) {
    "use strict";
    var hextable;
    var __moduleName = context_75 && context_75.id;
    function errInvalidByte(byte) {
        return new Error("encoding/hex: invalid byte: " +
            new TextDecoder().decode(new Uint8Array([byte])));
    }
    exports_75("errInvalidByte", errInvalidByte);
    function errLength() {
        return new Error("encoding/hex: odd length hex string");
    }
    exports_75("errLength", errLength);
    function fromHexChar(byte) {
        if (48 <= byte && byte <= 57)
            return byte - 48;
        if (97 <= byte && byte <= 102)
            return byte - 97 + 10;
        if (65 <= byte && byte <= 70)
            return byte - 65 + 10;
        throw errInvalidByte(byte);
    }
    function encodedLen(n) {
        return n * 2;
    }
    exports_75("encodedLen", encodedLen);
    function encode(src) {
        const dst = new Uint8Array(encodedLen(src.length));
        for (let i = 0; i < dst.length; i++) {
            const v = src[i];
            dst[i * 2] = hextable[v >> 4];
            dst[i * 2 + 1] = hextable[v & 0x0f];
        }
        return dst;
    }
    exports_75("encode", encode);
    function encodeToString(src) {
        return new TextDecoder().decode(encode(src));
    }
    exports_75("encodeToString", encodeToString);
    function decode(src) {
        const dst = new Uint8Array(decodedLen(src.length));
        for (let i = 0; i < dst.length; i++) {
            const a = fromHexChar(src[i * 2]);
            const b = fromHexChar(src[i * 2 + 1]);
            dst[i] = (a << 4) | b;
        }
        if (src.length % 2 == 1) {
            fromHexChar(src[dst.length * 2]);
            throw errLength();
        }
        return dst;
    }
    exports_75("decode", decode);
    function decodedLen(x) {
        return x >>> 1;
    }
    exports_75("decodedLen", decodedLen);
    function decodeString(s) {
        return decode(new TextEncoder().encode(s));
    }
    exports_75("decodeString", decodeString);
    return {
        setters: [],
        execute: function () {
            hextable = new TextEncoder().encode("0123456789abcdef");
        }
    };
});
System.register("https://deno.land/std@0.67.0/hash/hasher", [], function (exports_76, context_76) {
    "use strict";
    var __moduleName = context_76 && context_76.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.67.0/hash/_wasm/hash", ["https://deno.land/std@0.67.0/hash/_wasm/wasm", "https://deno.land/std@0.67.0/encoding/hex", "https://deno.land/std@0.67.0/encoding/base64"], function (exports_77, context_77) {
    "use strict";
    var wasm_js_1, hex, base64, TYPE_ERROR_MSG, Hash;
    var __moduleName = context_77 && context_77.id;
    return {
        setters: [
            function (wasm_js_1_1) {
                wasm_js_1 = wasm_js_1_1;
            },
            function (hex_1) {
                hex = hex_1;
            },
            function (base64_2) {
                base64 = base64_2;
            }
        ],
        execute: async function () {
            await wasm_js_1.default(wasm_js_1.source);
            TYPE_ERROR_MSG = "hash: `data` is invalid type";
            Hash = class Hash {
                constructor(algorithm) {
                    this.#hash = wasm_js_1.create_hash(algorithm);
                    this.#digested = false;
                }
                #hash;
                #digested;
                update(data) {
                    let msg;
                    if (typeof data === "string") {
                        msg = new TextEncoder().encode(data);
                    }
                    else if (typeof data === "object") {
                        if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
                            msg = new Uint8Array(data);
                        }
                        else {
                            throw new Error(TYPE_ERROR_MSG);
                        }
                    }
                    else {
                        throw new Error(TYPE_ERROR_MSG);
                    }
                    wasm_js_1.update_hash(this.#hash, msg);
                    return this;
                }
                digest() {
                    if (this.#digested)
                        throw new Error("hash: already digested");
                    this.#digested = true;
                    return wasm_js_1.digest_hash(this.#hash);
                }
                toString(format = "hex") {
                    const finalized = new Uint8Array(this.digest());
                    switch (format) {
                        case "hex":
                            return hex.encodeToString(finalized);
                        case "base64":
                            return base64.encode(finalized);
                        default:
                            throw new Error("hash: invalid format");
                    }
                }
            };
            exports_77("Hash", Hash);
        }
    };
});
System.register("https://deno.land/std@0.67.0/hash/mod", ["https://deno.land/std@0.67.0/hash/_wasm/hash"], function (exports_78, context_78) {
    "use strict";
    var hash_ts_1;
    var __moduleName = context_78 && context_78.id;
    function createHash(algorithm) {
        return new hash_ts_1.Hash(algorithm);
    }
    exports_78("createHash", createHash);
    return {
        setters: [
            function (hash_ts_1_1) {
                hash_ts_1 = hash_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/deps", ["https://deno.land/std@0.69.0/io/bufio", "https://deno.land/std@0.67.0/bytes/mod", "https://deno.land/std@0.69.0/async/deferred", "https://deno.land/std@0.67.0/hash/mod"], function (exports_79, context_79) {
    "use strict";
    var __moduleName = context_79 && context_79.id;
    return {
        setters: [
            function (bufio_ts_5_1) {
                exports_79({
                    "BufReader": bufio_ts_5_1["BufReader"],
                    "BufWriter": bufio_ts_5_1["BufWriter"]
                });
            },
            function (mod_ts_15_1) {
                exports_79({
                    "copyBytes": mod_ts_15_1["copyBytes"]
                });
            },
            function (deferred_ts_4_1) {
                exports_79({
                    "deferred": deferred_ts_4_1["deferred"]
                });
            },
            function (mod_ts_16_1) {
                exports_79({
                    "createHash": mod_ts_16_1["createHash"]
                });
            }
        ],
        execute: function () {
        }
    };
});
/*!
 * Adapted directly from https://github.com/brianc/node-buffer-writer
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/postgres@v0.4.5/packet_writer", ["https://deno.land/x/postgres@v0.4.5/deps"], function (exports_80, context_80) {
    "use strict";
    var deps_ts_17, PacketWriter;
    var __moduleName = context_80 && context_80.id;
    return {
        setters: [
            function (deps_ts_17_1) {
                deps_ts_17 = deps_ts_17_1;
            }
        ],
        execute: function () {
            PacketWriter = class PacketWriter {
                constructor(size) {
                    this.encoder = new TextEncoder();
                    this.size = size || 1024;
                    this.buffer = new Uint8Array(this.size + 5);
                    this.offset = 5;
                    this.headerPosition = 0;
                }
                _ensure(size) {
                    const remaining = this.buffer.length - this.offset;
                    if (remaining < size) {
                        const oldBuffer = this.buffer;
                        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
                        this.buffer = new Uint8Array(newSize);
                        deps_ts_17.copyBytes(oldBuffer, this.buffer);
                    }
                }
                addInt32(num) {
                    this._ensure(4);
                    this.buffer[this.offset++] = (num >>> 24) & 0xff;
                    this.buffer[this.offset++] = (num >>> 16) & 0xff;
                    this.buffer[this.offset++] = (num >>> 8) & 0xff;
                    this.buffer[this.offset++] = (num >>> 0) & 0xff;
                    return this;
                }
                addInt16(num) {
                    this._ensure(2);
                    this.buffer[this.offset++] = (num >>> 8) & 0xff;
                    this.buffer[this.offset++] = (num >>> 0) & 0xff;
                    return this;
                }
                addCString(string) {
                    if (!string) {
                        this._ensure(1);
                    }
                    else {
                        const encodedStr = this.encoder.encode(string);
                        this._ensure(encodedStr.byteLength + 1);
                        deps_ts_17.copyBytes(encodedStr, this.buffer, this.offset);
                        this.offset += encodedStr.byteLength;
                    }
                    this.buffer[this.offset++] = 0;
                    return this;
                }
                addChar(c) {
                    if (c.length != 1) {
                        throw new Error("addChar requires single character strings");
                    }
                    this._ensure(1);
                    deps_ts_17.copyBytes(this.encoder.encode(c), this.buffer, this.offset);
                    this.offset++;
                    return this;
                }
                addString(string) {
                    string = string || "";
                    const encodedStr = this.encoder.encode(string);
                    this._ensure(encodedStr.byteLength);
                    deps_ts_17.copyBytes(encodedStr, this.buffer, this.offset);
                    this.offset += encodedStr.byteLength;
                    return this;
                }
                add(otherBuffer) {
                    this._ensure(otherBuffer.length);
                    deps_ts_17.copyBytes(otherBuffer, this.buffer, this.offset);
                    this.offset += otherBuffer.length;
                    return this;
                }
                clear() {
                    this.offset = 5;
                    this.headerPosition = 0;
                }
                addHeader(code, last) {
                    const origOffset = this.offset;
                    this.offset = this.headerPosition;
                    this.buffer[this.offset++] = code;
                    this.addInt32(origOffset - (this.headerPosition + 1));
                    this.headerPosition = origOffset;
                    this.offset = origOffset;
                    if (!last) {
                        this._ensure(5);
                        this.offset += 5;
                    }
                    return this;
                }
                join(code) {
                    if (code) {
                        this.addHeader(code, true);
                    }
                    return this.buffer.slice(code ? 0 : 5, this.offset);
                }
                flush(code) {
                    const result = this.join(code);
                    this.clear();
                    return result;
                }
            };
            exports_80("PacketWriter", PacketWriter);
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/utils", ["https://deno.land/x/postgres@v0.4.5/deps"], function (exports_81, context_81) {
    "use strict";
    var deps_ts_18, encoder;
    var __moduleName = context_81 && context_81.id;
    function readInt16BE(buffer, offset) {
        offset = offset >>> 0;
        const val = buffer[offset + 1] | (buffer[offset] << 8);
        return val & 0x8000 ? val | 0xffff0000 : val;
    }
    exports_81("readInt16BE", readInt16BE);
    function readUInt16BE(buffer, offset) {
        offset = offset >>> 0;
        return buffer[offset] | (buffer[offset + 1] << 8);
    }
    exports_81("readUInt16BE", readUInt16BE);
    function readInt32BE(buffer, offset) {
        offset = offset >>> 0;
        return ((buffer[offset] << 24) |
            (buffer[offset + 1] << 16) |
            (buffer[offset + 2] << 8) |
            buffer[offset + 3]);
    }
    exports_81("readInt32BE", readInt32BE);
    function readUInt32BE(buffer, offset) {
        offset = offset >>> 0;
        return (buffer[offset] * 0x1000000 +
            ((buffer[offset + 1] << 16) |
                (buffer[offset + 2] << 8) |
                buffer[offset + 3]));
    }
    exports_81("readUInt32BE", readUInt32BE);
    function md5(bytes) {
        return deps_ts_18.createHash("md5").update(bytes).toString("hex");
    }
    function hashMd5Password(password, username, salt) {
        const innerHash = md5(encoder.encode(password + username));
        const innerBytes = encoder.encode(innerHash);
        const outerBuffer = new Uint8Array(innerBytes.length + salt.length);
        outerBuffer.set(innerBytes);
        outerBuffer.set(salt, innerBytes.length);
        const outerHash = md5(outerBuffer);
        return "md5" + outerHash;
    }
    exports_81("hashMd5Password", hashMd5Password);
    function parseDsn(dsn) {
        const [protocol, stripped_url] = dsn.match(/(?:(?!:\/\/).)+/g) ?? ["", ""];
        const url = new URL(`http:${stripped_url}`);
        return {
            driver: protocol,
            user: url.username,
            password: url.password,
            hostname: url.hostname,
            port: url.port,
            database: url.pathname.slice(1),
            params: Object.fromEntries(url.searchParams.entries()),
        };
    }
    exports_81("parseDsn", parseDsn);
    function delay(ms, value) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(value);
            }, ms);
        });
    }
    exports_81("delay", delay);
    return {
        setters: [
            function (deps_ts_18_1) {
                deps_ts_18 = deps_ts_18_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/packet_reader", ["https://deno.land/x/postgres@v0.4.5/utils"], function (exports_82, context_82) {
    "use strict";
    var utils_ts_1, PacketReader;
    var __moduleName = context_82 && context_82.id;
    return {
        setters: [
            function (utils_ts_1_1) {
                utils_ts_1 = utils_ts_1_1;
            }
        ],
        execute: function () {
            PacketReader = class PacketReader {
                constructor(buffer) {
                    this.buffer = buffer;
                    this.offset = 0;
                    this.decoder = new TextDecoder();
                }
                readInt16() {
                    const value = utils_ts_1.readInt16BE(this.buffer, this.offset);
                    this.offset += 2;
                    return value;
                }
                readInt32() {
                    const value = utils_ts_1.readInt32BE(this.buffer, this.offset);
                    this.offset += 4;
                    return value;
                }
                readByte() {
                    return this.readBytes(1)[0];
                }
                readBytes(length) {
                    const start = this.offset;
                    const end = start + length;
                    const slice = this.buffer.slice(start, end);
                    this.offset = end;
                    return slice;
                }
                readString(length) {
                    const bytes = this.readBytes(length);
                    return this.decoder.decode(bytes);
                }
                readCString() {
                    const start = this.offset;
                    const end = this.buffer.indexOf(0, start);
                    const slice = this.buffer.slice(start, end);
                    this.offset = end + 1;
                    return this.decoder.decode(slice);
                }
            };
            exports_82("PacketReader", PacketReader);
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/encode", [], function (exports_83, context_83) {
    "use strict";
    var __moduleName = context_83 && context_83.id;
    function pad(number, digits) {
        let padded = "" + number;
        while (padded.length < digits) {
            padded = "0" + padded;
        }
        return padded;
    }
    function encodeDate(date) {
        const year = pad(date.getFullYear(), 4);
        const month = pad(date.getMonth() + 1, 2);
        const day = pad(date.getDate(), 2);
        const hour = pad(date.getHours(), 2);
        const min = pad(date.getMinutes(), 2);
        const sec = pad(date.getSeconds(), 2);
        const ms = pad(date.getMilliseconds(), 3);
        const encodedDate = `${year}-${month}-${day}T${hour}:${min}:${sec}.${ms}`;
        const offset = date.getTimezoneOffset();
        const tzSign = offset > 0 ? "-" : "+";
        const absOffset = Math.abs(offset);
        const tzHours = pad(Math.floor(absOffset / 60), 2);
        const tzMinutes = pad(Math.floor(absOffset % 60), 2);
        const encodedTz = `${tzSign}${tzHours}:${tzMinutes}`;
        return encodedDate + encodedTz;
    }
    function escapeArrayElement(value) {
        let strValue = value.toString();
        const escapedValue = strValue.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        return `"${escapedValue}"`;
    }
    function encodeArray(array) {
        let encodedArray = "{";
        array.forEach((element, index) => {
            if (index > 0) {
                encodedArray += ",";
            }
            if (element === null || typeof element === "undefined") {
                encodedArray += "NULL";
            }
            else if (Array.isArray(element)) {
                encodedArray += encodeArray(element);
            }
            else if (element instanceof Uint8Array) {
                throw new Error("Can't encode array of buffers.");
            }
            else {
                const encodedElement = encode(element);
                encodedArray += escapeArrayElement(encodedElement);
            }
        });
        encodedArray += "}";
        return encodedArray;
    }
    function encodeBytes(value) {
        let hex = Array.from(value)
            .map((val) => (val < 10 ? `0${val.toString(16)}` : val.toString(16)))
            .join("");
        return `\\x${hex}`;
    }
    function encode(value) {
        if (value === null || typeof value === "undefined") {
            return null;
        }
        else if (value instanceof Uint8Array) {
            return encodeBytes(value);
        }
        else if (value instanceof Date) {
            return encodeDate(value);
        }
        else if (value instanceof Array) {
            return encodeArray(value);
        }
        else if (value instanceof Object) {
            return JSON.stringify(value);
        }
        else {
            return value.toString();
        }
    }
    exports_83("encode", encode);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/oid", [], function (exports_84, context_84) {
    "use strict";
    var Oid;
    var __moduleName = context_84 && context_84.id;
    return {
        setters: [],
        execute: function () {
            exports_84("Oid", Oid = {
                bool: 16,
                bytea: 17,
                char: 18,
                name: 19,
                int8: 20,
                int2: 21,
                int2vector: 22,
                int4: 23,
                regproc: 24,
                text: 25,
                oid: 26,
                tid: 27,
                xid: 28,
                cid: 29,
                oidvector: 30,
                pg_ddl_command: 32,
                pg_type: 71,
                pg_attribute: 75,
                pg_proc: 81,
                pg_class: 83,
                json: 114,
                xml: 142,
                _xml: 143,
                pg_node_tree: 194,
                _json: 199,
                smgr: 210,
                index_am_handler: 325,
                point: 600,
                lseg: 601,
                path: 602,
                box: 603,
                polygon: 604,
                line: 628,
                _line: 629,
                cidr: 650,
                _cidr: 651,
                float4: 700,
                float8: 701,
                abstime: 702,
                reltime: 703,
                tinterval: 704,
                unknown: 705,
                circle: 718,
                _circle: 719,
                money: 790,
                _money: 791,
                macaddr: 829,
                inet: 869,
                _bool: 1000,
                _bytea: 1001,
                _char: 1002,
                _name: 1003,
                _int2: 1005,
                _int2vector: 1006,
                _int4: 1007,
                _regproc: 1008,
                _text: 1009,
                _tid: 1010,
                _xid: 1011,
                _cid: 1012,
                _oidvector: 1013,
                _bpchar: 1014,
                _varchar: 1015,
                _int8: 1016,
                _point: 1017,
                _lseg: 1018,
                _path: 1019,
                _box: 1020,
                _float4: 1021,
                _float8: 1022,
                _abstime: 1023,
                _reltime: 1024,
                _tinterval: 1025,
                _polygon: 1027,
                _oid: 1028,
                aclitem: 1033,
                _aclitem: 1034,
                _macaddr: 1040,
                _inet: 1041,
                bpchar: 1042,
                varchar: 1043,
                date: 1082,
                time: 1083,
                timestamp: 1114,
                _timestamp: 1115,
                _date: 1182,
                _time: 1183,
                timestamptz: 1184,
                _timestamptz: 1185,
                interval: 1186,
                _interval: 1187,
                _numeric: 1231,
                pg_database: 1248,
                _cstring: 1263,
                timetz: 1266,
                _timetz: 1270,
                bit: 1560,
                _bit: 1561,
                varbit: 1562,
                _varbit: 1563,
                numeric: 1700,
                refcursor: 1790,
                _refcursor: 2201,
                regprocedure: 2202,
                regoper: 2203,
                regoperator: 2204,
                regclass: 2205,
                regtype: 2206,
                _regprocedure: 2207,
                _regoper: 2208,
                _regoperator: 2209,
                _regclass: 2210,
                _regtype: 2211,
                record: 2249,
                cstring: 2275,
                any: 2276,
                anyarray: 2277,
                void: 2278,
                trigger: 2279,
                language_handler: 2280,
                internal: 2281,
                opaque: 2282,
                anyelement: 2283,
                _record: 2287,
                anynonarray: 2776,
                pg_authid: 2842,
                pg_auth_members: 2843,
                _txid_snapshot: 2949,
                uuid: 2950,
                _uuid: 2951,
                txid_snapshot: 2970,
                fdw_handler: 3115,
                pg_lsn: 3220,
                _pg_lsn: 3221,
                tsm_handler: 3310,
                anyenum: 3500,
                tsvector: 3614,
                tsquery: 3615,
                gtsvector: 3642,
                _tsvector: 3643,
                _gtsvector: 3644,
                _tsquery: 3645,
                regconfig: 3734,
                _regconfig: 3735,
                regdictionary: 3769,
                _regdictionary: 3770,
                jsonb: 3802,
                _jsonb: 3807,
                anyrange: 3831,
                event_trigger: 3838,
                int4range: 3904,
                _int4range: 3905,
                numrange: 3906,
                _numrange: 3907,
                tsrange: 3908,
                _tsrange: 3909,
                tstzrange: 3910,
                _tstzrange: 3911,
                daterange: 3912,
                _daterange: 3913,
                int8range: 3926,
                _int8range: 3927,
                pg_shseclabel: 4066,
                regnamespace: 4089,
                _regnamespace: 4090,
                regrole: 4096,
                _regrole: 4097,
            });
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/array_parser", [], function (exports_85, context_85) {
    "use strict";
    var ArrayParser;
    var __moduleName = context_85 && context_85.id;
    function parseArray(source, transform) {
        return new ArrayParser(source, transform).parse();
    }
    exports_85("parseArray", parseArray);
    function identity(value) {
        return value;
    }
    return {
        setters: [],
        execute: function () {
            ArrayParser = class ArrayParser {
                constructor(source, transform) {
                    this.position = 0;
                    this.entries = [];
                    this.recorded = [];
                    this.dimension = 0;
                    this.source = source;
                    this.transform = transform || identity;
                }
                isEof() {
                    return this.position >= this.source.length;
                }
                nextCharacter() {
                    const character = this.source[this.position++];
                    if (character === "\\") {
                        return {
                            value: this.source[this.position++],
                            escaped: true,
                        };
                    }
                    return {
                        value: character,
                        escaped: false,
                    };
                }
                record(character) {
                    this.recorded.push(character);
                }
                newEntry(includeEmpty = false) {
                    let entry;
                    if (this.recorded.length > 0 || includeEmpty) {
                        entry = this.recorded.join("");
                        if (entry === "NULL" && !includeEmpty) {
                            entry = null;
                        }
                        if (entry !== null)
                            entry = this.transform(entry);
                        this.entries.push(entry);
                        this.recorded = [];
                    }
                }
                consumeDimensions() {
                    if (this.source[0] === "[") {
                        while (!this.isEof()) {
                            let char = this.nextCharacter();
                            if (char.value === "=")
                                break;
                        }
                    }
                }
                parse(nested) {
                    let character, parser, quote;
                    this.consumeDimensions();
                    while (!this.isEof()) {
                        character = this.nextCharacter();
                        if (character.value === "{" && !quote) {
                            this.dimension++;
                            if (this.dimension > 1) {
                                parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
                                this.entries.push(parser.parse(true));
                                this.position += parser.position - 2;
                            }
                        }
                        else if (character.value === "}" && !quote) {
                            this.dimension--;
                            if (!this.dimension) {
                                this.newEntry();
                                if (nested)
                                    return this.entries;
                            }
                        }
                        else if (character.value === '"' && !character.escaped) {
                            if (quote)
                                this.newEntry(true);
                            quote = !quote;
                        }
                        else if (character.value === "," && !quote) {
                            this.newEntry();
                        }
                        else {
                            this.record(character.value);
                        }
                    }
                    if (this.dimension !== 0) {
                        throw new Error("array dimension not balanced");
                    }
                    return this.entries;
                }
            };
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/decode", ["https://deno.land/x/postgres@v0.4.5/oid", "https://deno.land/x/postgres@v0.4.5/connection", "https://deno.land/x/postgres@v0.4.5/array_parser"], function (exports_86, context_86) {
    "use strict";
    var oid_ts_1, connection_ts_1, array_parser_ts_1, DATETIME_RE, DATE_RE, TIMEZONE_RE, BC_RE, HEX, BACKSLASH_BYTE_VALUE, HEX_PREFIX_REGEX, decoder;
    var __moduleName = context_86 && context_86.id;
    function decodeDate(dateStr) {
        const matches = DATE_RE.exec(dateStr);
        if (!matches) {
            return null;
        }
        const year = parseInt(matches[1], 10);
        const month = parseInt(matches[2], 10) - 1;
        const day = parseInt(matches[3], 10);
        const date = new Date(year, month, day);
        date.setUTCFullYear(year);
        return date;
    }
    function decodeTimezoneOffset(dateStr) {
        const timeStr = dateStr.split(" ")[1];
        const matches = TIMEZONE_RE.exec(timeStr);
        if (!matches) {
            return null;
        }
        const type = matches[1];
        if (type === "Z") {
            return 0;
        }
        const sign = type === "-" ? 1 : -1;
        const hours = parseInt(matches[2], 10);
        const minutes = parseInt(matches[3] || "0", 10);
        const seconds = parseInt(matches[4] || "0", 10);
        const offset = hours * 3600 + minutes * 60 + seconds;
        return sign * offset * 1000;
    }
    function decodeDatetime(dateStr) {
        if (dateStr === "infinity") {
            return Number(Infinity);
        }
        else if (dateStr === "-infinity") {
            return Number(-Infinity);
        }
        const matches = DATETIME_RE.exec(dateStr);
        if (!matches) {
            return decodeDate(dateStr);
        }
        const isBC = BC_RE.test(dateStr);
        const year = parseInt(matches[1], 10) * (isBC ? -1 : 1);
        const month = parseInt(matches[2], 10) - 1;
        const day = parseInt(matches[3], 10);
        const hour = parseInt(matches[4], 10);
        const minute = parseInt(matches[5], 10);
        const second = parseInt(matches[6], 10);
        const msMatch = matches[7];
        const ms = msMatch ? 1000 * parseFloat(msMatch) : 0;
        let date;
        const offset = decodeTimezoneOffset(dateStr);
        if (offset === null) {
            date = new Date(year, month, day, hour, minute, second, ms);
        }
        else {
            const utc = Date.UTC(year, month, day, hour, minute, second, ms);
            date = new Date(utc + offset);
        }
        date.setUTCFullYear(year);
        return date;
    }
    function decodeBinary() {
        throw new Error("Not implemented!");
    }
    function decodeBytea(byteaStr) {
        if (HEX_PREFIX_REGEX.test(byteaStr)) {
            return decodeByteaHex(byteaStr);
        }
        else {
            return decodeByteaEscape(byteaStr);
        }
    }
    function decodeByteaHex(byteaStr) {
        let bytesStr = byteaStr.slice(2);
        let bytes = new Uint8Array(bytesStr.length / 2);
        for (let i = 0, j = 0; i < bytesStr.length; i += 2, j++) {
            bytes[j] = parseInt(bytesStr[i] + bytesStr[i + 1], HEX);
        }
        return bytes;
    }
    function decodeByteaEscape(byteaStr) {
        let bytes = [];
        let i = 0;
        let k = 0;
        while (i < byteaStr.length) {
            if (byteaStr[i] !== "\\") {
                bytes.push(byteaStr.charCodeAt(i));
                ++i;
            }
            else {
                if (/[0-7]{3}/.test(byteaStr.substr(i + 1, 3))) {
                    bytes.push(parseInt(byteaStr.substr(i + 1, 3), 8));
                    i += 4;
                }
                else {
                    let backslashes = 1;
                    while (i + backslashes < byteaStr.length &&
                        byteaStr[i + backslashes] === "\\") {
                        backslashes++;
                    }
                    for (k = 0; k < Math.floor(backslashes / 2); ++k) {
                        bytes.push(BACKSLASH_BYTE_VALUE);
                    }
                    i += Math.floor(backslashes / 2) * 2;
                }
            }
        }
        return new Uint8Array(bytes);
    }
    function decodeStringArray(value) {
        if (!value)
            return null;
        return array_parser_ts_1.parseArray(value, undefined);
    }
    function decodeBaseTenInt(value) {
        return parseInt(value, 10);
    }
    function decodeIntArray(value) {
        if (!value)
            return null;
        return array_parser_ts_1.parseArray(value, decodeBaseTenInt);
    }
    function decodeText(value, typeOid) {
        const strValue = decoder.decode(value);
        switch (typeOid) {
            case oid_ts_1.Oid.char:
            case oid_ts_1.Oid.varchar:
            case oid_ts_1.Oid.text:
            case oid_ts_1.Oid.time:
            case oid_ts_1.Oid.timetz:
            case oid_ts_1.Oid.inet:
            case oid_ts_1.Oid.cidr:
            case oid_ts_1.Oid.macaddr:
            case oid_ts_1.Oid.name:
            case oid_ts_1.Oid.uuid:
            case oid_ts_1.Oid.oid:
            case oid_ts_1.Oid.regproc:
            case oid_ts_1.Oid.regprocedure:
            case oid_ts_1.Oid.regoper:
            case oid_ts_1.Oid.regoperator:
            case oid_ts_1.Oid.regclass:
            case oid_ts_1.Oid.regtype:
            case oid_ts_1.Oid.regrole:
            case oid_ts_1.Oid.regnamespace:
            case oid_ts_1.Oid.regconfig:
            case oid_ts_1.Oid.regdictionary:
            case oid_ts_1.Oid.int8:
            case oid_ts_1.Oid.numeric:
            case oid_ts_1.Oid.void:
            case oid_ts_1.Oid.bpchar:
                return strValue;
            case oid_ts_1.Oid._text:
            case oid_ts_1.Oid._varchar:
            case oid_ts_1.Oid._macaddr:
            case oid_ts_1.Oid._cidr:
            case oid_ts_1.Oid._inet:
            case oid_ts_1.Oid._bpchar:
            case oid_ts_1.Oid._uuid:
                return decodeStringArray(strValue);
            case oid_ts_1.Oid.bool:
                return strValue[0] === "t";
            case oid_ts_1.Oid.int2:
            case oid_ts_1.Oid.int4:
                return decodeBaseTenInt(strValue);
            case oid_ts_1.Oid._int2:
            case oid_ts_1.Oid._int4:
                return decodeIntArray(strValue);
            case oid_ts_1.Oid.float4:
            case oid_ts_1.Oid.float8:
                return parseFloat(strValue);
            case oid_ts_1.Oid.timestamptz:
            case oid_ts_1.Oid.timestamp:
                return decodeDatetime(strValue);
            case oid_ts_1.Oid.date:
                return decodeDate(strValue);
            case oid_ts_1.Oid.json:
            case oid_ts_1.Oid.jsonb:
                return JSON.parse(strValue);
            case oid_ts_1.Oid.bytea:
                return decodeBytea(strValue);
            default:
                throw new Error(`Don't know how to parse column type: ${typeOid}`);
        }
    }
    function decode(value, column) {
        if (column.format === connection_ts_1.Format.BINARY) {
            return decodeBinary();
        }
        else if (column.format === connection_ts_1.Format.TEXT) {
            return decodeText(value, column.typeOid);
        }
        else {
            throw new Error(`Unknown column format: ${column.format}`);
        }
    }
    exports_86("decode", decode);
    return {
        setters: [
            function (oid_ts_1_1) {
                oid_ts_1 = oid_ts_1_1;
            },
            function (connection_ts_1_1) {
                connection_ts_1 = connection_ts_1_1;
            },
            function (array_parser_ts_1_1) {
                array_parser_ts_1 = array_parser_ts_1_1;
            }
        ],
        execute: function () {
            DATETIME_RE = /^(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?/;
            DATE_RE = /^(\d{1,})-(\d{2})-(\d{2})$/;
            TIMEZONE_RE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
            BC_RE = /BC$/;
            HEX = 16;
            BACKSLASH_BYTE_VALUE = 92;
            HEX_PREFIX_REGEX = /^\\x/;
            decoder = new TextDecoder();
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/query", ["https://deno.land/x/postgres@v0.4.5/encode", "https://deno.land/x/postgres@v0.4.5/decode"], function (exports_87, context_87) {
    "use strict";
    var encode_ts_1, decode_ts_1, commandTagRegexp, QueryResult, Query;
    var __moduleName = context_87 && context_87.id;
    return {
        setters: [
            function (encode_ts_1_1) {
                encode_ts_1 = encode_ts_1_1;
            },
            function (decode_ts_1_1) {
                decode_ts_1 = decode_ts_1_1;
            }
        ],
        execute: function () {
            commandTagRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;
            QueryResult = class QueryResult {
                constructor(query) {
                    this.query = query;
                    this._done = false;
                    this.rows = [];
                }
                handleRowDescription(description) {
                    this.rowDescription = description;
                }
                _parseDataRow(dataRow) {
                    const parsedRow = [];
                    for (let i = 0, len = dataRow.length; i < len; i++) {
                        const column = this.rowDescription.columns[i];
                        const rawValue = dataRow[i];
                        if (rawValue === null) {
                            parsedRow.push(null);
                        }
                        else {
                            parsedRow.push(decode_ts_1.decode(rawValue, column));
                        }
                    }
                    return parsedRow;
                }
                handleDataRow(dataRow) {
                    if (this._done) {
                        throw new Error("New data row, after result if done.");
                    }
                    const parsedRow = this._parseDataRow(dataRow);
                    this.rows.push(parsedRow);
                }
                handleCommandComplete(commandTag) {
                    const match = commandTagRegexp.exec(commandTag);
                    if (match) {
                        this.command = match[1];
                        if (match[3]) {
                            this.rowCount = parseInt(match[3], 10);
                        }
                        else {
                            this.rowCount = parseInt(match[2], 10);
                        }
                    }
                }
                rowsOfObjects() {
                    return this.rows.map((row) => {
                        const rv = {};
                        this.rowDescription.columns.forEach((column, index) => {
                            rv[column.name] = row[index];
                        });
                        return rv;
                    });
                }
                done() {
                    this._done = true;
                }
            };
            exports_87("QueryResult", QueryResult);
            Query = class Query {
                constructor(text, ...args) {
                    let config;
                    if (typeof text === "string") {
                        config = { text, args };
                    }
                    else {
                        config = text;
                    }
                    this.text = config.text;
                    this.args = this._prepareArgs(config);
                    this.result = new QueryResult(this);
                }
                _prepareArgs(config) {
                    const encodingFn = config.encoder ? config.encoder : encode_ts_1.encode;
                    return (config.args || []).map(encodingFn);
                }
            };
            exports_87("Query", Query);
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/error", [], function (exports_88, context_88) {
    "use strict";
    var PostgresError;
    var __moduleName = context_88 && context_88.id;
    function parseError(msg) {
        const errorFields = {};
        let byte;
        let char;
        let errorMsg;
        while ((byte = msg.reader.readByte())) {
            char = String.fromCharCode(byte);
            errorMsg = msg.reader.readCString();
            switch (char) {
                case "S":
                    errorFields.severity = errorMsg;
                    break;
                case "C":
                    errorFields.code = errorMsg;
                    break;
                case "M":
                    errorFields.message = errorMsg;
                    break;
                case "D":
                    errorFields.detail = errorMsg;
                    break;
                case "H":
                    errorFields.hint = errorMsg;
                    break;
                case "P":
                    errorFields.position = errorMsg;
                    break;
                case "p":
                    errorFields.internalPosition = errorMsg;
                    break;
                case "q":
                    errorFields.internalQuery = errorMsg;
                    break;
                case "W":
                    errorFields.where = errorMsg;
                    break;
                case "s":
                    errorFields.schema = errorMsg;
                    break;
                case "t":
                    errorFields.table = errorMsg;
                    break;
                case "c":
                    errorFields.column = errorMsg;
                    break;
                case "d":
                    errorFields.dataTypeName = errorMsg;
                    break;
                case "n":
                    errorFields.constraint = errorMsg;
                    break;
                case "F":
                    errorFields.file = errorMsg;
                    break;
                case "L":
                    errorFields.line = errorMsg;
                    break;
                case "R":
                    errorFields.routine = errorMsg;
                    break;
                default:
                    break;
            }
        }
        return new PostgresError(errorFields);
    }
    exports_88("parseError", parseError);
    return {
        setters: [],
        execute: function () {
            PostgresError = class PostgresError extends Error {
                constructor(fields) {
                    super(fields.message);
                    this.fields = fields;
                    this.name = "PostgresError";
                }
            };
            exports_88("PostgresError", PostgresError);
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/connection_params", ["https://deno.land/x/postgres@v0.4.5/utils"], function (exports_89, context_89) {
    "use strict";
    var utils_ts_2, ConnectionParamsError, DEFAULT_OPTIONS;
    var __moduleName = context_89 && context_89.id;
    function getPgEnv() {
        try {
            const env = Deno.env;
            const port = env.get("PGPORT");
            return {
                database: env.get("PGDATABASE"),
                hostname: env.get("PGHOST"),
                port: port !== undefined ? parseInt(port, 10) : undefined,
                user: env.get("PGUSER"),
                password: env.get("PGPASSWORD"),
                applicationName: env.get("PGAPPNAME"),
            };
        }
        catch (e) {
            return {};
        }
    }
    function isDefined(value) {
        return value !== undefined && value !== null;
    }
    function select(sources, key) {
        return sources.map((s) => s[key]).find(isDefined);
    }
    function selectRequired(sources, key) {
        const result = select(sources, key);
        if (!isDefined(result)) {
            throw new ConnectionParamsError(`Required parameter ${key} not provided`);
        }
        return result;
    }
    function assertRequiredOptions(sources, requiredKeys) {
        const missingParams = [];
        for (const key of requiredKeys) {
            if (!isDefined(select(sources, key))) {
                missingParams.push(key);
            }
        }
        if (missingParams.length) {
            throw new ConnectionParamsError(formatMissingParams(missingParams));
        }
    }
    function formatMissingParams(missingParams) {
        return `Missing connection parameters: ${missingParams.join(", ")}. Connection parameters can be read from environment only if Deno is run with env permission (deno run --allow-env)`;
    }
    function parseOptionsFromDsn(connString) {
        const dsn = utils_ts_2.parseDsn(connString);
        if (dsn.driver !== "postgres") {
            throw new Error(`Supplied DSN has invalid driver: ${dsn.driver}.`);
        }
        return {
            ...dsn,
            port: dsn.port ? parseInt(dsn.port, 10) : undefined,
            applicationName: dsn.params.application_name,
        };
    }
    function createParams(config = {}) {
        if (typeof config === "string") {
            const dsn = parseOptionsFromDsn(config);
            return createParams(dsn);
        }
        const pgEnv = getPgEnv();
        const sources = [config, pgEnv, DEFAULT_OPTIONS];
        assertRequiredOptions(sources, ["database", "hostname", "port", "user", "applicationName"]);
        const params = {
            database: selectRequired(sources, "database"),
            hostname: selectRequired(sources, "hostname"),
            port: selectRequired(sources, "port"),
            applicationName: selectRequired(sources, "applicationName"),
            user: selectRequired(sources, "user"),
            password: select(sources, "password"),
        };
        if (isNaN(params.port)) {
            throw new ConnectionParamsError(`Invalid port ${params.port}`);
        }
        return params;
    }
    exports_89("createParams", createParams);
    return {
        setters: [
            function (utils_ts_2_1) {
                utils_ts_2 = utils_ts_2_1;
            }
        ],
        execute: function () {
            ConnectionParamsError = class ConnectionParamsError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "ConnectionParamsError";
                }
            };
            DEFAULT_OPTIONS = {
                hostname: "127.0.0.1",
                port: 5432,
                applicationName: "deno_postgres",
            };
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/deferred", ["https://deno.land/x/postgres@v0.4.5/deps"], function (exports_90, context_90) {
    "use strict";
    var deps_ts_19, DeferredStack;
    var __moduleName = context_90 && context_90.id;
    return {
        setters: [
            function (deps_ts_19_1) {
                deps_ts_19 = deps_ts_19_1;
            }
        ],
        execute: function () {
            DeferredStack = class DeferredStack {
                constructor(max, ls, _creator) {
                    this._creator = _creator;
                    this._maxSize = max || 10;
                    this._array = ls ? [...ls] : [];
                    this._size = this._array.length;
                    this._queue = [];
                }
                async pop() {
                    if (this._array.length > 0) {
                        return this._array.pop();
                    }
                    else if (this._size < this._maxSize && this._creator) {
                        this._size++;
                        return await this._creator();
                    }
                    const d = deps_ts_19.deferred();
                    this._queue.push(d);
                    await d;
                    return this._array.pop();
                }
                push(value) {
                    this._array.push(value);
                    if (this._queue.length > 0) {
                        const d = this._queue.shift();
                        d.resolve();
                    }
                }
                get size() {
                    return this._size;
                }
                get available() {
                    return this._array.length;
                }
            };
            exports_90("DeferredStack", DeferredStack);
        }
    };
});
/*!
 * Substantial parts adapted from https://github.com/brianc/node-postgres
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2010 - 2019 Brian Carlson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/postgres@v0.4.5/connection", ["https://deno.land/x/postgres@v0.4.5/deps", "https://deno.land/x/postgres@v0.4.5/packet_writer", "https://deno.land/x/postgres@v0.4.5/utils", "https://deno.land/x/postgres@v0.4.5/packet_reader", "https://deno.land/x/postgres@v0.4.5/query", "https://deno.land/x/postgres@v0.4.5/error", "https://deno.land/x/postgres@v0.4.5/deferred"], function (exports_91, context_91) {
    "use strict";
    var deps_ts_20, packet_writer_ts_1, utils_ts_3, packet_reader_ts_1, query_ts_1, error_ts_1, deferred_ts_5, Format, TransactionStatus, Message, Column, RowDescription, Connection;
    var __moduleName = context_91 && context_91.id;
    return {
        setters: [
            function (deps_ts_20_1) {
                deps_ts_20 = deps_ts_20_1;
            },
            function (packet_writer_ts_1_1) {
                packet_writer_ts_1 = packet_writer_ts_1_1;
            },
            function (utils_ts_3_1) {
                utils_ts_3 = utils_ts_3_1;
            },
            function (packet_reader_ts_1_1) {
                packet_reader_ts_1 = packet_reader_ts_1_1;
            },
            function (query_ts_1_1) {
                query_ts_1 = query_ts_1_1;
            },
            function (error_ts_1_1) {
                error_ts_1 = error_ts_1_1;
            },
            function (deferred_ts_5_1) {
                deferred_ts_5 = deferred_ts_5_1;
            }
        ],
        execute: function () {
            (function (Format) {
                Format[Format["TEXT"] = 0] = "TEXT";
                Format[Format["BINARY"] = 1] = "BINARY";
            })(Format || (Format = {}));
            exports_91("Format", Format);
            (function (TransactionStatus) {
                TransactionStatus["Idle"] = "I";
                TransactionStatus["IdleInTransaction"] = "T";
                TransactionStatus["InFailedTransaction"] = "E";
            })(TransactionStatus || (TransactionStatus = {}));
            Message = class Message {
                constructor(type, byteCount, body) {
                    this.type = type;
                    this.byteCount = byteCount;
                    this.body = body;
                    this.reader = new packet_reader_ts_1.PacketReader(body);
                }
            };
            exports_91("Message", Message);
            Column = class Column {
                constructor(name, tableOid, index, typeOid, columnLength, typeModifier, format) {
                    this.name = name;
                    this.tableOid = tableOid;
                    this.index = index;
                    this.typeOid = typeOid;
                    this.columnLength = columnLength;
                    this.typeModifier = typeModifier;
                    this.format = format;
                }
            };
            exports_91("Column", Column);
            RowDescription = class RowDescription {
                constructor(columnCount, columns) {
                    this.columnCount = columnCount;
                    this.columns = columns;
                }
            };
            exports_91("RowDescription", RowDescription);
            Connection = class Connection {
                constructor(connParams) {
                    this.connParams = connParams;
                    this.decoder = new TextDecoder();
                    this.encoder = new TextEncoder();
                    this._parameters = {};
                    this._queryLock = new deferred_ts_5.DeferredStack(1, [undefined]);
                }
                async readMessage() {
                    const header = new Uint8Array(5);
                    await this.bufReader.readFull(header);
                    const msgType = this.decoder.decode(header.slice(0, 1));
                    const msgLength = utils_ts_3.readUInt32BE(header, 1) - 4;
                    const msgBody = new Uint8Array(msgLength);
                    await this.bufReader.readFull(msgBody);
                    return new Message(msgType, msgLength, msgBody);
                }
                async _sendStartupMessage() {
                    const writer = this.packetWriter;
                    writer.clear();
                    writer.addInt16(3).addInt16(0);
                    const connParams = this.connParams;
                    writer.addCString("user").addCString(connParams.user);
                    writer.addCString("database").addCString(connParams.database);
                    writer.addCString("application_name").addCString(connParams.applicationName);
                    writer.addCString("client_encoding").addCString("'utf-8'");
                    writer.addCString("");
                    const bodyBuffer = writer.flush();
                    const bodyLength = bodyBuffer.length + 4;
                    writer.clear();
                    const finalBuffer = writer
                        .addInt32(bodyLength)
                        .add(bodyBuffer)
                        .join();
                    await this.bufWriter.write(finalBuffer);
                }
                async startup() {
                    const { port, hostname } = this.connParams;
                    this.conn = await Deno.connect({ port, hostname });
                    this.bufReader = new deps_ts_20.BufReader(this.conn);
                    this.bufWriter = new deps_ts_20.BufWriter(this.conn);
                    this.packetWriter = new packet_writer_ts_1.PacketWriter();
                    await this._sendStartupMessage();
                    await this.bufWriter.flush();
                    let msg;
                    msg = await this.readMessage();
                    await this.handleAuth(msg);
                    while (true) {
                        msg = await this.readMessage();
                        switch (msg.type) {
                            case "K":
                                this._processBackendKeyData(msg);
                                break;
                            case "S":
                                this._processParameterStatus(msg);
                                break;
                            case "Z":
                                this._processReadyForQuery(msg);
                                return;
                            default:
                                throw new Error(`Unknown response for startup: ${msg.type}`);
                        }
                    }
                }
                async handleAuth(msg) {
                    const code = msg.reader.readInt32();
                    switch (code) {
                        case 0:
                            break;
                        case 3:
                            await this._authCleartext();
                            await this._readAuthResponse();
                            break;
                        case 5: {
                            const salt = msg.reader.readBytes(4);
                            await this._authMd5(salt);
                            await this._readAuthResponse();
                            break;
                        }
                        default:
                            throw new Error(`Unknown auth message code ${code}`);
                    }
                }
                async _readAuthResponse() {
                    const msg = await this.readMessage();
                    if (msg.type === "E") {
                        throw error_ts_1.parseError(msg);
                    }
                    else if (msg.type !== "R") {
                        throw new Error(`Unexpected auth response: ${msg.type}.`);
                    }
                    const responseCode = msg.reader.readInt32();
                    if (responseCode !== 0) {
                        throw new Error(`Unexpected auth response code: ${responseCode}.`);
                    }
                }
                async _authCleartext() {
                    this.packetWriter.clear();
                    const password = this.connParams.password || "";
                    const buffer = this.packetWriter.addCString(password).flush(0x70);
                    await this.bufWriter.write(buffer);
                    await this.bufWriter.flush();
                }
                async _authMd5(salt) {
                    this.packetWriter.clear();
                    if (!this.connParams.password) {
                        throw new Error("Auth Error: attempting MD5 auth with password unset");
                    }
                    const password = utils_ts_3.hashMd5Password(this.connParams.password, this.connParams.user, salt);
                    const buffer = this.packetWriter.addCString(password).flush(0x70);
                    await this.bufWriter.write(buffer);
                    await this.bufWriter.flush();
                }
                _processBackendKeyData(msg) {
                    this._pid = msg.reader.readInt32();
                    this._secretKey = msg.reader.readInt32();
                }
                _processParameterStatus(msg) {
                    const key = msg.reader.readCString();
                    const value = msg.reader.readCString();
                    this._parameters[key] = value;
                }
                _processReadyForQuery(msg) {
                    const txStatus = msg.reader.readByte();
                    this._transactionStatus = String.fromCharCode(txStatus);
                }
                async _readReadyForQuery() {
                    const msg = await this.readMessage();
                    if (msg.type !== "Z") {
                        throw new Error(`Unexpected message type: ${msg.type}, expected "Z" (ReadyForQuery)`);
                    }
                    this._processReadyForQuery(msg);
                }
                async _simpleQuery(query) {
                    this.packetWriter.clear();
                    const buffer = this.packetWriter.addCString(query.text).flush(0x51);
                    await this.bufWriter.write(buffer);
                    await this.bufWriter.flush();
                    const result = query.result;
                    let msg;
                    msg = await this.readMessage();
                    switch (msg.type) {
                        case "T":
                            result.handleRowDescription(this._processRowDescription(msg));
                            break;
                        case "n":
                            break;
                        case "E":
                            await this._processError(msg);
                            break;
                        case "N":
                            console.log("TODO: handle notice");
                            break;
                        case "C": {
                            const commandTag = this._readCommandTag(msg);
                            result.handleCommandComplete(commandTag);
                            result.done();
                            break;
                        }
                        default:
                            throw new Error(`Unexpected frame: ${msg.type}`);
                    }
                    while (true) {
                        msg = await this.readMessage();
                        switch (msg.type) {
                            case "D": {
                                const foo = this._readDataRow(msg);
                                result.handleDataRow(foo);
                                break;
                            }
                            case "C": {
                                const commandTag = this._readCommandTag(msg);
                                result.handleCommandComplete(commandTag);
                                result.done();
                                break;
                            }
                            case "Z":
                                this._processReadyForQuery(msg);
                                return result;
                            case "E":
                                await this._processError(msg);
                                break;
                            default:
                                throw new Error(`Unexpected frame: ${msg.type}`);
                        }
                    }
                }
                async _sendPrepareMessage(query) {
                    this.packetWriter.clear();
                    const buffer = this.packetWriter
                        .addCString("")
                        .addCString(query.text)
                        .addInt16(0)
                        .flush(0x50);
                    await this.bufWriter.write(buffer);
                }
                async _sendBindMessage(query) {
                    this.packetWriter.clear();
                    const hasBinaryArgs = query.args.reduce((prev, curr) => {
                        return prev || curr instanceof Uint8Array;
                    }, false);
                    this.packetWriter.clear();
                    this.packetWriter
                        .addCString("")
                        .addCString("");
                    if (hasBinaryArgs) {
                        this.packetWriter.addInt16(query.args.length);
                        query.args.forEach((arg) => {
                            this.packetWriter.addInt16(arg instanceof Uint8Array ? 1 : 0);
                        });
                    }
                    else {
                        this.packetWriter.addInt16(0);
                    }
                    this.packetWriter.addInt16(query.args.length);
                    query.args.forEach((arg) => {
                        if (arg === null || typeof arg === "undefined") {
                            this.packetWriter.addInt32(-1);
                        }
                        else if (arg instanceof Uint8Array) {
                            this.packetWriter.addInt32(arg.length);
                            this.packetWriter.add(arg);
                        }
                        else {
                            const byteLength = this.encoder.encode(arg).length;
                            this.packetWriter.addInt32(byteLength);
                            this.packetWriter.addString(arg);
                        }
                    });
                    this.packetWriter.addInt16(0);
                    const buffer = this.packetWriter.flush(0x42);
                    await this.bufWriter.write(buffer);
                }
                async _sendDescribeMessage() {
                    this.packetWriter.clear();
                    const buffer = this.packetWriter.addCString("P").flush(0x44);
                    await this.bufWriter.write(buffer);
                }
                async _sendExecuteMessage() {
                    this.packetWriter.clear();
                    const buffer = this.packetWriter
                        .addCString("")
                        .addInt32(0)
                        .flush(0x45);
                    await this.bufWriter.write(buffer);
                }
                async _sendFlushMessage() {
                    this.packetWriter.clear();
                    const buffer = this.packetWriter.flush(0x48);
                    await this.bufWriter.write(buffer);
                }
                async _sendSyncMessage() {
                    this.packetWriter.clear();
                    const buffer = this.packetWriter.flush(0x53);
                    await this.bufWriter.write(buffer);
                }
                async _processError(msg) {
                    const error = error_ts_1.parseError(msg);
                    await this._readReadyForQuery();
                    throw error;
                }
                async _readParseComplete() {
                    const msg = await this.readMessage();
                    switch (msg.type) {
                        case "1":
                            break;
                        case "E":
                            await this._processError(msg);
                            break;
                        default:
                            throw new Error(`Unexpected frame: ${msg.type}`);
                    }
                }
                async _readBindComplete() {
                    const msg = await this.readMessage();
                    switch (msg.type) {
                        case "2":
                            break;
                        case "E":
                            await this._processError(msg);
                            break;
                        default:
                            throw new Error(`Unexpected frame: ${msg.type}`);
                    }
                }
                async _preparedQuery(query) {
                    await this._sendPrepareMessage(query);
                    await this._sendBindMessage(query);
                    await this._sendDescribeMessage();
                    await this._sendExecuteMessage();
                    await this._sendSyncMessage();
                    await this.bufWriter.flush();
                    await this._readParseComplete();
                    await this._readBindComplete();
                    const result = query.result;
                    let msg;
                    msg = await this.readMessage();
                    switch (msg.type) {
                        case "T": {
                            const rowDescription = this._processRowDescription(msg);
                            result.handleRowDescription(rowDescription);
                            break;
                        }
                        case "n":
                            break;
                        case "E":
                            await this._processError(msg);
                            break;
                        default:
                            throw new Error(`Unexpected frame: ${msg.type}`);
                    }
                    outerLoop: while (true) {
                        msg = await this.readMessage();
                        switch (msg.type) {
                            case "D": {
                                const rawDataRow = this._readDataRow(msg);
                                result.handleDataRow(rawDataRow);
                                break;
                            }
                            case "C": {
                                const commandTag = this._readCommandTag(msg);
                                result.handleCommandComplete(commandTag);
                                result.done();
                                break outerLoop;
                            }
                            case "E":
                                await this._processError(msg);
                                break;
                            default:
                                throw new Error(`Unexpected frame: ${msg.type}`);
                        }
                    }
                    await this._readReadyForQuery();
                    return result;
                }
                async query(query) {
                    await this._queryLock.pop();
                    try {
                        if (query.args.length === 0) {
                            return await this._simpleQuery(query);
                        }
                        else {
                            return await this._preparedQuery(query);
                        }
                    }
                    finally {
                        this._queryLock.push(undefined);
                    }
                }
                _processRowDescription(msg) {
                    const columnCount = msg.reader.readInt16();
                    const columns = [];
                    for (let i = 0; i < columnCount; i++) {
                        const column = new Column(msg.reader.readCString(), msg.reader.readInt32(), msg.reader.readInt16(), msg.reader.readInt32(), msg.reader.readInt16(), msg.reader.readInt32(), msg.reader.readInt16());
                        columns.push(column);
                    }
                    return new RowDescription(columnCount, columns);
                }
                _readDataRow(msg) {
                    const fieldCount = msg.reader.readInt16();
                    const row = [];
                    for (let i = 0; i < fieldCount; i++) {
                        const colLength = msg.reader.readInt32();
                        if (colLength == -1) {
                            row.push(null);
                            continue;
                        }
                        row.push(msg.reader.readBytes(colLength));
                    }
                    return row;
                }
                _readCommandTag(msg) {
                    return msg.reader.readString(msg.byteCount);
                }
                async initSQL() {
                    const config = { text: "select 1;", args: [] };
                    const query = new query_ts_1.Query(config);
                    await this.query(query);
                }
                async end() {
                    const terminationMessage = new Uint8Array([0x58, 0x00, 0x00, 0x00, 0x04]);
                    await this.bufWriter.write(terminationMessage);
                    await this.bufWriter.flush();
                    this.conn.close();
                }
            };
            exports_91("Connection", Connection);
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/client", ["https://deno.land/x/postgres@v0.4.5/connection", "https://deno.land/x/postgres@v0.4.5/connection_params", "https://deno.land/x/postgres@v0.4.5/query"], function (exports_92, context_92) {
    "use strict";
    var connection_ts_2, connection_params_ts_1, query_ts_2, Client, PoolClient;
    var __moduleName = context_92 && context_92.id;
    return {
        setters: [
            function (connection_ts_2_1) {
                connection_ts_2 = connection_ts_2_1;
            },
            function (connection_params_ts_1_1) {
                connection_params_ts_1 = connection_params_ts_1_1;
            },
            function (query_ts_2_1) {
                query_ts_2 = query_ts_2_1;
            }
        ],
        execute: function () {
            Client = class Client {
                constructor(config) {
                    this._aenter = this.connect;
                    this._aexit = this.end;
                    const connectionParams = connection_params_ts_1.createParams(config);
                    this._connection = new connection_ts_2.Connection(connectionParams);
                }
                async connect() {
                    await this._connection.startup();
                    await this._connection.initSQL();
                }
                async query(text, ...args) {
                    const query = new query_ts_2.Query(text, ...args);
                    return await this._connection.query(query);
                }
                async multiQuery(queries) {
                    const result = [];
                    for (const query of queries) {
                        result.push(await this.query(query));
                    }
                    return result;
                }
                async end() {
                    await this._connection.end();
                }
            };
            exports_92("Client", Client);
            PoolClient = class PoolClient {
                constructor(connection, releaseCallback) {
                    this._connection = connection;
                    this._releaseCallback = releaseCallback;
                }
                async query(text, ...args) {
                    const query = new query_ts_2.Query(text, ...args);
                    return await this._connection.query(query);
                }
                async release() {
                    await this._releaseCallback();
                }
            };
            exports_92("PoolClient", PoolClient);
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/pool", ["https://deno.land/x/postgres@v0.4.5/client", "https://deno.land/x/postgres@v0.4.5/connection", "https://deno.land/x/postgres@v0.4.5/connection_params", "https://deno.land/x/postgres@v0.4.5/deferred", "https://deno.land/x/postgres@v0.4.5/query"], function (exports_93, context_93) {
    "use strict";
    var client_ts_1, connection_ts_3, connection_params_ts_2, deferred_ts_6, query_ts_3, Pool;
    var __moduleName = context_93 && context_93.id;
    return {
        setters: [
            function (client_ts_1_1) {
                client_ts_1 = client_ts_1_1;
            },
            function (connection_ts_3_1) {
                connection_ts_3 = connection_ts_3_1;
            },
            function (connection_params_ts_2_1) {
                connection_params_ts_2 = connection_params_ts_2_1;
            },
            function (deferred_ts_6_1) {
                deferred_ts_6 = deferred_ts_6_1;
            },
            function (query_ts_3_1) {
                query_ts_3 = query_ts_3_1;
            }
        ],
        execute: function () {
            Pool = class Pool {
                constructor(connectionParams, maxSize, lazy) {
                    this._aenter = () => { };
                    this._aexit = this.end;
                    this._connectionParams = connection_params_ts_2.createParams(connectionParams);
                    this._maxSize = maxSize;
                    this._lazy = !!lazy;
                    this.ready = this._startup();
                }
                async _createConnection() {
                    const connection = new connection_ts_3.Connection(this._connectionParams);
                    await connection.startup();
                    await connection.initSQL();
                    return connection;
                }
                get maxSize() {
                    return this._maxSize;
                }
                get size() {
                    if (this._availableConnections == null) {
                        return 0;
                    }
                    return this._availableConnections.size;
                }
                get available() {
                    if (this._availableConnections == null) {
                        return 0;
                    }
                    return this._availableConnections.available;
                }
                async _startup() {
                    const initSize = this._lazy ? 1 : this._maxSize;
                    const connecting = [...Array(initSize)].map(async () => await this._createConnection());
                    this._connections = await Promise.all(connecting);
                    this._availableConnections = new deferred_ts_6.DeferredStack(this._maxSize, this._connections, this._createConnection.bind(this));
                }
                async _execute(query) {
                    await this.ready;
                    const connection = await this._availableConnections.pop();
                    try {
                        const result = await connection.query(query);
                        return result;
                    }
                    catch (error) {
                        throw error;
                    }
                    finally {
                        this._availableConnections.push(connection);
                    }
                }
                async connect() {
                    await this.ready;
                    const connection = await this._availableConnections.pop();
                    const release = () => this._availableConnections.push(connection);
                    return new client_ts_1.PoolClient(connection, release);
                }
                async query(text, ...args) {
                    const query = new query_ts_3.Query(text, ...args);
                    return await this._execute(query);
                }
                async end() {
                    await this.ready;
                    while (this.available > 0) {
                        const conn = await this._availableConnections.pop();
                        await conn.end();
                    }
                }
            };
            exports_93("Pool", Pool);
        }
    };
});
System.register("https://deno.land/x/postgres@v0.4.5/mod", ["https://deno.land/x/postgres@v0.4.5/client", "https://deno.land/x/postgres@v0.4.5/error", "https://deno.land/x/postgres@v0.4.5/pool"], function (exports_94, context_94) {
    "use strict";
    var __moduleName = context_94 && context_94.id;
    return {
        setters: [
            function (client_ts_2_1) {
                exports_94({
                    "Client": client_ts_2_1["Client"]
                });
            },
            function (error_ts_2_1) {
                exports_94({
                    "PostgresError": error_ts_2_1["PostgresError"]
                });
            },
            function (pool_ts_2_1) {
                exports_94({
                    "Pool": pool_ts_2_1["Pool"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/config", [], function (exports_95, context_95) {
    "use strict";
    var connString, key;
    var __moduleName = context_95 && context_95.id;
    return {
        setters: [],
        execute: function () {
            connString = {
                user: "ak",
                database: "postgres",
                hostname: "localhost",
                port: 5432,
                password: "ak",
            };
            exports_95("connString", connString);
            key = "qwerty1234";
            exports_95("key", key);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/database/DbConnection", ["https://deno.land/x/postgres@v0.4.5/mod", "file:///home/ak/dev/backend/deno_api/practice/config"], function (exports_96, context_96) {
    "use strict";
    var mod_ts_17, config_ts_1, DbConnection;
    var __moduleName = context_96 && context_96.id;
    return {
        setters: [
            function (mod_ts_17_1) {
                mod_ts_17 = mod_ts_17_1;
            },
            function (config_ts_1_1) {
                config_ts_1 = config_ts_1_1;
            }
        ],
        execute: function () {
            DbConnection = class DbConnection {
                constructor() {
                    this.Connect();
                }
                async Connect() {
                    this.client = new mod_ts_17.Client(config_ts_1.connString);
                    await this.client.connect();
                }
            };
            exports_96("default", new DbConnection().client);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/repository/CustomerRepo", ["file:///home/ak/dev/backend/deno_api/practice/database/DbConnection"], function (exports_97, context_97) {
    "use strict";
    var DbConnection_ts_1, CustomerRepo;
    var __moduleName = context_97 && context_97.id;
    return {
        setters: [
            function (DbConnection_ts_1_1) {
                DbConnection_ts_1 = DbConnection_ts_1_1;
            }
        ],
        execute: function () {
            CustomerRepo = class CustomerRepo {
                async getCustomers() {
                    const result = await DbConnection_ts_1.default.query("select * from customer;");
                    return result.rows;
                }
                async getCustomer(id) {
                    const result = await DbConnection_ts_1.default.query("select * from customer where customerid=$1;", id);
                    return result.rows;
                }
                async addCustomer(customer) {
                    const result = await DbConnection_ts_1.default.query("insert into customer(companyname,city,country) values($1,$2,$3)", customer.name, customer.city, customer.country);
                    return customer;
                }
                async updateCustomer(id, customer) {
                    await DbConnection_ts_1.default.query("update customer set companyname=$1,city=$2,country=$3 where customerid=$4", customer.name, customer.city, customer.country);
                    return customer;
                }
                async deleteCustomer(id) {
                    await DbConnection_ts_1.default.query("delete from customer where customerid=$1", id);
                }
            };
            exports_97("default", new CustomerRepo());
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/controllers/CustomerController", ["file:///home/ak/dev/backend/deno_api/practice/repository/CustomerRepo"], function (exports_98, context_98) {
    "use strict";
    var CustomerRepo_ts_1, getCustomers, getCustomer, addCustomer, updateCustomer, deleteCustomer;
    var __moduleName = context_98 && context_98.id;
    return {
        setters: [
            function (CustomerRepo_ts_1_1) {
                CustomerRepo_ts_1 = CustomerRepo_ts_1_1;
            }
        ],
        execute: function () {
            getCustomers = async ({ response }) => {
                try {
                    const result = await CustomerRepo_ts_1.default.getCustomers();
                    response.status = 200;
                    response.body = result;
                }
                catch (error) {
                    response.status = 500;
                    response.body = {
                        err: error.toString(),
                    };
                }
            };
            exports_98("getCustomers", getCustomers);
            getCustomer = async ({ params, response }) => {
                try {
                    const result = await CustomerRepo_ts_1.default.getCustomer(params.id);
                    if (result.toString() === "") {
                        response.status = 404;
                        response.body = { err: "Customer " + params.id + " is not registered" };
                        return;
                    }
                    else {
                        response.status = result;
                        response.status = 200;
                    }
                }
                catch (error) {
                    response.status = 500;
                    response.body = { err: error.toString() };
                }
            };
            exports_98("getCustomer", getCustomer);
            addCustomer = async ({ request, response }) => {
                const body = await request.body();
                const customer = await body.value;
                if (customer.name === "") {
                    response.body = {
                        err: "Name cannot be empty",
                    };
                    response.status = 500;
                    return;
                }
                try {
                    const result = await CustomerRepo_ts_1.default.addCustomer(customer);
                    response.body = result;
                    response.status = 201;
                }
                catch (error) {
                    response.status = 500;
                    response.body = { err: error.message };
                }
            };
            exports_98("addCustomer", addCustomer);
            updateCustomer = async ({ params, request, response }) => {
                await getCustomer({ params: { "id": params.id }, response });
                if (response.status === 404) {
                    const errMsg = response.body.err;
                    response.body = { err: errMsg };
                    response.status = 404;
                    return;
                }
                else {
                    const body = await request.body();
                    const customer = await body.value;
                    if (customer.name === "" || customer.name == null) {
                        response.body = { err: "Name cannot be empty" };
                        response.status = 500;
                        return;
                    }
                    try {
                        const result = await CustomerRepo_ts_1.default.updateCustomer(params.id, customer);
                        response.body = result;
                        response.status = 200;
                    }
                    catch (error) {
                        response.status = 500;
                        response.body = { err: error.message };
                    }
                }
            };
            exports_98("updateCustomer", updateCustomer);
            deleteCustomer = async ({ params, response }) => {
                await getCustomer({ params: { "id": params.id }, response });
                if (response.status === 404) {
                    const errMsg = response.body.err;
                    response.status = 404;
                    response.body = { err: errMsg };
                    return;
                }
                try {
                    await CustomerRepo_ts_1.default.deleteCustomer(params.id);
                    response.body = { msg: "Customer id:" + params.id + " has been deleted." };
                    response.status = 204;
                }
                catch (error) {
                    response.status = 500;
                    response.body = { err: error.message };
                }
            };
            exports_98("deleteCustomer", deleteCustomer);
        }
    };
});
System.register("https://deno.land/x/djwt@v1.7/base64/base64", [], function (exports_99, context_99) {
    "use strict";
    var __moduleName = context_99 && context_99.id;
    function convertBase64ToUint8Array(data) {
        const binString = atob(data);
        const size = binString.length;
        const bytes = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            bytes[i] = binString.charCodeAt(i);
        }
        return bytes;
    }
    exports_99("convertBase64ToUint8Array", convertBase64ToUint8Array);
    function convertUint8ArrayToBase64(bytes) {
        const base64abc = (() => {
            const abc = [], A = "A".charCodeAt(0), a = "a".charCodeAt(0), n = "0".charCodeAt(0);
            for (let i = 0; i < 26; ++i) {
                abc.push(String.fromCharCode(A + i));
            }
            for (let i = 0; i < 26; ++i) {
                abc.push(String.fromCharCode(a + i));
            }
            for (let i = 0; i < 10; ++i) {
                abc.push(String.fromCharCode(n + i));
            }
            abc.push("+");
            abc.push("/");
            return abc;
        })();
        let result = "", i, l = bytes.length;
        for (i = 2; i < l; i += 3) {
            result += base64abc[bytes[i - 2] >> 2];
            result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
            result += base64abc[((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6)];
            result += base64abc[bytes[i] & 0x3f];
        }
        if (i === l + 1) {
            result += base64abc[bytes[i - 2] >> 2];
            result += base64abc[(bytes[i - 2] & 0x03) << 4];
            result += "==";
        }
        if (i === l) {
            result += base64abc[bytes[i - 2] >> 2];
            result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
            result += base64abc[(bytes[i - 1] & 0x0f) << 2];
            result += "=";
        }
        return result;
    }
    exports_99("convertUint8ArrayToBase64", convertUint8ArrayToBase64);
    function convertStringToBase64(str) {
        return btoa(unescape(encodeURIComponent(str)));
    }
    exports_99("convertStringToBase64", convertStringToBase64);
    function convertBase64ToString(str) {
        return decodeURIComponent(escape(atob(str)));
    }
    exports_99("convertBase64ToString", convertBase64ToString);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.69.0/encoding/hex", [], function (exports_100, context_100) {
    "use strict";
    var hextable;
    var __moduleName = context_100 && context_100.id;
    function errInvalidByte(byte) {
        return new Error("encoding/hex: invalid byte: " +
            new TextDecoder().decode(new Uint8Array([byte])));
    }
    exports_100("errInvalidByte", errInvalidByte);
    function errLength() {
        return new Error("encoding/hex: odd length hex string");
    }
    exports_100("errLength", errLength);
    function fromHexChar(byte) {
        if (48 <= byte && byte <= 57)
            return byte - 48;
        if (97 <= byte && byte <= 102)
            return byte - 97 + 10;
        if (65 <= byte && byte <= 70)
            return byte - 65 + 10;
        throw errInvalidByte(byte);
    }
    function encodedLen(n) {
        return n * 2;
    }
    exports_100("encodedLen", encodedLen);
    function encode(src) {
        const dst = new Uint8Array(encodedLen(src.length));
        for (let i = 0; i < dst.length; i++) {
            const v = src[i];
            dst[i * 2] = hextable[v >> 4];
            dst[i * 2 + 1] = hextable[v & 0x0f];
        }
        return dst;
    }
    exports_100("encode", encode);
    function encodeToString(src) {
        return new TextDecoder().decode(encode(src));
    }
    exports_100("encodeToString", encodeToString);
    function decode(src) {
        const dst = new Uint8Array(decodedLen(src.length));
        for (let i = 0; i < dst.length; i++) {
            const a = fromHexChar(src[i * 2]);
            const b = fromHexChar(src[i * 2 + 1]);
            dst[i] = (a << 4) | b;
        }
        if (src.length % 2 == 1) {
            fromHexChar(src[dst.length * 2]);
            throw errLength();
        }
        return dst;
    }
    exports_100("decode", decode);
    function decodedLen(x) {
        return x >>> 1;
    }
    exports_100("decodedLen", decodedLen);
    function decodeString(s) {
        return decode(new TextEncoder().encode(s));
    }
    exports_100("decodeString", decodeString);
    return {
        setters: [],
        execute: function () {
            hextable = new TextEncoder().encode("0123456789abcdef");
        }
    };
});
System.register("https://deno.land/std@0.69.0/hash/sha256", [], function (exports_101, context_101) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha256, HmacSha256;
    var __moduleName = context_101 && context_101.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
                0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
                0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
                0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
                0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
                0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
            blocks = [];
            Sha256 = class Sha256 {
                constructor(is224 = false, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(is224, sharedMemory);
                }
                #block;
                #blocks;
                #bytes;
                #finalized;
                #first;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #h5;
                #h6;
                #h7;
                #hashed;
                #hBytes;
                #is224;
                #lastByteIndex;
                #start;
                init(is224, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (is224) {
                        this.#h0 = 0xc1059ed8;
                        this.#h1 = 0x367cd507;
                        this.#h2 = 0x3070dd17;
                        this.#h3 = 0xf70e5939;
                        this.#h4 = 0xffc00b31;
                        this.#h5 = 0x68581511;
                        this.#h6 = 0x64f98fa7;
                        this.#h7 = 0xbefa4fa4;
                    }
                    else {
                        this.#h0 = 0x6a09e667;
                        this.#h1 = 0xbb67ae85;
                        this.#h2 = 0x3c6ef372;
                        this.#h3 = 0xa54ff53a;
                        this.#h4 = 0x510e527f;
                        this.#h5 = 0x9b05688c;
                        this.#h6 = 0x1f83d9ab;
                        this.#h7 = 0x5be0cd19;
                    }
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                    this.#first = true;
                    this.#is224 = is224;
                }
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 +
                                        (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f = this.#h5;
                    let g = this.#h6;
                    let h = this.#h7;
                    const blocks = this.#blocks;
                    let s0;
                    let s1;
                    let maj;
                    let t1;
                    let t2;
                    let ch;
                    let ab;
                    let da;
                    let cd;
                    let bc;
                    for (let j = 16; j < 64; ++j) {
                        t1 = blocks[j - 15];
                        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
                        t1 = blocks[j - 2];
                        s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^
                            (t1 >>> 10);
                        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
                    }
                    bc = b & c;
                    for (let j = 0; j < 64; j += 4) {
                        if (this.#first) {
                            if (this.#is224) {
                                ab = 300032;
                                t1 = blocks[0] - 1413257819;
                                h = (t1 - 150054599) << 0;
                                d = (t1 + 24177077) << 0;
                            }
                            else {
                                ab = 704751109;
                                t1 = blocks[0] - 210244248;
                                h = (t1 - 1521486534) << 0;
                                d = (t1 + 143694565) << 0;
                            }
                            this.#first = false;
                        }
                        else {
                            s0 = ((a >>> 2) | (a << 30)) ^
                                ((a >>> 13) | (a << 19)) ^
                                ((a >>> 22) | (a << 10));
                            s1 = ((e >>> 6) | (e << 26)) ^
                                ((e >>> 11) | (e << 21)) ^
                                ((e >>> 25) | (e << 7));
                            ab = a & b;
                            maj = ab ^ (a & c) ^ bc;
                            ch = (e & f) ^ (~e & g);
                            t1 = h + s1 + ch + K[j] + blocks[j];
                            t2 = s0 + maj;
                            h = (d + t1) << 0;
                            d = (t1 + t2) << 0;
                        }
                        s0 = ((d >>> 2) | (d << 30)) ^
                            ((d >>> 13) | (d << 19)) ^
                            ((d >>> 22) | (d << 10));
                        s1 = ((h >>> 6) | (h << 26)) ^
                            ((h >>> 11) | (h << 21)) ^
                            ((h >>> 25) | (h << 7));
                        da = d & a;
                        maj = da ^ (d & b) ^ ab;
                        ch = (h & e) ^ (~h & f);
                        t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
                        t2 = s0 + maj;
                        g = (c + t1) << 0;
                        c = (t1 + t2) << 0;
                        s0 = ((c >>> 2) | (c << 30)) ^
                            ((c >>> 13) | (c << 19)) ^
                            ((c >>> 22) | (c << 10));
                        s1 = ((g >>> 6) | (g << 26)) ^
                            ((g >>> 11) | (g << 21)) ^
                            ((g >>> 25) | (g << 7));
                        cd = c & d;
                        maj = cd ^ (c & a) ^ da;
                        ch = (g & h) ^ (~g & e);
                        t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
                        t2 = s0 + maj;
                        f = (b + t1) << 0;
                        b = (t1 + t2) << 0;
                        s0 = ((b >>> 2) | (b << 30)) ^
                            ((b >>> 13) | (b << 19)) ^
                            ((b >>> 22) | (b << 10));
                        s1 = ((f >>> 6) | (f << 26)) ^
                            ((f >>> 11) | (f << 21)) ^
                            ((f >>> 25) | (f << 7));
                        bc = b & c;
                        maj = bc ^ (b & d) ^ cd;
                        ch = (f & g) ^ (~f & h);
                        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
                        t2 = s0 + maj;
                        e = (a + t1) << 0;
                        a = (t1 + t2) << 0;
                    }
                    this.#h0 = (this.#h0 + a) << 0;
                    this.#h1 = (this.#h1 + b) << 0;
                    this.#h2 = (this.#h2 + c) << 0;
                    this.#h3 = (this.#h3 + d) << 0;
                    this.#h4 = (this.#h4 + e) << 0;
                    this.#h5 = (this.#h5 + f) << 0;
                    this.#h6 = (this.#h6 + g) << 0;
                    this.#h7 = (this.#h7 + h) << 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    let hex = HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f] +
                        HEX_CHARS[(h5 >> 28) & 0x0f] +
                        HEX_CHARS[(h5 >> 24) & 0x0f] +
                        HEX_CHARS[(h5 >> 20) & 0x0f] +
                        HEX_CHARS[(h5 >> 16) & 0x0f] +
                        HEX_CHARS[(h5 >> 12) & 0x0f] +
                        HEX_CHARS[(h5 >> 8) & 0x0f] +
                        HEX_CHARS[(h5 >> 4) & 0x0f] +
                        HEX_CHARS[h5 & 0x0f] +
                        HEX_CHARS[(h6 >> 28) & 0x0f] +
                        HEX_CHARS[(h6 >> 24) & 0x0f] +
                        HEX_CHARS[(h6 >> 20) & 0x0f] +
                        HEX_CHARS[(h6 >> 16) & 0x0f] +
                        HEX_CHARS[(h6 >> 12) & 0x0f] +
                        HEX_CHARS[(h6 >> 8) & 0x0f] +
                        HEX_CHARS[(h6 >> 4) & 0x0f] +
                        HEX_CHARS[h6 & 0x0f];
                    if (!this.#is224) {
                        hex += HEX_CHARS[(h7 >> 28) & 0x0f] +
                            HEX_CHARS[(h7 >> 24) & 0x0f] +
                            HEX_CHARS[(h7 >> 20) & 0x0f] +
                            HEX_CHARS[(h7 >> 16) & 0x0f] +
                            HEX_CHARS[(h7 >> 12) & 0x0f] +
                            HEX_CHARS[(h7 >> 8) & 0x0f] +
                            HEX_CHARS[(h7 >> 4) & 0x0f] +
                            HEX_CHARS[h7 & 0x0f];
                    }
                    return hex;
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    const arr = [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                        (h5 >> 24) & 0xff,
                        (h5 >> 16) & 0xff,
                        (h5 >> 8) & 0xff,
                        h5 & 0xff,
                        (h6 >> 24) & 0xff,
                        (h6 >> 16) & 0xff,
                        (h6 >> 8) & 0xff,
                        h6 & 0xff,
                    ];
                    if (!this.#is224) {
                        arr.push((h7 >> 24) & 0xff, (h7 >> 16) & 0xff, (h7 >> 8) & 0xff, h7 & 0xff);
                    }
                    return arr;
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(this.#is224 ? 28 : 32);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    dataView.setUint32(20, this.#h5);
                    dataView.setUint32(24, this.#h6);
                    if (!this.#is224) {
                        dataView.setUint32(28, this.#h7);
                    }
                    return buffer;
                }
            };
            exports_101("Sha256", Sha256);
            HmacSha256 = class HmacSha256 extends Sha256 {
                constructor(secretKey, is224 = false, sharedMemory = false) {
                    super(is224, sharedMemory);
                    let key;
                    if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        for (let i = 0; i < length; ++i) {
                            let code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code = 0x10000 +
                                    (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        if (secretKey instanceof ArrayBuffer) {
                            key = new Uint8Array(secretKey);
                        }
                        else {
                            key = secretKey;
                        }
                    }
                    if (key.length > 64) {
                        key = new Sha256(is224, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 64; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#oKeyPad = oKeyPad;
                    this.#inner = true;
                    this.#is224 = is224;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #is224;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#is224, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_101("HmacSha256", HmacSha256);
        }
    };
});
System.register("https://deno.land/std@0.69.0/hash/sha512", [], function (exports_102, context_102) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha512, HmacSha512;
    var __moduleName = context_102 && context_102.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            K = [
                0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b,
                0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242,
                0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe,
                0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
                0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc,
                0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f,
                0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967,
                0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
                0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1,
                0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218,
                0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08,
                0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
                0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814,
                0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915,
                0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f,
                0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
                0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be,
                0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
            ];
            blocks = [];
            Sha512 = class Sha512 {
                constructor(bits = 512, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(bits, sharedMemory);
                }
                #blocks;
                #block;
                #bits;
                #start;
                #bytes;
                #hBytes;
                #lastByteIndex;
                #finalized;
                #hashed;
                #h0h;
                #h0l;
                #h1h;
                #h1l;
                #h2h;
                #h2l;
                #h3h;
                #h3l;
                #h4h;
                #h4l;
                #h5h;
                #h5l;
                #h6h;
                #h6l;
                #h7h;
                #h7l;
                init(bits, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] =
                            blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] =
                                blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] =
                                    blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks =
                            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (bits === 224) {
                        this.#h0h = 0x8c3d37c8;
                        this.#h0l = 0x19544da2;
                        this.#h1h = 0x73e19966;
                        this.#h1l = 0x89dcd4d6;
                        this.#h2h = 0x1dfab7ae;
                        this.#h2l = 0x32ff9c82;
                        this.#h3h = 0x679dd514;
                        this.#h3l = 0x582f9fcf;
                        this.#h4h = 0x0f6d2b69;
                        this.#h4l = 0x7bd44da8;
                        this.#h5h = 0x77e36f73;
                        this.#h5l = 0x04c48942;
                        this.#h6h = 0x3f9d85a8;
                        this.#h6l = 0x6a1d36c8;
                        this.#h7h = 0x1112e6ad;
                        this.#h7l = 0x91d692a1;
                    }
                    else if (bits === 256) {
                        this.#h0h = 0x22312194;
                        this.#h0l = 0xfc2bf72c;
                        this.#h1h = 0x9f555fa3;
                        this.#h1l = 0xc84c64c2;
                        this.#h2h = 0x2393b86b;
                        this.#h2l = 0x6f53b151;
                        this.#h3h = 0x96387719;
                        this.#h3l = 0x5940eabd;
                        this.#h4h = 0x96283ee2;
                        this.#h4l = 0xa88effe3;
                        this.#h5h = 0xbe5e1e25;
                        this.#h5l = 0x53863992;
                        this.#h6h = 0x2b0199fc;
                        this.#h6l = 0x2c85b8aa;
                        this.#h7h = 0x0eb72ddc;
                        this.#h7l = 0x81c52ca2;
                    }
                    else if (bits === 384) {
                        this.#h0h = 0xcbbb9d5d;
                        this.#h0l = 0xc1059ed8;
                        this.#h1h = 0x629a292a;
                        this.#h1l = 0x367cd507;
                        this.#h2h = 0x9159015a;
                        this.#h2l = 0x3070dd17;
                        this.#h3h = 0x152fecd8;
                        this.#h3l = 0xf70e5939;
                        this.#h4h = 0x67332667;
                        this.#h4l = 0xffc00b31;
                        this.#h5h = 0x8eb44a87;
                        this.#h5l = 0x68581511;
                        this.#h6h = 0xdb0c2e0d;
                        this.#h6l = 0x64f98fa7;
                        this.#h7h = 0x47b5481d;
                        this.#h7l = 0xbefa4fa4;
                    }
                    else {
                        this.#h0h = 0x6a09e667;
                        this.#h0l = 0xf3bcc908;
                        this.#h1h = 0xbb67ae85;
                        this.#h1l = 0x84caa73b;
                        this.#h2h = 0x3c6ef372;
                        this.#h2l = 0xfe94f82b;
                        this.#h3h = 0xa54ff53a;
                        this.#h3l = 0x5f1d36f1;
                        this.#h4h = 0x510e527f;
                        this.#h4l = 0xade682d1;
                        this.#h5h = 0x9b05688c;
                        this.#h5l = 0x2b3e6c1f;
                        this.#h6h = 0x1f83d9ab;
                        this.#h6l = 0xfb41bd6b;
                        this.#h7h = 0x5be0cd19;
                        this.#h7l = 0x137e2179;
                    }
                    this.#bits = bits;
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                }
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    const length = msg.length;
                    const blocks = this.#blocks;
                    let index = 0;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] =
                                blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] =
                                    blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] =
                                        blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 128; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 128; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code = 0x10000 + (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 128) {
                            this.#block = blocks[32];
                            this.#start = i - 128;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[32] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[32];
                    if (i >= 112) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] =
                            blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] =
                                blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] =
                                    blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
                    }
                    blocks[30] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[31] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    const h0h = this.#h0h, h0l = this.#h0l, h1h = this.#h1h, h1l = this.#h1l, h2h = this.#h2h, h2l = this.#h2l, h3h = this.#h3h, h3l = this.#h3l, h4h = this.#h4h, h4l = this.#h4l, h5h = this.#h5h, h5l = this.#h5l, h6h = this.#h6h, h6l = this.#h6l, h7h = this.#h7h, h7l = this.#h7l;
                    let s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
                    const blocks = this.#blocks;
                    for (let j = 32; j < 160; j += 2) {
                        t1h = blocks[j - 30];
                        t1l = blocks[j - 29];
                        s0h = ((t1h >>> 1) | (t1l << 31)) ^ ((t1h >>> 8) | (t1l << 24)) ^ (t1h >>> 7);
                        s0l = ((t1l >>> 1) | (t1h << 31)) ^ ((t1l >>> 8) | (t1h << 24)) ^ ((t1l >>> 7) | (t1h << 25));
                        t1h = blocks[j - 4];
                        t1l = blocks[j - 3];
                        s1h = ((t1h >>> 19) | (t1l << 13)) ^ ((t1l >>> 29) | (t1h << 3)) ^ (t1h >>> 6);
                        s1l = ((t1l >>> 19) | (t1h << 13)) ^ ((t1h >>> 29) | (t1l << 3)) ^ ((t1l >>> 6) | (t1h << 26));
                        t1h = blocks[j - 32];
                        t1l = blocks[j - 31];
                        t2h = blocks[j - 14];
                        t2l = blocks[j - 13];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (s0l & 0xffff) + (s1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (s0h & 0xffff) + (s1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
                        blocks[j] = (c4 << 16) | (c3 & 0xffff);
                        blocks[j + 1] = (c2 << 16) | (c1 & 0xffff);
                    }
                    let ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
                    bch = bh & ch;
                    bcl = bl & cl;
                    for (let j = 0; j < 160; j += 8) {
                        s0h = ((ah >>> 28) | (al << 4)) ^ ((al >>> 2) | (ah << 30)) ^ ((al >>> 7) | (ah << 25));
                        s0l = ((al >>> 28) | (ah << 4)) ^ ((ah >>> 2) | (al << 30)) ^ ((ah >>> 7) | (al << 25));
                        s1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((el >>> 9) | (eh << 23));
                        s1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((eh >>> 9) | (el << 23));
                        abh = ah & bh;
                        abl = al & bl;
                        majh = abh ^ (ah & ch) ^ bch;
                        majl = abl ^ (al & cl) ^ bcl;
                        chh = (eh & fh) ^ (~eh & gh);
                        chl = (el & fl) ^ (~el & gl);
                        t1h = blocks[j];
                        t1l = blocks[j + 1];
                        t2h = K[j];
                        t2l = K[j + 1];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (hl & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (hh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (dl & 0xffff) + (t1l & 0xffff);
                        c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (dh & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        hh = (c4 << 16) | (c3 & 0xffff);
                        hl = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        dh = (c4 << 16) | (c3 & 0xffff);
                        dl = (c2 << 16) | (c1 & 0xffff);
                        s0h = ((dh >>> 28) | (dl << 4)) ^ ((dl >>> 2) | (dh << 30)) ^ ((dl >>> 7) | (dh << 25));
                        s0l = ((dl >>> 28) | (dh << 4)) ^ ((dh >>> 2) | (dl << 30)) ^ ((dh >>> 7) | (dl << 25));
                        s1h = ((hh >>> 14) | (hl << 18)) ^ ((hh >>> 18) | (hl << 14)) ^ ((hl >>> 9) | (hh << 23));
                        s1l = ((hl >>> 14) | (hh << 18)) ^ ((hl >>> 18) | (hh << 14)) ^ ((hh >>> 9) | (hl << 23));
                        dah = dh & ah;
                        dal = dl & al;
                        majh = dah ^ (dh & bh) ^ abh;
                        majl = dal ^ (dl & bl) ^ abl;
                        chh = (hh & eh) ^ (~hh & fh);
                        chl = (hl & el) ^ (~hl & fl);
                        t1h = blocks[j + 2];
                        t1l = blocks[j + 3];
                        t2h = K[j + 2];
                        t2l = K[j + 3];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (gl & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (gh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (cl & 0xffff) + (t1l & 0xffff);
                        c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (ch & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        gh = (c4 << 16) | (c3 & 0xffff);
                        gl = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        ch = (c4 << 16) | (c3 & 0xffff);
                        cl = (c2 << 16) | (c1 & 0xffff);
                        s0h = ((ch >>> 28) | (cl << 4)) ^ ((cl >>> 2) | (ch << 30)) ^ ((cl >>> 7) | (ch << 25));
                        s0l = ((cl >>> 28) | (ch << 4)) ^ ((ch >>> 2) | (cl << 30)) ^ ((ch >>> 7) | (cl << 25));
                        s1h = ((gh >>> 14) | (gl << 18)) ^ ((gh >>> 18) | (gl << 14)) ^ ((gl >>> 9) | (gh << 23));
                        s1l = ((gl >>> 14) | (gh << 18)) ^ ((gl >>> 18) | (gh << 14)) ^ ((gh >>> 9) | (gl << 23));
                        cdh = ch & dh;
                        cdl = cl & dl;
                        majh = cdh ^ (ch & ah) ^ dah;
                        majl = cdl ^ (cl & al) ^ dal;
                        chh = (gh & hh) ^ (~gh & eh);
                        chl = (gl & hl) ^ (~gl & el);
                        t1h = blocks[j + 4];
                        t1l = blocks[j + 5];
                        t2h = K[j + 4];
                        t2l = K[j + 5];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (fl & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (fh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (bl & 0xffff) + (t1l & 0xffff);
                        c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (bh & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        fh = (c4 << 16) | (c3 & 0xffff);
                        fl = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        bh = (c4 << 16) | (c3 & 0xffff);
                        bl = (c2 << 16) | (c1 & 0xffff);
                        s0h = ((bh >>> 28) | (bl << 4)) ^ ((bl >>> 2) | (bh << 30)) ^ ((bl >>> 7) | (bh << 25));
                        s0l = ((bl >>> 28) | (bh << 4)) ^ ((bh >>> 2) | (bl << 30)) ^ ((bh >>> 7) | (bl << 25));
                        s1h = ((fh >>> 14) | (fl << 18)) ^ ((fh >>> 18) | (fl << 14)) ^ ((fl >>> 9) | (fh << 23));
                        s1l = ((fl >>> 14) | (fh << 18)) ^ ((fl >>> 18) | (fh << 14)) ^ ((fh >>> 9) | (fl << 23));
                        bch = bh & ch;
                        bcl = bl & cl;
                        majh = bch ^ (bh & dh) ^ cdh;
                        majl = bcl ^ (bl & dl) ^ cdl;
                        chh = (fh & gh) ^ (~fh & hh);
                        chl = (fl & gl) ^ (~fl & hl);
                        t1h = blocks[j + 6];
                        t1l = blocks[j + 7];
                        t2h = K[j + 6];
                        t2l = K[j + 7];
                        c1 = (t2l & 0xffff) + (t1l & 0xffff) + (chl & 0xffff) + (s1l & 0xffff) + (el & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (chh & 0xffff) + (s1h & 0xffff) + (eh & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
                        t1h = (c4 << 16) | (c3 & 0xffff);
                        t1l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (majl & 0xffff) + (s0l & 0xffff);
                        c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
                        c3 = (majh & 0xffff) + (s0h & 0xffff) + (c2 >>> 16);
                        c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
                        t2h = (c4 << 16) | (c3 & 0xffff);
                        t2l = (c2 << 16) | (c1 & 0xffff);
                        c1 = (al & 0xffff) + (t1l & 0xffff);
                        c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (ah & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        eh = (c4 << 16) | (c3 & 0xffff);
                        el = (c2 << 16) | (c1 & 0xffff);
                        c1 = (t2l & 0xffff) + (t1l & 0xffff);
                        c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
                        c3 = (t2h & 0xffff) + (t1h & 0xffff) + (c2 >>> 16);
                        c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
                        ah = (c4 << 16) | (c3 & 0xffff);
                        al = (c2 << 16) | (c1 & 0xffff);
                    }
                    c1 = (h0l & 0xffff) + (al & 0xffff);
                    c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
                    c3 = (h0h & 0xffff) + (ah & 0xffff) + (c2 >>> 16);
                    c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
                    this.#h0h = (c4 << 16) | (c3 & 0xffff);
                    this.#h0l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h1l & 0xffff) + (bl & 0xffff);
                    c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
                    c3 = (h1h & 0xffff) + (bh & 0xffff) + (c2 >>> 16);
                    c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
                    this.#h1h = (c4 << 16) | (c3 & 0xffff);
                    this.#h1l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h2l & 0xffff) + (cl & 0xffff);
                    c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
                    c3 = (h2h & 0xffff) + (ch & 0xffff) + (c2 >>> 16);
                    c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
                    this.#h2h = (c4 << 16) | (c3 & 0xffff);
                    this.#h2l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h3l & 0xffff) + (dl & 0xffff);
                    c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
                    c3 = (h3h & 0xffff) + (dh & 0xffff) + (c2 >>> 16);
                    c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
                    this.#h3h = (c4 << 16) | (c3 & 0xffff);
                    this.#h3l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h4l & 0xffff) + (el & 0xffff);
                    c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
                    c3 = (h4h & 0xffff) + (eh & 0xffff) + (c2 >>> 16);
                    c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
                    this.#h4h = (c4 << 16) | (c3 & 0xffff);
                    this.#h4l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h5l & 0xffff) + (fl & 0xffff);
                    c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
                    c3 = (h5h & 0xffff) + (fh & 0xffff) + (c2 >>> 16);
                    c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
                    this.#h5h = (c4 << 16) | (c3 & 0xffff);
                    this.#h5l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h6l & 0xffff) + (gl & 0xffff);
                    c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
                    c3 = (h6h & 0xffff) + (gh & 0xffff) + (c2 >>> 16);
                    c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
                    this.#h6h = (c4 << 16) | (c3 & 0xffff);
                    this.#h6l = (c2 << 16) | (c1 & 0xffff);
                    c1 = (h7l & 0xffff) + (hl & 0xffff);
                    c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
                    c3 = (h7h & 0xffff) + (hh & 0xffff) + (c2 >>> 16);
                    c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
                    this.#h7h = (c4 << 16) | (c3 & 0xffff);
                    this.#h7l = (c2 << 16) | (c1 & 0xffff);
                }
                hex() {
                    this.finalize();
                    const h0h = this.#h0h, h0l = this.#h0l, h1h = this.#h1h, h1l = this.#h1l, h2h = this.#h2h, h2l = this.#h2l, h3h = this.#h3h, h3l = this.#h3l, h4h = this.#h4h, h4l = this.#h4l, h5h = this.#h5h, h5l = this.#h5l, h6h = this.#h6h, h6l = this.#h6l, h7h = this.#h7h, h7l = this.#h7l, bits = this.#bits;
                    let hex = HEX_CHARS[(h0h >> 28) & 0x0f] + HEX_CHARS[(h0h >> 24) & 0x0f] +
                        HEX_CHARS[(h0h >> 20) & 0x0f] + HEX_CHARS[(h0h >> 16) & 0x0f] +
                        HEX_CHARS[(h0h >> 12) & 0x0f] + HEX_CHARS[(h0h >> 8) & 0x0f] +
                        HEX_CHARS[(h0h >> 4) & 0x0f] + HEX_CHARS[h0h & 0x0f] +
                        HEX_CHARS[(h0l >> 28) & 0x0f] + HEX_CHARS[(h0l >> 24) & 0x0f] +
                        HEX_CHARS[(h0l >> 20) & 0x0f] + HEX_CHARS[(h0l >> 16) & 0x0f] +
                        HEX_CHARS[(h0l >> 12) & 0x0f] + HEX_CHARS[(h0l >> 8) & 0x0f] +
                        HEX_CHARS[(h0l >> 4) & 0x0f] + HEX_CHARS[h0l & 0x0f] +
                        HEX_CHARS[(h1h >> 28) & 0x0f] + HEX_CHARS[(h1h >> 24) & 0x0f] +
                        HEX_CHARS[(h1h >> 20) & 0x0f] + HEX_CHARS[(h1h >> 16) & 0x0f] +
                        HEX_CHARS[(h1h >> 12) & 0x0f] + HEX_CHARS[(h1h >> 8) & 0x0f] +
                        HEX_CHARS[(h1h >> 4) & 0x0f] + HEX_CHARS[h1h & 0x0f] +
                        HEX_CHARS[(h1l >> 28) & 0x0f] + HEX_CHARS[(h1l >> 24) & 0x0f] +
                        HEX_CHARS[(h1l >> 20) & 0x0f] + HEX_CHARS[(h1l >> 16) & 0x0f] +
                        HEX_CHARS[(h1l >> 12) & 0x0f] + HEX_CHARS[(h1l >> 8) & 0x0f] +
                        HEX_CHARS[(h1l >> 4) & 0x0f] + HEX_CHARS[h1l & 0x0f] +
                        HEX_CHARS[(h2h >> 28) & 0x0f] + HEX_CHARS[(h2h >> 24) & 0x0f] +
                        HEX_CHARS[(h2h >> 20) & 0x0f] + HEX_CHARS[(h2h >> 16) & 0x0f] +
                        HEX_CHARS[(h2h >> 12) & 0x0f] + HEX_CHARS[(h2h >> 8) & 0x0f] +
                        HEX_CHARS[(h2h >> 4) & 0x0f] + HEX_CHARS[h2h & 0x0f] +
                        HEX_CHARS[(h2l >> 28) & 0x0f] + HEX_CHARS[(h2l >> 24) & 0x0f] +
                        HEX_CHARS[(h2l >> 20) & 0x0f] + HEX_CHARS[(h2l >> 16) & 0x0f] +
                        HEX_CHARS[(h2l >> 12) & 0x0f] + HEX_CHARS[(h2l >> 8) & 0x0f] +
                        HEX_CHARS[(h2l >> 4) & 0x0f] + HEX_CHARS[h2l & 0x0f] +
                        HEX_CHARS[(h3h >> 28) & 0x0f] + HEX_CHARS[(h3h >> 24) & 0x0f] +
                        HEX_CHARS[(h3h >> 20) & 0x0f] + HEX_CHARS[(h3h >> 16) & 0x0f] +
                        HEX_CHARS[(h3h >> 12) & 0x0f] + HEX_CHARS[(h3h >> 8) & 0x0f] +
                        HEX_CHARS[(h3h >> 4) & 0x0f] + HEX_CHARS[h3h & 0x0f];
                    if (bits >= 256) {
                        hex +=
                            HEX_CHARS[(h3l >> 28) & 0x0f] + HEX_CHARS[(h3l >> 24) & 0x0f] +
                                HEX_CHARS[(h3l >> 20) & 0x0f] + HEX_CHARS[(h3l >> 16) & 0x0f] +
                                HEX_CHARS[(h3l >> 12) & 0x0f] + HEX_CHARS[(h3l >> 8) & 0x0f] +
                                HEX_CHARS[(h3l >> 4) & 0x0f] + HEX_CHARS[h3l & 0x0f];
                    }
                    if (bits >= 384) {
                        hex +=
                            HEX_CHARS[(h4h >> 28) & 0x0f] + HEX_CHARS[(h4h >> 24) & 0x0f] +
                                HEX_CHARS[(h4h >> 20) & 0x0f] + HEX_CHARS[(h4h >> 16) & 0x0f] +
                                HEX_CHARS[(h4h >> 12) & 0x0f] + HEX_CHARS[(h4h >> 8) & 0x0f] +
                                HEX_CHARS[(h4h >> 4) & 0x0f] + HEX_CHARS[h4h & 0x0f] +
                                HEX_CHARS[(h4l >> 28) & 0x0f] + HEX_CHARS[(h4l >> 24) & 0x0f] +
                                HEX_CHARS[(h4l >> 20) & 0x0f] + HEX_CHARS[(h4l >> 16) & 0x0f] +
                                HEX_CHARS[(h4l >> 12) & 0x0f] + HEX_CHARS[(h4l >> 8) & 0x0f] +
                                HEX_CHARS[(h4l >> 4) & 0x0f] + HEX_CHARS[h4l & 0x0f] +
                                HEX_CHARS[(h5h >> 28) & 0x0f] + HEX_CHARS[(h5h >> 24) & 0x0f] +
                                HEX_CHARS[(h5h >> 20) & 0x0f] + HEX_CHARS[(h5h >> 16) & 0x0f] +
                                HEX_CHARS[(h5h >> 12) & 0x0f] + HEX_CHARS[(h5h >> 8) & 0x0f] +
                                HEX_CHARS[(h5h >> 4) & 0x0f] + HEX_CHARS[h5h & 0x0f] +
                                HEX_CHARS[(h5l >> 28) & 0x0f] + HEX_CHARS[(h5l >> 24) & 0x0f] +
                                HEX_CHARS[(h5l >> 20) & 0x0f] + HEX_CHARS[(h5l >> 16) & 0x0f] +
                                HEX_CHARS[(h5l >> 12) & 0x0f] + HEX_CHARS[(h5l >> 8) & 0x0f] +
                                HEX_CHARS[(h5l >> 4) & 0x0f] + HEX_CHARS[h5l & 0x0f];
                    }
                    if (bits === 512) {
                        hex +=
                            HEX_CHARS[(h6h >> 28) & 0x0f] + HEX_CHARS[(h6h >> 24) & 0x0f] +
                                HEX_CHARS[(h6h >> 20) & 0x0f] + HEX_CHARS[(h6h >> 16) & 0x0f] +
                                HEX_CHARS[(h6h >> 12) & 0x0f] + HEX_CHARS[(h6h >> 8) & 0x0f] +
                                HEX_CHARS[(h6h >> 4) & 0x0f] + HEX_CHARS[h6h & 0x0f] +
                                HEX_CHARS[(h6l >> 28) & 0x0f] + HEX_CHARS[(h6l >> 24) & 0x0f] +
                                HEX_CHARS[(h6l >> 20) & 0x0f] + HEX_CHARS[(h6l >> 16) & 0x0f] +
                                HEX_CHARS[(h6l >> 12) & 0x0f] + HEX_CHARS[(h6l >> 8) & 0x0f] +
                                HEX_CHARS[(h6l >> 4) & 0x0f] + HEX_CHARS[h6l & 0x0f] +
                                HEX_CHARS[(h7h >> 28) & 0x0f] + HEX_CHARS[(h7h >> 24) & 0x0f] +
                                HEX_CHARS[(h7h >> 20) & 0x0f] + HEX_CHARS[(h7h >> 16) & 0x0f] +
                                HEX_CHARS[(h7h >> 12) & 0x0f] + HEX_CHARS[(h7h >> 8) & 0x0f] +
                                HEX_CHARS[(h7h >> 4) & 0x0f] + HEX_CHARS[h7h & 0x0f] +
                                HEX_CHARS[(h7l >> 28) & 0x0f] + HEX_CHARS[(h7l >> 24) & 0x0f] +
                                HEX_CHARS[(h7l >> 20) & 0x0f] + HEX_CHARS[(h7l >> 16) & 0x0f] +
                                HEX_CHARS[(h7l >> 12) & 0x0f] + HEX_CHARS[(h7l >> 8) & 0x0f] +
                                HEX_CHARS[(h7l >> 4) & 0x0f] + HEX_CHARS[h7l & 0x0f];
                    }
                    return hex;
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0h = this.#h0h, h0l = this.#h0l, h1h = this.#h1h, h1l = this.#h1l, h2h = this.#h2h, h2l = this.#h2l, h3h = this.#h3h, h3l = this.#h3l, h4h = this.#h4h, h4l = this.#h4l, h5h = this.#h5h, h5l = this.#h5l, h6h = this.#h6h, h6l = this.#h6l, h7h = this.#h7h, h7l = this.#h7l, bits = this.#bits;
                    const arr = [
                        (h0h >> 24) & 0xff, (h0h >> 16) & 0xff, (h0h >> 8) & 0xff, h0h & 0xff,
                        (h0l >> 24) & 0xff, (h0l >> 16) & 0xff, (h0l >> 8) & 0xff, h0l & 0xff,
                        (h1h >> 24) & 0xff, (h1h >> 16) & 0xff, (h1h >> 8) & 0xff, h1h & 0xff,
                        (h1l >> 24) & 0xff, (h1l >> 16) & 0xff, (h1l >> 8) & 0xff, h1l & 0xff,
                        (h2h >> 24) & 0xff, (h2h >> 16) & 0xff, (h2h >> 8) & 0xff, h2h & 0xff,
                        (h2l >> 24) & 0xff, (h2l >> 16) & 0xff, (h2l >> 8) & 0xff, h2l & 0xff,
                        (h3h >> 24) & 0xff, (h3h >> 16) & 0xff, (h3h >> 8) & 0xff, h3h & 0xff
                    ];
                    if (bits >= 256) {
                        arr.push((h3l >> 24) & 0xff, (h3l >> 16) & 0xff, (h3l >> 8) & 0xff, h3l & 0xff);
                    }
                    if (bits >= 384) {
                        arr.push((h4h >> 24) & 0xff, (h4h >> 16) & 0xff, (h4h >> 8) & 0xff, h4h & 0xff, (h4l >> 24) & 0xff, (h4l >> 16) & 0xff, (h4l >> 8) & 0xff, h4l & 0xff, (h5h >> 24) & 0xff, (h5h >> 16) & 0xff, (h5h >> 8) & 0xff, h5h & 0xff, (h5l >> 24) & 0xff, (h5l >> 16) & 0xff, (h5l >> 8) & 0xff, h5l & 0xff);
                    }
                    if (bits === 512) {
                        arr.push((h6h >> 24) & 0xff, (h6h >> 16) & 0xff, (h6h >> 8) & 0xff, h6h & 0xff, (h6l >> 24) & 0xff, (h6l >> 16) & 0xff, (h6l >> 8) & 0xff, h6l & 0xff, (h7h >> 24) & 0xff, (h7h >> 16) & 0xff, (h7h >> 8) & 0xff, h7h & 0xff, (h7l >> 24) & 0xff, (h7l >> 16) & 0xff, (h7l >> 8) & 0xff, h7l & 0xff);
                    }
                    return arr;
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const bits = this.#bits;
                    const buffer = new ArrayBuffer(bits / 8);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0h);
                    dataView.setUint32(4, this.#h0l);
                    dataView.setUint32(8, this.#h1h);
                    dataView.setUint32(12, this.#h1l);
                    dataView.setUint32(16, this.#h2h);
                    dataView.setUint32(20, this.#h2l);
                    dataView.setUint32(24, this.#h3h);
                    if (bits >= 256) {
                        dataView.setUint32(28, this.#h3l);
                    }
                    if (bits >= 384) {
                        dataView.setUint32(32, this.#h4h);
                        dataView.setUint32(36, this.#h4l);
                        dataView.setUint32(40, this.#h5h);
                        dataView.setUint32(44, this.#h5l);
                    }
                    if (bits === 512) {
                        dataView.setUint32(48, this.#h6h);
                        dataView.setUint32(52, this.#h6l);
                        dataView.setUint32(56, this.#h7h);
                        dataView.setUint32(60, this.#h7l);
                    }
                    return buffer;
                }
            };
            exports_102("Sha512", Sha512);
            HmacSha512 = class HmacSha512 extends Sha512 {
                constructor(secretKey, bits = 512, sharedMemory = false) {
                    super(bits, sharedMemory);
                    let key;
                    if (secretKey instanceof ArrayBuffer) {
                        key = new Uint8Array(secretKey);
                    }
                    else if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        let code;
                        for (let i = 0; i < length; ++i) {
                            code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code = 0x10000 +
                                    (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        key = secretKey;
                    }
                    if (key.length > 128) {
                        key = new Sha512(bits, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 128; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#inner = true;
                    this.#bits = bits;
                    this.#oKeyPad = oKeyPad;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #bits;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#bits, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_102("HmacSha512", HmacSha512);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/common", [], function (exports_103, context_103) {
    "use strict";
    var __moduleName = context_103 && context_103.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary", [], function (exports_104, context_104) {
    "use strict";
    var RawBinary;
    var __moduleName = context_104 && context_104.id;
    return {
        setters: [],
        execute: function () {
            RawBinary = class RawBinary extends Uint8Array {
                hex() {
                    return [...this].map((x) => x.toString(16).padStart(2, "0")).join("");
                }
                binary() {
                    return this;
                }
                base64() {
                    return btoa(String.fromCharCode.apply(null, [...this]));
                }
                base64url() {
                    let a = btoa(String.fromCharCode.apply(null, [...this])).replace(/=/g, "");
                    a = a.replace(/\+/g, "-");
                    a = a.replace(/\//g, "_");
                    return a;
                }
                base32() {
                    const lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
                    const trim = [0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff];
                    let output = "";
                    let bits = 0;
                    let current = 0;
                    for (let i = 0; i < this.length; i++) {
                        current = (current << 8) + this[i];
                        bits += 8;
                        while (bits >= 5) {
                            bits -= 5;
                            output += lookup[current >> bits];
                            current = current & trim[bits];
                        }
                    }
                    if (bits > 0) {
                        output += lookup[current << (5 - bits)];
                    }
                    return output;
                }
                toString() {
                    return new TextDecoder().decode(this);
                }
            };
            exports_104("RawBinary", RawBinary);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/utility/encode", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary"], function (exports_105, context_105) {
    "use strict";
    var binary_ts_1, encode;
    var __moduleName = context_105 && context_105.id;
    return {
        setters: [
            function (binary_ts_1_1) {
                binary_ts_1 = binary_ts_1_1;
            }
        ],
        execute: function () {
            encode = class encode {
                static hex(data) {
                    if (data.length % 2 !== 0)
                        throw "Invalid hex format";
                    const output = new binary_ts_1.RawBinary(data.length >> 1);
                    let ptr = 0;
                    for (let i = 0; i < data.length; i += 2) {
                        output[ptr++] = parseInt(data.substr(i, 2), 16);
                    }
                    return output;
                }
                static bigint(n) {
                    const bytes = [];
                    while (n > 0) {
                        bytes.push(Number(n & 255n));
                        n = n >> 8n;
                    }
                    bytes.reverse();
                    return new binary_ts_1.RawBinary(bytes);
                }
                static string(data) {
                    return new binary_ts_1.RawBinary(new TextEncoder().encode(data));
                }
                static base64(data) {
                    return new binary_ts_1.RawBinary(Uint8Array.from(atob(data), (c) => c.charCodeAt(0)));
                }
                static base64url(data) {
                    let input = data
                        .replace(/-/g, "+")
                        .replace(/_/g, "/");
                    const pad = input.length % 4;
                    if (pad) {
                        if (pad === 1)
                            throw "Invalid length";
                        input += new Array(5 - pad).join("=");
                    }
                    return encode.base64(input);
                }
                static binary(data) {
                    return new binary_ts_1.RawBinary(data);
                }
                static base32(data) {
                    data = data.toUpperCase();
                    data = data.replace(/=+$/g, "");
                    const lookup = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
                    const size = (data.length * 5) >> 3;
                    const output = new binary_ts_1.RawBinary(size);
                    let ptr = 0;
                    let bits = 0;
                    let current = 0;
                    for (let i = 0; i < data.length; i++) {
                        const value = lookup.indexOf(data[i]);
                        if (value < 0)
                            throw "Invalid base32 format";
                        current = (current << 5) + value;
                        bits += 5;
                        if (bits >= 8) {
                            bits -= 8;
                            const t = current >> bits;
                            current -= t << bits;
                            output[ptr++] = t;
                        }
                    }
                    return output;
                }
            };
            exports_105("encode", encode);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/helper", [], function (exports_106, context_106) {
    "use strict";
    var __moduleName = context_106 && context_106.id;
    function str2bytes(str) {
        const encoder = new TextEncoder();
        return encoder.encode(str);
    }
    exports_106("str2bytes", str2bytes);
    function hex(bytes) {
        let output = "";
        for (const b of bytes)
            output += b.toString(16).padStart(2, "0");
        return output;
    }
    exports_106("hex", hex);
    function xor(a, b) {
        const c = new Uint8Array(a.length);
        for (let i = 0; i < c.length; i++) {
            c[i] = a[i] ^ b[i % b.length];
        }
        return c;
    }
    exports_106("xor", xor);
    function concat(...arg) {
        const length = arg.reduce((a, b) => a + b.length, 0);
        const c = new Uint8Array(length);
        let ptr = 0;
        for (let i = 0; i < arg.length; i++) {
            c.set(arg[i], ptr);
            ptr += arg[i].length;
        }
        return c;
    }
    exports_106("concat", concat);
    function bignum_to_byte(n) {
        const bytes = [];
        while (n > 0) {
            bytes.push(Number(n & 255n));
            n = n >> 8n;
        }
        bytes.reverse();
        return bytes;
    }
    exports_106("bignum_to_byte", bignum_to_byte);
    function random_bytes(length) {
        const n = new Uint8Array(length);
        for (let i = 0; i < length; i++)
            n[i] = ((Math.random() * 254) | 0) + 1;
        return n;
    }
    exports_106("random_bytes", random_bytes);
    function get_key_size(n) {
        const size_list = [64n, 128n, 256n, 512n, 1024n];
        for (const size of size_list) {
            if (n < (1n << size * 8n))
                return Number(size);
        }
        return 2048;
    }
    exports_106("get_key_size", get_key_size);
    function base64_to_binary(b) {
        let binaryString = window.atob(b);
        let len = binaryString.length;
        let bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    }
    exports_106("base64_to_binary", base64_to_binary);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/export_key", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/helper", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/utility/encode"], function (exports_107, context_107) {
    "use strict";
    var helper_ts_1, encode_ts_2;
    var __moduleName = context_107 && context_107.id;
    function ber_size_bytes(size) {
        if (size <= 127)
            return [size];
        const bytes = [];
        while (size > 0) {
            bytes.push(size & 0xff);
            size = size >> 8;
        }
        bytes.reverse();
        return [0x80 + bytes.length, ...bytes];
    }
    function add_line_break(base64_str) {
        const lines = [];
        for (let i = 0; i < base64_str.length; i += 64) {
            lines.push(base64_str.substr(i, 64));
        }
        return lines.join("\n");
    }
    function ber_generate_integer_list(order) {
        let content = [];
        for (const item of order) {
            if ((item[0] & 0x80) > 0) {
                content = content.concat([0x02, ...ber_size_bytes(item.length + 1), 0x0, ...item]);
            }
            else {
                content = content.concat([0x02, ...ber_size_bytes(item.length), ...item]);
            }
        }
        return content;
    }
    function rsa_export_pkcs8_public(key) {
        const n = helper_ts_1.bignum_to_byte(key.n);
        const e = helper_ts_1.bignum_to_byte(key.e || 0n);
        const other = [0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00];
        const content = ber_generate_integer_list([n, e]);
        const keySequence = [
            0x30,
            ...ber_size_bytes(content.length),
            ...content,
        ];
        const bitString = [
            0x03,
            ...ber_size_bytes(keySequence.length + 1),
            0x00,
            ...keySequence,
        ];
        const ber = [
            0x30,
            ...ber_size_bytes(other.length + bitString.length),
            ...other,
            ...bitString,
        ];
        return "-----BEGIN PUBLIC KEY-----\n" +
            add_line_break(encode_ts_2.encode.binary(ber).base64()) +
            "\n-----END PUBLIC KEY-----\n";
    }
    exports_107("rsa_export_pkcs8_public", rsa_export_pkcs8_public);
    function rsa_export_pkcs8_private(key) {
        const n = helper_ts_1.bignum_to_byte(key.n);
        const e = helper_ts_1.bignum_to_byte(key.e || 0n);
        const d = helper_ts_1.bignum_to_byte(key.d || 0n);
        const q = helper_ts_1.bignum_to_byte(key.q || 0n);
        const p = helper_ts_1.bignum_to_byte(key.p || 0n);
        const dp = helper_ts_1.bignum_to_byte(key.dp || 0n);
        const dq = helper_ts_1.bignum_to_byte(key.dq || 0n);
        const qi = helper_ts_1.bignum_to_byte(key.qi || 0n);
        const content = ber_generate_integer_list([n, e, d, p, q, dp, dq, qi]);
        const ber = encode_ts_2.encode.binary([
            0x30,
            ...ber_size_bytes(content.length + 3),
            0x02,
            0x01,
            0x00,
            ...content,
        ]).base64();
        return "-----BEGIN RSA PRIVATE KEY-----\n" + add_line_break(ber) +
            "\n-----END RSA PRIVATE KEY-----\n";
    }
    exports_107("rsa_export_pkcs8_private", rsa_export_pkcs8_private);
    return {
        setters: [
            function (helper_ts_1_1) {
                helper_ts_1 = helper_ts_1_1;
            },
            function (encode_ts_2_1) {
                encode_ts_2 = encode_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_key", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/utility/encode", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/export_key"], function (exports_108, context_108) {
    "use strict";
    var encode_ts_3, export_key_ts_1, RSAKey;
    var __moduleName = context_108 && context_108.id;
    return {
        setters: [
            function (encode_ts_3_1) {
                encode_ts_3 = encode_ts_3_1;
            },
            function (export_key_ts_1_1) {
                export_key_ts_1 = export_key_ts_1_1;
            }
        ],
        execute: function () {
            RSAKey = class RSAKey {
                constructor(params) {
                    this.n = params.n;
                    this.e = params.e;
                    this.d = params.d;
                    this.p = params.p;
                    this.q = params.q;
                    this.dp = params.dp;
                    this.dq = params.dq;
                    this.qi = params.qi;
                    this.length = params.length;
                }
                pem() {
                    if (this.d) {
                        return export_key_ts_1.rsa_export_pkcs8_private(this);
                    }
                    else {
                        return export_key_ts_1.rsa_export_pkcs8_public(this);
                    }
                }
                jwk() {
                    let jwk = {
                        kty: "RSA",
                        n: encode_ts_3.encode.bigint(this.n).base64url(),
                    };
                    if (this.d)
                        jwk = { ...jwk, d: encode_ts_3.encode.bigint(this.d).base64url() };
                    if (this.e)
                        jwk = { ...jwk, e: encode_ts_3.encode.bigint(this.e).base64url() };
                    if (this.p)
                        jwk = { ...jwk, p: encode_ts_3.encode.bigint(this.p).base64url() };
                    if (this.q)
                        jwk = { ...jwk, q: encode_ts_3.encode.bigint(this.q).base64url() };
                    if (this.dp)
                        jwk = { ...jwk, dp: encode_ts_3.encode.bigint(this.dp).base64url() };
                    if (this.dq)
                        jwk = { ...jwk, dq: encode_ts_3.encode.bigint(this.dq).base64url() };
                    if (this.qi)
                        jwk = { ...jwk, qi: encode_ts_3.encode.bigint(this.qi).base64url() };
                    return jwk;
                }
            };
            exports_108("RSAKey", RSAKey);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_wc", [], function (exports_109, context_109) {
    "use strict";
    var WebCryptoRSA;
    var __moduleName = context_109 && context_109.id;
    function big_base64(m) {
        if (m === undefined)
            return undefined;
        const bytes = [];
        while (m > 0n) {
            bytes.push(Number(m & 255n));
            m = m >> 8n;
        }
        bytes.reverse();
        let a = btoa(String.fromCharCode.apply(null, bytes)).replace(/=/g, "");
        a = a.replace(/\+/g, "-");
        a = a.replace(/\//g, "_");
        return a;
    }
    function getHashFunctionName(hash) {
        if (hash === "sha1")
            return "SHA-1";
        if (hash === "sha256")
            return "SHA-256";
        return "";
    }
    async function createWebCryptoKey(key, usage, options) {
        let jwk = {
            kty: "RSA",
            n: big_base64(key.n),
            ext: true,
        };
        if (usage === "encrypt") {
            jwk = { ...jwk, e: big_base64(key.e) };
        }
        else if (usage === "decrypt") {
            jwk = {
                ...jwk,
                d: big_base64(key.d),
                e: big_base64(key.e),
                p: big_base64(key.p),
                q: big_base64(key.q),
                dp: big_base64(key.dp),
                dq: big_base64(key.dq),
                qi: big_base64(key.qi),
            };
        }
        return await crypto.subtle.importKey("jwk", jwk, {
            name: "RSA-OAEP",
            hash: { name: getHashFunctionName(options.hash) },
        }, false, [usage]);
    }
    return {
        setters: [],
        execute: function () {
            WebCryptoRSA = class WebCryptoRSA {
                constructor(key, options) {
                    this.encryptedKey = null;
                    this.decryptedKey = null;
                    this.key = key;
                    this.options = options;
                }
                static isSupported(options) {
                    if (!crypto.subtle)
                        return false;
                    if (options.padding !== "oaep")
                        return false;
                    return true;
                }
                static async encrypt(key, m, options) {
                    return await crypto.subtle.encrypt({ name: "RSA-OAEP" }, await createWebCryptoKey(key, "encrypt", options), m);
                }
                static async decrypt(key, m, options) {
                    return await crypto.subtle.decrypt({ name: "RSA-OAEP" }, await createWebCryptoKey(key, "decrypt", options), m);
                }
            };
            exports_109("WebCryptoRSA", WebCryptoRSA);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/math", [], function (exports_110, context_110) {
    "use strict";
    var __moduleName = context_110 && context_110.id;
    function power_mod(n, p, m) {
        if (p === 1n)
            return n;
        if (p % 2n === 0n) {
            const t = power_mod(n, p >> 1n, m);
            return (t * t) % m;
        }
        else {
            const t = power_mod(n, p >> 1n, m);
            return (t * t * n) % m;
        }
    }
    exports_110("power_mod", power_mod);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/base64@v0.2.1/base", [], function (exports_111, context_111) {
    "use strict";
    var __moduleName = context_111 && context_111.id;
    function getLengths(b64) {
        const len = b64.length;
        let validLen = b64.indexOf("=");
        if (validLen === -1) {
            validLen = len;
        }
        const placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);
        return [validLen, placeHoldersLen];
    }
    function init(lookup, revLookup, urlsafe = false) {
        function _byteLength(validLen, placeHoldersLen) {
            return Math.floor(((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen);
        }
        function tripletToBase64(num) {
            return (lookup[(num >> 18) & 0x3f] +
                lookup[(num >> 12) & 0x3f] +
                lookup[(num >> 6) & 0x3f] +
                lookup[num & 0x3f]);
        }
        function encodeChunk(buf, start, end) {
            const out = new Array((end - start) / 3);
            for (let i = start, curTriplet = 0; i < end; i += 3) {
                out[curTriplet++] = tripletToBase64((buf[i] << 16) + (buf[i + 1] << 8) + buf[i + 2]);
            }
            return out.join("");
        }
        return {
            byteLength(b64) {
                return _byteLength.apply(null, getLengths(b64));
            },
            toUint8Array(b64) {
                const [validLen, placeHoldersLen] = getLengths(b64);
                const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));
                const len = placeHoldersLen ? validLen - 4 : validLen;
                let tmp;
                let curByte = 0;
                let i;
                for (i = 0; i < len; i += 4) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 18) |
                        (revLookup[b64.charCodeAt(i + 1)] << 12) |
                        (revLookup[b64.charCodeAt(i + 2)] << 6) |
                        revLookup[b64.charCodeAt(i + 3)];
                    buf[curByte++] = (tmp >> 16) & 0xff;
                    buf[curByte++] = (tmp >> 8) & 0xff;
                    buf[curByte++] = tmp & 0xff;
                }
                if (placeHoldersLen === 2) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 2) |
                        (revLookup[b64.charCodeAt(i + 1)] >> 4);
                    buf[curByte++] = tmp & 0xff;
                }
                else if (placeHoldersLen === 1) {
                    tmp = (revLookup[b64.charCodeAt(i)] << 10) |
                        (revLookup[b64.charCodeAt(i + 1)] << 4) |
                        (revLookup[b64.charCodeAt(i + 2)] >> 2);
                    buf[curByte++] = (tmp >> 8) & 0xff;
                    buf[curByte++] = tmp & 0xff;
                }
                return buf;
            },
            fromUint8Array(buf) {
                const maxChunkLength = 16383;
                const len = buf.length;
                const extraBytes = len % 3;
                const len2 = len - extraBytes;
                const parts = new Array(Math.ceil(len2 / maxChunkLength) + (extraBytes ? 1 : 0));
                let curChunk = 0;
                let chunkEnd;
                for (let i = 0; i < len2; i += maxChunkLength) {
                    chunkEnd = i + maxChunkLength;
                    parts[curChunk++] = encodeChunk(buf, i, chunkEnd > len2 ? len2 : chunkEnd);
                }
                let tmp;
                if (extraBytes === 1) {
                    tmp = buf[len2];
                    parts[curChunk] = lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f];
                    if (!urlsafe)
                        parts[curChunk] += "==";
                }
                else if (extraBytes === 2) {
                    tmp = (buf[len2] << 8) | (buf[len2 + 1] & 0xff);
                    parts[curChunk] = lookup[tmp >> 10] +
                        lookup[(tmp >> 4) & 0x3f] +
                        lookup[(tmp << 2) & 0x3f];
                    if (!urlsafe)
                        parts[curChunk] += "=";
                }
                return parts.join("");
            },
        };
    }
    exports_111("init", init);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/base64@v0.2.1/base64url", ["https://deno.land/x/base64@v0.2.1/base"], function (exports_112, context_112) {
    "use strict";
    var base_ts_1, lookup, revLookup, code, _a, byteLength, toUint8Array, fromUint8Array;
    var __moduleName = context_112 && context_112.id;
    return {
        setters: [
            function (base_ts_1_1) {
                base_ts_1 = base_ts_1_1;
            }
        ],
        execute: function () {
            lookup = [];
            revLookup = [];
            code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
            for (let i = 0, l = code.length; i < l; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
            }
            _a = base_ts_1.init(lookup, revLookup, true), exports_112("byteLength", byteLength = _a.byteLength), exports_112("toUint8Array", toUint8Array = _a.toUint8Array), exports_112("fromUint8Array", fromUint8Array = _a.fromUint8Array);
        }
    };
});
System.register("https://raw.githubusercontent.com/chiefbiiko/std-encoding/v1.0.0/mod", ["https://deno.land/x/base64@v0.2.1/base64url"], function (exports_113, context_113) {
    "use strict";
    var base64url_ts_1, decoder, encoder;
    var __moduleName = context_113 && context_113.id;
    function toHexString(buf) {
        return buf.reduce((hex, byte) => `${hex}${byte < 16 ? "0" : ""}${byte.toString(16)}`, "");
    }
    function fromHexString(hex) {
        const len = hex.length;
        if (len % 2 || !/^[0-9a-fA-F]+$/.test(hex)) {
            throw new TypeError("Invalid hex string.");
        }
        hex = hex.toLowerCase();
        const buf = new Uint8Array(Math.floor(len / 2));
        const end = len / 2;
        for (let i = 0; i < end; ++i) {
            buf[i] = parseInt(hex.substr(i * 2, 2), 16);
        }
        return buf;
    }
    function decode(buf, encoding = "utf8") {
        if (/^utf-?8$/i.test(encoding)) {
            return decoder.decode(buf);
        }
        else if (/^base64$/i.test(encoding)) {
            return base64url_ts_1.fromUint8Array(buf);
        }
        else if (/^hex(?:adecimal)?$/i.test(encoding)) {
            return toHexString(buf);
        }
        else {
            throw new TypeError("Unsupported string encoding.");
        }
    }
    exports_113("decode", decode);
    function encode(str, encoding = "utf8") {
        if (/^utf-?8$/i.test(encoding)) {
            return encoder.encode(str);
        }
        else if (/^base64$/i.test(encoding)) {
            return base64url_ts_1.toUint8Array(str);
        }
        else if (/^hex(?:adecimal)?$/i.test(encoding)) {
            return fromHexString(str);
        }
        else {
            throw new TypeError("Unsupported string encoding.");
        }
    }
    exports_113("encode", encode);
    return {
        setters: [
            function (base64url_ts_1_1) {
                base64url_ts_1 = base64url_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
        }
    };
});
System.register("https://raw.githubusercontent.com/chiefbiiko/sha1/v1.0.3/deps", ["https://raw.githubusercontent.com/chiefbiiko/std-encoding/v1.0.0/mod"], function (exports_114, context_114) {
    "use strict";
    var __moduleName = context_114 && context_114.id;
    return {
        setters: [
            function (mod_ts_18_1) {
                exports_114({
                    "encode": mod_ts_18_1["encode"],
                    "decode": mod_ts_18_1["decode"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://raw.githubusercontent.com/chiefbiiko/sha1/v1.0.3/mod", ["https://raw.githubusercontent.com/chiefbiiko/sha1/v1.0.3/deps"], function (exports_115, context_115) {
    "use strict";
    var deps_ts_21, BYTES, SHA1;
    var __moduleName = context_115 && context_115.id;
    function rotl(x, n) {
        return (x << n) | (x >>> (32 - n));
    }
    function sha1(msg, inputEncoding, outputEncoding) {
        return new SHA1().update(msg, inputEncoding).digest(outputEncoding);
    }
    exports_115("sha1", sha1);
    return {
        setters: [
            function (deps_ts_21_1) {
                deps_ts_21 = deps_ts_21_1;
            }
        ],
        execute: function () {
            exports_115("BYTES", BYTES = 20);
            SHA1 = class SHA1 {
                constructor() {
                    this.hashSize = BYTES;
                    this._buf = new Uint8Array(64);
                    this._K = new Uint32Array([0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6]);
                    this.init();
                }
                static F(t, b, c, d) {
                    if (t <= 19) {
                        return (b & c) | (~b & d);
                    }
                    else if (t <= 39) {
                        return b ^ c ^ d;
                    }
                    else if (t <= 59) {
                        return (b & c) | (b & d) | (c & d);
                    }
                    else {
                        return b ^ c ^ d;
                    }
                }
                init() {
                    this._H = new Uint32Array([
                        0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
                    ]);
                    this._bufIdx = 0;
                    this._count = new Uint32Array(2);
                    this._buf.fill(0);
                    this._finalized = false;
                    return this;
                }
                update(msg, inputEncoding) {
                    if (msg === null) {
                        throw new TypeError("msg must be a string or Uint8Array.");
                    }
                    else if (typeof msg === "string") {
                        msg = deps_ts_21.encode(msg, inputEncoding);
                    }
                    for (let i = 0; i < msg.length; i++) {
                        this._buf[this._bufIdx++] = msg[i];
                        if (this._bufIdx === 64) {
                            this.transform();
                            this._bufIdx = 0;
                        }
                    }
                    const c = this._count;
                    if ((c[0] += msg.length << 3) < msg.length << 3) {
                        c[1]++;
                    }
                    c[1] += msg.length >>> 29;
                    return this;
                }
                digest(outputEncoding) {
                    if (this._finalized) {
                        throw new Error("digest has already been called.");
                    }
                    this._finalized = true;
                    const b = this._buf;
                    let idx = this._bufIdx;
                    b[idx++] = 0x80;
                    while (idx !== 56) {
                        if (idx === 64) {
                            this.transform();
                            idx = 0;
                        }
                        b[idx++] = 0;
                    }
                    const c = this._count;
                    b[56] = (c[1] >>> 24) & 0xff;
                    b[57] = (c[1] >>> 16) & 0xff;
                    b[58] = (c[1] >>> 8) & 0xff;
                    b[59] = (c[1] >>> 0) & 0xff;
                    b[60] = (c[0] >>> 24) & 0xff;
                    b[61] = (c[0] >>> 16) & 0xff;
                    b[62] = (c[0] >>> 8) & 0xff;
                    b[63] = (c[0] >>> 0) & 0xff;
                    this.transform();
                    const hash = new Uint8Array(BYTES);
                    for (let i = 0; i < 5; i++) {
                        hash[(i << 2) + 0] = (this._H[i] >>> 24) & 0xff;
                        hash[(i << 2) + 1] = (this._H[i] >>> 16) & 0xff;
                        hash[(i << 2) + 2] = (this._H[i] >>> 8) & 0xff;
                        hash[(i << 2) + 3] = (this._H[i] >>> 0) & 0xff;
                    }
                    this.init();
                    return outputEncoding ? deps_ts_21.decode(hash, outputEncoding) : hash;
                }
                transform() {
                    const h = this._H;
                    let a = h[0];
                    let b = h[1];
                    let c = h[2];
                    let d = h[3];
                    let e = h[4];
                    const w = new Uint32Array(80);
                    for (let i = 0; i < 16; i++) {
                        w[i] =
                            this._buf[(i << 2) + 3] |
                                (this._buf[(i << 2) + 2] << 8) |
                                (this._buf[(i << 2) + 1] << 16) |
                                (this._buf[i << 2] << 24);
                    }
                    for (let t = 0; t < 80; t++) {
                        if (t >= 16) {
                            w[t] = rotl(w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16], 1);
                        }
                        const tmp = (rotl(a, 5) +
                            SHA1.F(t, b, c, d) +
                            e +
                            w[t] +
                            this._K[Math.floor(t / 20)]) |
                            0;
                        e = d;
                        d = c;
                        c = rotl(b, 30);
                        b = a;
                        a = tmp;
                    }
                    h[0] = (h[0] + a) | 0;
                    h[1] = (h[1] + b) | 0;
                    h[2] = (h[2] + c) | 0;
                    h[3] = (h[3] + d) | 0;
                    h[4] = (h[4] + e) | 0;
                }
            };
            exports_115("SHA1", SHA1);
        }
    };
});
System.register("https://raw.githubusercontent.com/chiefbiiko/sha256/v1.0.2/deps", ["https://raw.githubusercontent.com/chiefbiiko/std-encoding/v1.0.0/mod"], function (exports_116, context_116) {
    "use strict";
    var __moduleName = context_116 && context_116.id;
    return {
        setters: [
            function (mod_ts_19_1) {
                exports_116({
                    "encode": mod_ts_19_1["encode"],
                    "decode": mod_ts_19_1["decode"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://raw.githubusercontent.com/chiefbiiko/sha256/v1.0.2/mod", ["https://raw.githubusercontent.com/chiefbiiko/sha256/v1.0.2/deps"], function (exports_117, context_117) {
    "use strict";
    var deps_ts_22, BYTES, SHA256;
    var __moduleName = context_117 && context_117.id;
    function sha256(msg, inputEncoding, outputEncoding) {
        return new SHA256().update(msg, inputEncoding).digest(outputEncoding);
    }
    exports_117("sha256", sha256);
    return {
        setters: [
            function (deps_ts_22_1) {
                deps_ts_22 = deps_ts_22_1;
            }
        ],
        execute: function () {
            exports_117("BYTES", BYTES = 32);
            SHA256 = class SHA256 {
                constructor() {
                    this.hashSize = BYTES;
                    this._buf = new Uint8Array(64);
                    this._K = new Uint32Array([
                        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
                        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
                        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
                        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
                        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
                    ]);
                    this.init();
                }
                init() {
                    this._H = new Uint32Array([
                        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                    ]);
                    this._bufIdx = 0;
                    this._count = new Uint32Array(2);
                    this._buf.fill(0);
                    this._finalized = false;
                    return this;
                }
                update(msg, inputEncoding) {
                    if (msg === null) {
                        throw new TypeError("msg must be a string or Uint8Array.");
                    }
                    else if (typeof msg === "string") {
                        msg = deps_ts_22.encode(msg, inputEncoding);
                    }
                    for (let i = 0, len = msg.length; i < len; i++) {
                        this._buf[this._bufIdx++] = msg[i];
                        if (this._bufIdx === 64) {
                            this._transform();
                            this._bufIdx = 0;
                        }
                    }
                    const c = this._count;
                    if ((c[0] += msg.length << 3) < msg.length << 3) {
                        c[1]++;
                    }
                    c[1] += msg.length >>> 29;
                    return this;
                }
                digest(outputEncoding) {
                    if (this._finalized) {
                        throw new Error("digest has already been called.");
                    }
                    this._finalized = true;
                    const b = this._buf;
                    let idx = this._bufIdx;
                    b[idx++] = 0x80;
                    while (idx !== 56) {
                        if (idx === 64) {
                            this._transform();
                            idx = 0;
                        }
                        b[idx++] = 0;
                    }
                    const c = this._count;
                    b[56] = (c[1] >>> 24) & 0xff;
                    b[57] = (c[1] >>> 16) & 0xff;
                    b[58] = (c[1] >>> 8) & 0xff;
                    b[59] = (c[1] >>> 0) & 0xff;
                    b[60] = (c[0] >>> 24) & 0xff;
                    b[61] = (c[0] >>> 16) & 0xff;
                    b[62] = (c[0] >>> 8) & 0xff;
                    b[63] = (c[0] >>> 0) & 0xff;
                    this._transform();
                    const hash = new Uint8Array(BYTES);
                    for (let i = 0; i < 8; i++) {
                        hash[(i << 2) + 0] = (this._H[i] >>> 24) & 0xff;
                        hash[(i << 2) + 1] = (this._H[i] >>> 16) & 0xff;
                        hash[(i << 2) + 2] = (this._H[i] >>> 8) & 0xff;
                        hash[(i << 2) + 3] = (this._H[i] >>> 0) & 0xff;
                    }
                    this.init();
                    return outputEncoding ? deps_ts_22.decode(hash, outputEncoding) : hash;
                }
                _transform() {
                    const h = this._H;
                    let h0 = h[0];
                    let h1 = h[1];
                    let h2 = h[2];
                    let h3 = h[3];
                    let h4 = h[4];
                    let h5 = h[5];
                    let h6 = h[6];
                    let h7 = h[7];
                    const w = new Uint32Array(16);
                    let i;
                    for (i = 0; i < 16; i++) {
                        w[i] =
                            this._buf[(i << 2) + 3] |
                                (this._buf[(i << 2) + 2] << 8) |
                                (this._buf[(i << 2) + 1] << 16) |
                                (this._buf[i << 2] << 24);
                    }
                    for (i = 0; i < 64; i++) {
                        let tmp;
                        if (i < 16) {
                            tmp = w[i];
                        }
                        else {
                            let a = w[(i + 1) & 15];
                            let b = w[(i + 14) & 15];
                            tmp = w[i & 15] =
                                (((a >>> 7) ^ (a >>> 18) ^ (a >>> 3) ^ (a << 25) ^ (a << 14)) +
                                    ((b >>> 17) ^ (b >>> 19) ^ (b >>> 10) ^ (b << 15) ^ (b << 13)) +
                                    w[i & 15] +
                                    w[(i + 9) & 15]) |
                                    0;
                        }
                        tmp =
                            (tmp +
                                h7 +
                                ((h4 >>> 6) ^
                                    (h4 >>> 11) ^
                                    (h4 >>> 25) ^
                                    (h4 << 26) ^
                                    (h4 << 21) ^
                                    (h4 << 7)) +
                                (h6 ^ (h4 & (h5 ^ h6))) +
                                this._K[i]) |
                                0;
                        h7 = h6;
                        h6 = h5;
                        h5 = h4;
                        h4 = h3 + tmp;
                        h3 = h2;
                        h2 = h1;
                        h1 = h0;
                        h0 =
                            (tmp +
                                ((h1 & h2) ^ (h3 & (h1 ^ h2))) +
                                ((h1 >>> 2) ^
                                    (h1 >>> 13) ^
                                    (h1 >>> 22) ^
                                    (h1 << 30) ^
                                    (h1 << 19) ^
                                    (h1 << 10))) |
                                0;
                    }
                    h[0] = (h[0] + h0) | 0;
                    h[1] = (h[1] + h1) | 0;
                    h[2] = (h[2] + h2) | 0;
                    h[3] = (h[3] + h3) | 0;
                    h[4] = (h[4] + h4) | 0;
                    h[5] = (h[5] + h5) | 0;
                    h[6] = (h[6] + h6) | 0;
                    h[7] = (h[7] + h7) | 0;
                }
            };
            exports_117("SHA256", SHA256);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hash", ["https://raw.githubusercontent.com/chiefbiiko/sha1/v1.0.3/mod", "https://raw.githubusercontent.com/chiefbiiko/sha256/v1.0.2/mod"], function (exports_118, context_118) {
    "use strict";
    var mod_ts_20, mod_ts_21;
    var __moduleName = context_118 && context_118.id;
    function createHash(algorithm) {
        return new class {
            constructor() {
                this.m = new Uint8Array();
            }
            update(b) {
                this.m = b;
                return this;
            }
            digest() {
                if (algorithm === "sha1") {
                    return mod_ts_20.sha1(this.m);
                }
                else if (algorithm === "sha256") {
                    return mod_ts_21.sha256(this.m);
                }
                throw "Unsupport hash algorithm";
            }
        }();
    }
    exports_118("createHash", createHash);
    return {
        setters: [
            function (mod_ts_20_1) {
                mod_ts_20 = mod_ts_20_1;
            },
            function (mod_ts_21_1) {
                mod_ts_21 = mod_ts_21_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/primitives", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hash"], function (exports_119, context_119) {
    "use strict";
    var hash_ts_2;
    var __moduleName = context_119 && context_119.id;
    function i2osp(x, length) {
        const t = new Uint8Array(length);
        for (let i = length - 1; i >= 0; i--) {
            if (x === 0n)
                break;
            t[i] = Number(x & 255n);
            x = x >> 8n;
        }
        return t;
    }
    exports_119("i2osp", i2osp);
    function os2ip(m) {
        let n = 0n;
        for (const c of m)
            n = (n << 8n) + BigInt(c);
        return n;
    }
    exports_119("os2ip", os2ip);
    function mgf1(seed, length, hash) {
        let counter = 0n;
        let output = [];
        while (output.length < length) {
            let h;
            const c = i2osp(counter, 4);
            if (typeof hash === "function") {
                h = hash(new Uint8Array([...seed, ...c]));
            }
            else {
                h = new Uint8Array(hash_ts_2.createHash(hash).update(new Uint8Array([...seed, ...c])).digest());
            }
            output = [...output, ...h];
            counter++;
        }
        return new Uint8Array(output.slice(0, length));
    }
    exports_119("mgf1", mgf1);
    return {
        setters: [
            function (hash_ts_2_1) {
                hash_ts_2 = hash_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/eme_oaep", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hash", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/primitives", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/helper"], function (exports_120, context_120) {
    "use strict";
    var hash_ts_3, primitives_ts_1, helper_ts_2;
    var __moduleName = context_120 && context_120.id;
    function eme_oaep_encode(label, m, k, algorithm) {
        const labelHash = new Uint8Array(hash_ts_3.createHash(algorithm).update(label).digest());
        const ps = new Uint8Array(k - labelHash.length * 2 - 2 - m.length);
        const db = helper_ts_2.concat(labelHash, ps, [0x01], m);
        const seed = helper_ts_2.random_bytes(labelHash.length);
        const dbMask = primitives_ts_1.mgf1(seed, k - labelHash.length - 1, algorithm);
        const maskedDb = helper_ts_2.xor(db, dbMask);
        const seedMask = primitives_ts_1.mgf1(maskedDb, labelHash.length, algorithm);
        const maskedSeed = helper_ts_2.xor(seed, seedMask);
        return helper_ts_2.concat([0x00], maskedSeed, maskedDb);
    }
    exports_120("eme_oaep_encode", eme_oaep_encode);
    function eme_oaep_decode(label, c, k, algorithm) {
        const labelHash = new Uint8Array(hash_ts_3.createHash(algorithm).update(label).digest());
        const maskedSeed = c.slice(1, 1 + labelHash.length);
        const maskedDb = c.slice(1 + labelHash.length);
        const seedMask = primitives_ts_1.mgf1(maskedDb, labelHash.length, algorithm);
        const seed = helper_ts_2.xor(maskedSeed, seedMask);
        const dbMask = primitives_ts_1.mgf1(seed, k - labelHash.length - 1, algorithm);
        const db = helper_ts_2.xor(maskedDb, dbMask);
        let ptr = labelHash.length;
        while (ptr < db.length && db[ptr] === 0)
            ptr++;
        return db.slice(ptr + 1);
    }
    exports_120("eme_oaep_decode", eme_oaep_decode);
    return {
        setters: [
            function (hash_ts_3_1) {
                hash_ts_3 = hash_ts_3_1;
            },
            function (primitives_ts_1_1) {
                primitives_ts_1 = primitives_ts_1_1;
            },
            function (helper_ts_2_1) {
                helper_ts_2 = helper_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/basic_encoding_rule", [], function (exports_121, context_121) {
    "use strict";
    var __moduleName = context_121 && context_121.id;
    function ber_decode(bytes, from, to) {
        return ber_next(bytes);
    }
    exports_121("ber_decode", ber_decode);
    function ber_sequence(bytes, from, length) {
        const end = from + length;
        let res = [];
        let ptr = from;
        while (ptr < end) {
            const next = ber_next(bytes, ptr);
            res.push(next);
            ptr += next.totalLength;
        }
        return res;
    }
    function ber_integer(bytes, from, length) {
        let n = 0n;
        for (const b of bytes.slice(from, from + length)) {
            n = (n << 8n) + BigInt(b);
        }
        return n;
    }
    function ber_oid(bytes, from, length) {
        const id = [
            (bytes[from] / 40) | 0,
            (bytes[from] % 40),
        ];
        let value = 0;
        for (const b of bytes.slice(from + 1, from + length)) {
            if (b > 128)
                value += value * 127 + (b - 128);
            else {
                value = value * 128 + b;
                id.push(value);
                value = 0;
            }
        }
        return id.join(".");
    }
    function ber_unknown(bytes, from, length) {
        return bytes.slice(from, from + length);
    }
    function ber_simple(n) {
        if (Array.isArray(n.value))
            return n.value.map((x) => ber_simple(x));
        return n.value;
    }
    exports_121("ber_simple", ber_simple);
    function ber_next(bytes, from, to) {
        if (!from)
            from = 0;
        if (!to)
            to = bytes.length;
        let ptr = from;
        const type = bytes[ptr++];
        let size = bytes[ptr++];
        if ((size & 0x80) > 0) {
            let ext = size - 0x80;
            size = 0;
            while (--ext >= 0) {
                size = (size << 8) + bytes[ptr++];
            }
        }
        let value = null;
        if (type === 0x30) {
            value = ber_sequence(bytes, ptr, size);
        }
        else if (type === 0x2) {
            value = ber_integer(bytes, ptr, size);
        }
        else if (type === 0x3) {
            value = ber_sequence(bytes, ptr + 1, size - 1);
        }
        else if (type === 0x5) {
            value = null;
        }
        else if (type === 0x6) {
            value = ber_oid(bytes, ptr, size);
        }
        else {
            value = ber_unknown(bytes, ptr, size);
        }
        return {
            totalLength: (ptr - from) + size,
            type,
            length: size,
            value,
        };
    }
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_internal", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/math", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/eme_oaep", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/primitives", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/helper", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/basic_encoding_rule", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary"], function (exports_122, context_122) {
    "use strict";
    var math_ts_1, eme_oaep_ts_1, primitives_ts_2, helper_ts_3, basic_encoding_rule_ts_1, binary_ts_2;
    var __moduleName = context_122 && context_122.id;
    function rsaep(n, e, m) {
        return math_ts_1.power_mod(m, e, n);
    }
    exports_122("rsaep", rsaep);
    function rsadp(n, d, c) {
        return math_ts_1.power_mod(c, d, n);
    }
    exports_122("rsadp", rsadp);
    function rsa_oaep_encrypt(bytes, n, e, m, algorithm) {
        const em = eme_oaep_ts_1.eme_oaep_encode(new Uint8Array(0), m, bytes, algorithm);
        const msg = primitives_ts_2.os2ip(em);
        const c = rsaep(n, e, msg);
        return primitives_ts_2.i2osp(c, bytes);
    }
    exports_122("rsa_oaep_encrypt", rsa_oaep_encrypt);
    function rsa_oaep_decrypt(bytes, n, d, c, algorithm) {
        const em = rsadp(n, d, primitives_ts_2.os2ip(c));
        const m = eme_oaep_ts_1.eme_oaep_decode(new Uint8Array(0), primitives_ts_2.i2osp(em, bytes), bytes, algorithm);
        return m;
    }
    exports_122("rsa_oaep_decrypt", rsa_oaep_decrypt);
    function rsa_pkcs1_encrypt(bytes, n, e, m) {
        const p = helper_ts_3.concat([0x00, 0x02], helper_ts_3.random_bytes(bytes - m.length - 3), [0x00], m);
        const msg = primitives_ts_2.os2ip(p);
        const c = rsaep(n, e, msg);
        return primitives_ts_2.i2osp(c, bytes);
    }
    exports_122("rsa_pkcs1_encrypt", rsa_pkcs1_encrypt);
    function rsa_pkcs1_decrypt(bytes, n, d, c) {
        const em = primitives_ts_2.i2osp(rsadp(n, d, primitives_ts_2.os2ip(c)), bytes);
        if (em[0] !== 0)
            throw "Decryption error";
        if (em[1] !== 0x02)
            throw "Decryption error";
        let psCursor = 2;
        for (; psCursor < em.length; psCursor++) {
            if (em[psCursor] === 0x00)
                break;
        }
        if (psCursor < 10)
            throw "Decryption error";
        return em.slice(psCursor + 1);
    }
    exports_122("rsa_pkcs1_decrypt", rsa_pkcs1_decrypt);
    function rsa_pkcs1_verify(bytes, n, d, s, m) {
        let em = primitives_ts_2.i2osp(rsadp(n, d, primitives_ts_2.os2ip(s)), bytes);
        if (em[0] !== 0)
            throw "Decryption error";
        if (em[1] !== 0x01)
            throw "Decryption error";
        let psCursor = 2;
        for (; psCursor < em.length; psCursor++) {
            if (em[psCursor] === 0x00)
                break;
        }
        if (psCursor < 10)
            throw "Decryption error";
        em = em.slice(psCursor + 1);
        const ber = basic_encoding_rule_ts_1.ber_simple(basic_encoding_rule_ts_1.ber_decode(em));
        const decryptedMessage = ber[1];
        if (decryptedMessage.length !== m.length)
            return false;
        for (let i = 0; i < decryptedMessage.length; i++) {
            if (decryptedMessage[i] !== m[i])
                return false;
        }
        return true;
    }
    exports_122("rsa_pkcs1_verify", rsa_pkcs1_verify);
    function rsa_pkcs1_sign(bytes, n, d, message) {
        const oid = [0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00];
        const der = [
            0x30,
            message.length + 2 + oid.length,
            ...oid,
            0x04,
            message.length,
            ...message,
        ];
        const ps = new Array(bytes - 3 - der.length).fill(0xff);
        const em = new Uint8Array([0x00, 0x01, ...ps, 0x00, ...der]);
        const msg = primitives_ts_2.os2ip(em);
        const c = rsaep(n, d, msg);
        return new binary_ts_2.RawBinary(primitives_ts_2.i2osp(c, bytes));
    }
    exports_122("rsa_pkcs1_sign", rsa_pkcs1_sign);
    return {
        setters: [
            function (math_ts_1_1) {
                math_ts_1 = math_ts_1_1;
            },
            function (eme_oaep_ts_1_1) {
                eme_oaep_ts_1 = eme_oaep_ts_1_1;
            },
            function (primitives_ts_2_1) {
                primitives_ts_2 = primitives_ts_2_1;
            },
            function (helper_ts_3_1) {
                helper_ts_3 = helper_ts_3_1;
            },
            function (basic_encoding_rule_ts_1_1) {
                basic_encoding_rule_ts_1 = basic_encoding_rule_ts_1_1;
            },
            function (binary_ts_2_1) {
                binary_ts_2 = binary_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_js", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_internal", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hash"], function (exports_123, context_123) {
    "use strict";
    var rsa_internal_ts_1, binary_ts_3, hash_ts_4, PureRSA;
    var __moduleName = context_123 && context_123.id;
    return {
        setters: [
            function (rsa_internal_ts_1_1) {
                rsa_internal_ts_1 = rsa_internal_ts_1_1;
            },
            function (binary_ts_3_1) {
                binary_ts_3 = binary_ts_3_1;
            },
            function (hash_ts_4_1) {
                hash_ts_4 = hash_ts_4_1;
            }
        ],
        execute: function () {
            PureRSA = class PureRSA {
                static async encrypt(key, message, options) {
                    if (!key.e)
                        throw "Invalid RSA key";
                    if (options.padding === "oaep") {
                        return new binary_ts_3.RawBinary(rsa_internal_ts_1.rsa_oaep_encrypt(key.length, key.n, key.e, message, options.hash));
                    }
                    else if (options.padding === "pkcs1") {
                        return new binary_ts_3.RawBinary(rsa_internal_ts_1.rsa_pkcs1_encrypt(key.length, key.n, key.e, message));
                    }
                    throw "Invalid parameters";
                }
                static async decrypt(key, ciper, options) {
                    if (!key.d)
                        throw "Invalid RSA key";
                    if (options.padding === "oaep") {
                        return new binary_ts_3.RawBinary(rsa_internal_ts_1.rsa_oaep_decrypt(key.length, key.n, key.d, ciper, options.hash));
                    }
                    else if (options.padding === "pkcs1") {
                        return new binary_ts_3.RawBinary(rsa_internal_ts_1.rsa_pkcs1_decrypt(key.length, key.n, key.d, ciper));
                    }
                    throw "Invalid parameters";
                }
                static async verify(key, signature, message, options) {
                    if (!key.e)
                        throw "Invalid RSA key";
                    return rsa_internal_ts_1.rsa_pkcs1_verify(key.length, key.n, key.e, signature, hash_ts_4.createHash(options.hash).update(message).digest());
                }
                static async sign(key, message, options) {
                    if (!key.d)
                        throw "You need private key to sign the message";
                    return rsa_internal_ts_1.rsa_pkcs1_sign(key.length, key.n, key.d, hash_ts_4.createHash(options.hash).update(message).digest());
                }
            };
            exports_123("PureRSA", PureRSA);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/import_key", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/utility/encode", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/helper", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/basic_encoding_rule", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/primitives"], function (exports_124, context_124) {
    "use strict";
    var encode_ts_4, helper_ts_4, basic_encoding_rule_ts_2, primitives_ts_3;
    var __moduleName = context_124 && context_124.id;
    function detect_format(key) {
        if (typeof key === "object") {
            if (key.kty === "RSA")
                return "jwk";
        }
        else if (typeof key === "string") {
            if (key.substr(0, "-----".length) === "-----")
                return "pem";
        }
        throw new TypeError("Unsupported key format");
    }
    function rsa_import_jwk(key) {
        if (typeof key !== "object")
            throw new TypeError("Invalid JWK format");
        if (!key.n)
            throw new TypeError("RSA key requires n");
        const n = primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.n));
        return {
            e: key.e ? primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.e)) : undefined,
            n: primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.n)),
            d: key.d ? primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.d)) : undefined,
            p: key.p ? primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.p)) : undefined,
            q: key.q ? primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.q)) : undefined,
            dp: key.dp ? primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.dp)) : undefined,
            dq: key.dq ? primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.dq)) : undefined,
            qi: key.qi ? primitives_ts_3.os2ip(encode_ts_4.encode.base64url(key.qi)) : undefined,
            length: helper_ts_4.get_key_size(n),
        };
    }
    function rsa_import_pem_cert(key) {
        const trimmedKey = key.substr(27, key.length - 53);
        const parseKey = basic_encoding_rule_ts_2.ber_simple(basic_encoding_rule_ts_2.ber_decode(helper_ts_4.base64_to_binary(trimmedKey)));
        return {
            length: helper_ts_4.get_key_size(parseKey[0][5][1][0][0]),
            n: parseKey[0][5][1][0][0],
            e: parseKey[0][5][1][0][1],
        };
    }
    function rsa_import_pem_private(key) {
        const trimmedKey = key.substr(31, key.length - 61);
        const parseKey = basic_encoding_rule_ts_2.ber_simple(basic_encoding_rule_ts_2.ber_decode(helper_ts_4.base64_to_binary(trimmedKey)));
        return {
            n: parseKey[1],
            d: parseKey[3],
            e: parseKey[2],
            p: parseKey[4],
            q: parseKey[5],
            dp: parseKey[6],
            dq: parseKey[7],
            qi: parseKey[8],
            length: helper_ts_4.get_key_size(parseKey[1]),
        };
    }
    function rsa_import_pem_public(key) {
        const trimmedKey = key.substr(26, key.length - 51);
        const parseKey = basic_encoding_rule_ts_2.ber_simple(basic_encoding_rule_ts_2.ber_decode(helper_ts_4.base64_to_binary(trimmedKey)));
        return {
            length: helper_ts_4.get_key_size(parseKey[1][0][0]),
            n: parseKey[1][0][0],
            e: parseKey[1][0][1],
        };
    }
    function rsa_import_pem(key) {
        if (typeof key !== "string")
            throw new TypeError("PEM key must be string");
        const maps = [
            ["-----BEGIN RSA PRIVATE KEY-----", rsa_import_pem_private],
            ["-----BEGIN PUBLIC KEY-----", rsa_import_pem_public],
            ["-----BEGIN CERTIFICATE-----", rsa_import_pem_cert],
        ];
        for (const [prefix, func] of maps) {
            if (key.indexOf(prefix) === 0)
                return func(key);
        }
        throw new TypeError("Unsupported key format");
    }
    function rsa_import_key(key, format) {
        const finalFormat = format === "auto" ? detect_format(key) : format;
        if (finalFormat === "jwk")
            return rsa_import_jwk(key);
        if (finalFormat === "pem")
            return rsa_import_pem(key);
        throw new TypeError("Unsupported key format");
    }
    exports_124("rsa_import_key", rsa_import_key);
    return {
        setters: [
            function (encode_ts_4_1) {
                encode_ts_4 = encode_ts_4_1;
            },
            function (helper_ts_4_1) {
                helper_ts_4 = helper_ts_4_1;
            },
            function (basic_encoding_rule_ts_2_1) {
                basic_encoding_rule_ts_2 = basic_encoding_rule_ts_2_1;
            },
            function (primitives_ts_3_1) {
                primitives_ts_3 = primitives_ts_3_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/mod", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_wc", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_js", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/import_key", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/rsa_key"], function (exports_125, context_125) {
    "use strict";
    var rsa_wc_ts_1, rsa_js_ts_1, binary_ts_4, import_key_ts_1, rsa_key_ts_1, RSA;
    var __moduleName = context_125 && context_125.id;
    function computeMessage(m) {
        return typeof m === "string" ? new TextEncoder().encode(m) : m;
    }
    function computeOption(options) {
        return {
            hash: "sha1",
            padding: "oaep",
            ...options,
        };
    }
    return {
        setters: [
            function (rsa_wc_ts_1_1) {
                rsa_wc_ts_1 = rsa_wc_ts_1_1;
            },
            function (rsa_js_ts_1_1) {
                rsa_js_ts_1 = rsa_js_ts_1_1;
            },
            function (binary_ts_4_1) {
                binary_ts_4 = binary_ts_4_1;
            },
            function (import_key_ts_1_1) {
                import_key_ts_1 = import_key_ts_1_1;
            },
            function (rsa_key_ts_1_1) {
                rsa_key_ts_1 = rsa_key_ts_1_1;
            }
        ],
        execute: function () {
            RSA = class RSA {
                constructor(key) {
                    this.key = key;
                }
                async encrypt(m, options) {
                    const computedOption = computeOption(options);
                    const func = rsa_wc_ts_1.WebCryptoRSA.isSupported(computedOption)
                        ? rsa_wc_ts_1.WebCryptoRSA.encrypt
                        : rsa_js_ts_1.PureRSA.encrypt;
                    return new binary_ts_4.RawBinary(await func(this.key, computeMessage(m), computedOption));
                }
                async decrypt(m, options) {
                    const computedOption = computeOption(options);
                    const func = rsa_wc_ts_1.WebCryptoRSA.isSupported(computedOption)
                        ? rsa_wc_ts_1.WebCryptoRSA.decrypt
                        : rsa_js_ts_1.PureRSA.decrypt;
                    return new binary_ts_4.RawBinary(await func(this.key, m, computedOption));
                }
                async verify(signature, message, options) {
                    const computedOption = {
                        ...options,
                        algorithm: "rsassa-pkcs1-v1_5",
                        hash: "sha256",
                    };
                    return await rsa_js_ts_1.PureRSA.verify(this.key, signature, computeMessage(message), computedOption);
                }
                async sign(message, options) {
                    const computedOption = {
                        ...options,
                        algorithm: "rsassa-pkcs1-v1_5",
                        hash: "sha256",
                    };
                    return await rsa_js_ts_1.PureRSA.sign(this.key, computeMessage(message), computedOption);
                }
                static parseKey(key, format = "auto") {
                    return this.importKey(key, format);
                }
                static importKey(key, format = "auto") {
                    return new rsa_key_ts_1.RSAKey(import_key_ts_1.rsa_import_key(key, format));
                }
            };
            exports_125("RSA", RSA);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/aes_base", [], function (exports_126, context_126) {
    "use strict";
    var AESBase;
    var __moduleName = context_126 && context_126.id;
    return {
        setters: [],
        execute: function () {
            AESBase = class AESBase {
            };
            exports_126("AESBase", AESBase);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/common", [], function (exports_127, context_127) {
    "use strict";
    var __moduleName = context_127 && context_127.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/aes_wc", [], function (exports_128, context_128) {
    "use strict";
    var WebCryptoAES;
    var __moduleName = context_128 && context_128.id;
    function base64(m) {
        return btoa(String.fromCharCode.apply(null, [...m])).replace(/=/g, "");
    }
    return {
        setters: [],
        execute: function () {
            WebCryptoAES = class WebCryptoAES {
                constructor(key, config) {
                    this.wkey = null;
                    this.key = key;
                    this.config = config;
                }
                async loadKey() {
                    if (this.wkey === null) {
                        this.wkey = await crypto.subtle.importKey("jwk", { kty: "oct", k: base64(this.key) }, "AES-CBC", true, ["encrypt", "decrypt"]);
                    }
                    return this.wkey;
                }
                async encrypt(m) {
                    const key = await this.loadKey();
                    const option = { name: "AES-CBC", iv: this.config.iv };
                    const data = await crypto.subtle.encrypt(option, key, m);
                    return new Uint8Array(data);
                }
                async decrypt(m) {
                    const key = await this.loadKey();
                    const option = { name: "AES-CBC", iv: this.config.iv };
                    const data = await crypto.subtle.decrypt(option, key, m);
                    return new Uint8Array(data);
                }
            };
            exports_128("WebCryptoAES", WebCryptoAES);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/block_ciper_operator", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/helper"], function (exports_129, context_129) {
    "use strict";
    var helper_ts_5, BlockCiper, ECB, CFB, CBC, BlockCiperOperation;
    var __moduleName = context_129 && context_129.id;
    function pad(m) {
        const blockNumber = Math.ceil((m.length + 1) / 16);
        const paddedMessageLength = blockNumber * 16;
        const remainedLength = paddedMessageLength - m.length;
        const paddedMessage = new Uint8Array(paddedMessageLength);
        paddedMessage.set(m, 0);
        paddedMessage.set(new Array(remainedLength).fill(remainedLength), m.length);
        return paddedMessage;
    }
    function unpad(m) {
        const lastByte = m[m.length - 1];
        return new Uint8Array(m.slice(0, m.length - lastByte));
    }
    return {
        setters: [
            function (helper_ts_5_1) {
                helper_ts_5 = helper_ts_5_1;
            }
        ],
        execute: function () {
            BlockCiper = class BlockCiper {
            };
            exports_129("BlockCiper", BlockCiper);
            ECB = class ECB {
                static encrypt(m, ciper, blockSize) {
                    if (m.length % blockSize !== 0)
                        throw "Message is not properly padded";
                    const output = new Uint8Array(m.length);
                    for (let i = 0; i < m.length; i += blockSize) {
                        output.set(ciper.encrypt(m.slice(i, i + blockSize)), i);
                    }
                    return output;
                }
                static decrypt(m, ciper, blockSize) {
                    if (m.length % blockSize !== 0)
                        throw "Message is not properly padded";
                    const output = new Uint8Array(m.length);
                    for (let i = 0; i < m.length; i += blockSize) {
                        output.set(ciper.decrypt(m.slice(i, i + blockSize)), i);
                    }
                    return output;
                }
            };
            CFB = class CFB {
                static encrypt(m, ciper, blockSize, iv) {
                    const output = new Uint8Array(m.length);
                    let prev = iv;
                    for (let i = 0; i < m.length; i += blockSize) {
                        prev = helper_ts_5.xor(m.slice(i, i + blockSize), ciper.encrypt(prev));
                        output.set(prev, i);
                    }
                    return output;
                }
                static decrypt(m, ciper, blockSize, iv) {
                    const output = new Uint8Array(m.length);
                    let prev = iv;
                    for (let i = 0; i < m.length; i += blockSize) {
                        const t = m.slice(i, Math.min(i + blockSize, m.length));
                        output.set(helper_ts_5.xor(t, ciper.encrypt(prev)), i);
                        prev = t;
                    }
                    return output;
                }
            };
            CBC = class CBC {
                static encrypt(m, ciper, blockSize, iv) {
                    const output = new Uint8Array(m.length);
                    let prev = iv;
                    for (let i = 0; i < m.length; i += blockSize) {
                        prev = ciper.encrypt(helper_ts_5.xor(m.slice(i, i + blockSize), prev));
                        output.set(prev, i);
                    }
                    return output;
                }
                static decrypt(m, ciper, blockSize, iv) {
                    const output = new Uint8Array(m.length);
                    let prev = iv;
                    for (let i = 0; i < m.length; i += blockSize) {
                        const t = m.slice(i, i + blockSize);
                        output.set(helper_ts_5.xor(ciper.decrypt(t), prev), i);
                        prev = t;
                    }
                    return output;
                }
            };
            BlockCiperOperation = class BlockCiperOperation {
                static encrypt(m, ciper, blockSize, config) {
                    const computedConfig = {
                        mode: "cbc",
                        padding: "pkcs5",
                        ...config,
                    };
                    const computedIV = typeof computedConfig.iv === "string"
                        ? new TextEncoder().encode(computedConfig.iv)
                        : computedConfig.iv;
                    if (blockSize !== computedIV?.length)
                        throw "Invalid IV size";
                    if (computedConfig.mode === "ecb") {
                        return ECB.encrypt(pad(m), ciper, 16);
                    }
                    else if (computedConfig.mode === "cbc") {
                        return CBC.encrypt(pad(m), ciper, 16, computedIV);
                    }
                    else if (computedConfig.mode === "cfb") {
                        return CFB.encrypt(m, ciper, 16, computedIV);
                    }
                    else
                        throw "Not implemented";
                }
                static decrypt(m, ciper, blockSize, config) {
                    const computedConfig = {
                        mode: "cbc",
                        padding: "pkcs5",
                        ...config,
                    };
                    const computedIV = typeof computedConfig.iv === "string"
                        ? new TextEncoder().encode(computedConfig.iv)
                        : computedConfig.iv;
                    if (blockSize !== computedIV?.length)
                        throw "Invalid IV size";
                    let output;
                    if (computedConfig.mode === "ecb") {
                        output = ECB.decrypt(m, ciper, 16);
                    }
                    else if (computedConfig.mode === "cbc") {
                        output = CBC.decrypt(m, ciper, 16, computedIV);
                    }
                    else if (computedConfig.mode === "cfb") {
                        return CFB.decrypt(m, ciper, 16, computedIV);
                    }
                    else
                        throw "Not implemented";
                    return unpad(output);
                }
            };
            exports_129("BlockCiperOperation", BlockCiperOperation);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/aes_js", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/block_ciper_operator"], function (exports_130, context_130) {
    "use strict";
    var block_ciper_operator_ts_1, SBOX, INV_SBOX, RCON, AESBlockCiper, PureAES;
    var __moduleName = context_130 && context_130.id;
    function xtime(n, x) {
        if (x === 1)
            return n;
        let output = 0;
        let multiply = n;
        while (x > 0) {
            if (x & 0x01)
                output ^= multiply;
            multiply = multiply & 0x80 ? multiply << 1 ^ 0x011b : multiply << 1;
            x = x >> 1;
        }
        return output & 0xff;
    }
    function rotWord(keySchedule, column) {
        const offset = column * 4;
        const tmp = keySchedule[offset];
        keySchedule[offset] = keySchedule[offset + 1];
        keySchedule[offset + 1] = keySchedule[offset + 2];
        keySchedule[offset + 2] = keySchedule[offset + 3];
        keySchedule[offset + 3] = tmp;
    }
    function subWord(keySchedule, column) {
        const offset = column * 4;
        for (let i = 0; i < 4; i++) {
            keySchedule[offset + i] = SBOX[keySchedule[offset + i]];
        }
    }
    function keyExpansion(key) {
        const Nb = 4;
        const Nk = key.length / 4;
        const Nr = Nk + 6;
        const keySchedule = new Uint8Array(16 * (Nr + 1));
        keySchedule.set(key, 0);
        for (let i = Nk; i < (Nb * (Nr + 1)); i++) {
            const prevOffset = (i - Nk) * 4;
            const offset = i * 4;
            keySchedule[offset] = keySchedule[offset - 4];
            keySchedule[offset + 1] = keySchedule[offset - 3];
            keySchedule[offset + 2] = keySchedule[offset - 2];
            keySchedule[offset + 3] = keySchedule[offset - 1];
            if (i % Nk === 0) {
                rotWord(keySchedule, i);
                subWord(keySchedule, i);
                keySchedule[offset] ^= RCON[i / Nk];
            }
            else if (Nk > 6 && i % Nk === 4) {
                subWord(keySchedule, i);
            }
            keySchedule[offset] ^= keySchedule[prevOffset];
            keySchedule[offset + 1] ^= keySchedule[prevOffset + 1];
            keySchedule[offset + 2] ^= keySchedule[prevOffset + 2];
            keySchedule[offset + 3] ^= keySchedule[prevOffset + 3];
        }
        return keySchedule;
    }
    return {
        setters: [
            function (block_ciper_operator_ts_1_1) {
                block_ciper_operator_ts_1 = block_ciper_operator_ts_1_1;
            }
        ],
        execute: function () {
            SBOX = [
                0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
                0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
                0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
                0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
                0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
                0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
                0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
                0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
                0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
                0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
                0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
                0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
                0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
                0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
                0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
                0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
            ];
            INV_SBOX = [
                0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
                0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
                0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
                0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
                0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
                0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
                0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
                0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
                0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
                0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
                0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
                0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
                0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
                0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
                0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
                0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
            ];
            RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
            AESBlockCiper = class AESBlockCiper {
                constructor(key) {
                    this.keySchedule = keyExpansion(key);
                }
                subBytes(block) {
                    for (let i = 0; i < block.length; i++) {
                        block[i] = SBOX[block[i]];
                    }
                }
                inverseSubBytes(block) {
                    for (let i = 0; i < block.length; i++) {
                        block[i] = INV_SBOX[block[i]];
                    }
                }
                shiftRow(block) {
                    let t = block[1];
                    block[1] = block[5];
                    block[5] = block[9];
                    block[9] = block[13];
                    block[13] = t;
                    t = block[10];
                    block[10] = block[2];
                    block[2] = t;
                    t = block[14];
                    block[14] = block[6];
                    block[6] = t;
                    t = block[15];
                    block[15] = block[11];
                    block[11] = block[7];
                    block[7] = block[3];
                    block[3] = t;
                }
                inverseShiftRow(block) {
                    let t = block[13];
                    block[13] = block[9];
                    block[9] = block[5];
                    block[5] = block[1];
                    block[1] = t;
                    t = block[10];
                    block[10] = block[2];
                    block[2] = t;
                    t = block[14];
                    block[14] = block[6];
                    block[6] = t;
                    t = block[3];
                    block[3] = block[7];
                    block[7] = block[11];
                    block[11] = block[15];
                    block[15] = t;
                }
                addRoundKey(state, round) {
                    for (let i = 0; i < 16; i++) {
                        state[i] ^= this.keySchedule[round * 16 + i];
                    }
                }
                mixColumn(block) {
                    for (let i = 0; i < 4; i++) {
                        const offset = i * 4;
                        const a = [
                            block[offset],
                            block[offset + 1],
                            block[offset + 2],
                            block[offset + 3],
                        ];
                        block[offset] = xtime(a[0], 0x2) ^
                            xtime(a[1], 0x3) ^
                            xtime(a[2], 0x1) ^
                            xtime(a[3], 0x1);
                        block[offset + 1] = xtime(a[0], 0x1) ^
                            xtime(a[1], 0x2) ^
                            xtime(a[2], 0x3) ^
                            xtime(a[3], 0x1);
                        block[offset + 2] = xtime(a[0], 0x1) ^
                            xtime(a[1], 0x1) ^
                            xtime(a[2], 0x2) ^
                            xtime(a[3], 0x3);
                        block[offset + 3] = xtime(a[0], 0x3) ^
                            xtime(a[1], 0x1) ^
                            xtime(a[2], 0x1) ^
                            xtime(a[3], 0x2);
                    }
                }
                inverseMixColumn(block) {
                    for (let i = 0; i < 4; i++) {
                        const offset = i * 4;
                        const a = [
                            block[offset],
                            block[offset + 1],
                            block[offset + 2],
                            block[offset + 3],
                        ];
                        block[offset] = xtime(a[0], 0xe) ^
                            xtime(a[1], 0xb) ^
                            xtime(a[2], 0xd) ^
                            xtime(a[3], 0x9);
                        block[offset + 1] = xtime(a[0], 0x9) ^
                            xtime(a[1], 0xe) ^
                            xtime(a[2], 0xb) ^
                            xtime(a[3], 0xd);
                        block[offset + 2] = xtime(a[0], 0xd) ^
                            xtime(a[1], 0x9) ^
                            xtime(a[2], 0xe) ^
                            xtime(a[3], 0xb);
                        block[offset + 3] = xtime(a[0], 0xb) ^
                            xtime(a[1], 0xd) ^
                            xtime(a[2], 0x9) ^
                            xtime(a[3], 0xe);
                    }
                }
                encrypt(m) {
                    const nb = 4;
                    const nr = this.keySchedule.length / 16 - 1;
                    const state = new Uint8Array(m);
                    this.addRoundKey(state, 0);
                    for (let i = 1; i < nr; i++) {
                        this.subBytes(state);
                        this.shiftRow(state);
                        this.mixColumn(state);
                        this.addRoundKey(state, i);
                    }
                    this.subBytes(state);
                    this.shiftRow(state);
                    this.addRoundKey(state, nr);
                    return state;
                }
                decrypt(m) {
                    const nb = 4;
                    const nr = this.keySchedule.length / 16 - 1;
                    const state = new Uint8Array(m);
                    this.addRoundKey(state, nr);
                    for (let i = nr - 1; i > 0; i--) {
                        this.inverseShiftRow(state);
                        this.inverseSubBytes(state);
                        this.addRoundKey(state, i);
                        this.inverseMixColumn(state);
                    }
                    this.inverseShiftRow(state);
                    this.inverseSubBytes(state);
                    this.addRoundKey(state, 0);
                    return state;
                }
            };
            PureAES = class PureAES {
                constructor(key, config) {
                    this.ciper = new AESBlockCiper(key);
                    this.config = config;
                }
                async encrypt(m) {
                    return block_ciper_operator_ts_1.BlockCiperOperation.encrypt(m, this.ciper, 16, this.config);
                }
                async decrypt(m) {
                    return block_ciper_operator_ts_1.BlockCiperOperation.decrypt(m, this.ciper, 16, this.config);
                }
            };
            exports_130("PureAES", PureAES);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/mod", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/aes_wc", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/aes_js"], function (exports_131, context_131) {
    "use strict";
    var binary_ts_5, aes_wc_ts_1, aes_js_ts_1, AES;
    var __moduleName = context_131 && context_131.id;
    function computeMessage(m) {
        return typeof m === "string" ? new TextEncoder().encode(m) : m;
    }
    return {
        setters: [
            function (binary_ts_5_1) {
                binary_ts_5 = binary_ts_5_1;
            },
            function (aes_wc_ts_1_1) {
                aes_wc_ts_1 = aes_wc_ts_1_1;
            },
            function (aes_js_ts_1_1) {
                aes_js_ts_1 = aes_js_ts_1_1;
            }
        ],
        execute: function () {
            AES = class AES {
                constructor(key, options) {
                    const computedKey = computeMessage(key);
                    const computedOption = {
                        mode: "cbc",
                        ...options,
                        iv: options?.iv ? computeMessage(options.iv) : new Uint8Array(16),
                    };
                    if ([16, 24, 32].indexOf(computedKey.length) < 0) {
                        throw "Invalid key length";
                    }
                    if (crypto.subtle && options?.mode === "cbc") {
                        this.ciper = new aes_wc_ts_1.WebCryptoAES(computedKey, computedOption);
                    }
                    else {
                        this.ciper = new aes_js_ts_1.PureAES(computedKey, computedOption);
                    }
                }
                async encrypt(m) {
                    return new binary_ts_5.RawBinary(await this.ciper.encrypt(computeMessage(m)));
                }
                async decrypt(m) {
                    return new binary_ts_5.RawBinary(await this.ciper.decrypt(computeMessage(m)));
                }
            };
            exports_131("AES", AES);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hmac/mod", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/helper", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hash"], function (exports_132, context_132) {
    "use strict";
    var binary_ts_6, helper_ts_6, hash_ts_5;
    var __moduleName = context_132 && context_132.id;
    function hmac(algorithm, key, data) {
        const blockSize = 64;
        const hasher = hash_ts_5.createHash(algorithm);
        const computedData = typeof data === "string"
            ? new TextEncoder().encode(data)
            : data;
        let computedKey = typeof key === "string"
            ? new TextEncoder().encode(key)
            : key;
        if (computedKey.length > blockSize) {
            computedKey = hasher.update(computedKey).digest();
        }
        if (computedKey.length < blockSize) {
            const tmp = new Uint8Array(blockSize);
            tmp.set(computedKey, 0);
            computedKey = tmp;
        }
        const opad = new Uint8Array(computedKey);
        const ipad = new Uint8Array(computedKey);
        for (let i = 0; i < blockSize; i++) {
            opad[i] = computedKey[i] ^ 0x5c;
            ipad[i] = computedKey[i] ^ 0x36;
        }
        const output = hasher.update(helper_ts_6.concat(opad, hasher.update(helper_ts_6.concat(ipad, computedData)).digest())).digest();
        return new binary_ts_6.RawBinary(output);
    }
    exports_132("hmac", hmac);
    return {
        setters: [
            function (binary_ts_6_1) {
                binary_ts_6 = binary_ts_6_1;
            },
            function (helper_ts_6_1) {
                helper_ts_6 = helper_ts_6_1;
            },
            function (hash_ts_5_1) {
                hash_ts_5 = hash_ts_5_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/otp/totp", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/utility/encode", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hmac/mod", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/binary"], function (exports_133, context_133) {
    "use strict";
    var encode_ts_5, mod_ts_22, binary_ts_7, TOTP;
    var __moduleName = context_133 && context_133.id;
    function numberToByte(n) {
        const a = new Uint8Array(8);
        for (let i = 7; i >= 0; i--) {
            a[i] = n & 0xff;
            n = n >> 8;
        }
        return a;
    }
    function dt(h, digits) {
        let offset = h[h.length - 1] & 0x0f;
        const a = h.slice(offset, offset + 4);
        const code = ((a[0] & 0x7f) << 24) +
            ((a[1] & 0xff) << 16) +
            ((a[2] & 0xff) << 8) +
            (a[3] & 0xff);
        return code % Math.pow(10, digits);
    }
    return {
        setters: [
            function (encode_ts_5_1) {
                encode_ts_5 = encode_ts_5_1;
            },
            function (mod_ts_22_1) {
                mod_ts_22 = mod_ts_22_1;
            },
            function (binary_ts_7_1) {
                binary_ts_7 = binary_ts_7_1;
            }
        ],
        execute: function () {
            TOTP = class TOTP {
                constructor(secret, digits = 6, algorithm = "sha1", period = 30) {
                    this.period = period;
                    this.algorithm = algorithm;
                    this.secret = encode_ts_5.encode.base32(secret);
                    this.secretInBase32 = secret;
                    this.digits = digits;
                }
                static generateSecret(numberOfByte) {
                    const bin = new binary_ts_7.RawBinary(numberOfByte);
                    crypto.getRandomValues(bin);
                    return bin.base32();
                }
                uri(name, issuer) {
                    name = encodeURIComponent(name);
                    issuer = encodeURIComponent(issuer);
                    return `otpauth://totp/${issuer}:${name}?secret=${this.secretInBase32}&period=${this.period}&digits=${this.digits}&algorithm=${this.algorithm.toUpperCase()}&issuer=${issuer}`;
                }
                generate(timestamp = Date.now()) {
                    const c = Math.floor(timestamp / (this.period * 1000));
                    const code = dt(mod_ts_22.hmac(this.algorithm, this.secret, numberToByte(c)), this.digits);
                    return code.toString().padStart(this.digits, "0");
                }
                verify(code, timestamp = Date.now()) {
                    return code === this.generate(timestamp);
                }
            };
            exports_133("TOTP", TOTP);
        }
    };
});
System.register("https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/mod", ["https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/rsa/mod", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/aes/mod", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/hmac/mod", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/otp/totp", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/src/utility/encode"], function (exports_134, context_134) {
    "use strict";
    var __moduleName = context_134 && context_134.id;
    function exportStar_3(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_134(exports);
    }
    return {
        setters: [
            function (mod_ts_23_1) {
                exportStar_3(mod_ts_23_1);
            },
            function (mod_ts_24_1) {
                exportStar_3(mod_ts_24_1);
            },
            function (mod_ts_25_1) {
                exportStar_3(mod_ts_25_1);
            },
            function (totp_ts_1_1) {
                exportStar_3(totp_ts_1_1);
            },
            function (encode_ts_6_1) {
                exportStar_3(encode_ts_6_1);
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.69.0/encoding/base64", [], function (exports_135, context_135) {
    "use strict";
    var __moduleName = context_135 && context_135.id;
    function encode(data) {
        if (typeof data === "string") {
            return btoa(data);
        }
        else {
            const d = new Uint8Array(data);
            let dataString = "";
            for (let i = 0; i < d.length; ++i) {
                dataString += String.fromCharCode(d[i]);
            }
            return btoa(dataString);
        }
    }
    exports_135("encode", encode);
    function decode(data) {
        const binaryString = decodeString(data);
        const binary = new Uint8Array(binaryString.length);
        for (let i = 0; i < binary.length; ++i) {
            binary[i] = binaryString.charCodeAt(i);
        }
        return binary.buffer;
    }
    exports_135("decode", decode);
    function decodeString(data) {
        return atob(data);
    }
    exports_135("decodeString", decodeString);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.69.0/encoding/base64url", ["https://deno.land/std@0.69.0/encoding/base64"], function (exports_136, context_136) {
    "use strict";
    var base64_ts_1;
    var __moduleName = context_136 && context_136.id;
    function addPaddingToBase64url(base64url) {
        if (base64url.length % 4 === 2)
            return base64url + "==";
        if (base64url.length % 4 === 3)
            return base64url + "=";
        if (base64url.length % 4 === 1) {
            throw new TypeError("Illegal base64url string!");
        }
        return base64url;
    }
    exports_136("addPaddingToBase64url", addPaddingToBase64url);
    function convertBase64urlToBase64(base64url) {
        return addPaddingToBase64url(base64url)
            .replace(/\-/g, "+")
            .replace(/_/g, "/");
    }
    function convertBase64ToBase64url(base64) {
        return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function encode(data) {
        return convertBase64ToBase64url(base64_ts_1.encode(data));
    }
    exports_136("encode", encode);
    function decode(data) {
        return base64_ts_1.decode(convertBase64urlToBase64(data));
    }
    exports_136("decode", decode);
    return {
        setters: [
            function (base64_ts_1_1) {
                base64_ts_1 = base64_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/djwt@v1.7/deps", ["https://deno.land/std@0.69.0/encoding/hex", "https://deno.land/std@0.69.0/hash/sha256", "https://deno.land/std@0.69.0/hash/sha512", "https://cdn.jsdelivr.net/gh/invisal/god_crypto@22eb70429c998d84a57e786217c277373fbeca9f/mod", "https://deno.land/std@0.69.0/encoding/base64url"], function (exports_137, context_137) {
    "use strict";
    var __moduleName = context_137 && context_137.id;
    return {
        setters: [
            function (hex_ts_1_1) {
                exports_137({
                    "convertHexToUint8Array": hex_ts_1_1["decodeString"],
                    "convertUint8ArrayToHex": hex_ts_1_1["encodeToString"]
                });
            },
            function (sha256_ts_2_1) {
                exports_137({
                    "HmacSha256": sha256_ts_2_1["HmacSha256"]
                });
            },
            function (sha512_ts_1_1) {
                exports_137({
                    "HmacSha512": sha512_ts_1_1["HmacSha512"]
                });
            },
            function (mod_ts_26_1) {
                exports_137({
                    "RSA": mod_ts_26_1["RSA"]
                });
            },
            function (base64url_ts_2_1) {
                exports_137({
                    "addPaddingToBase64url": base64url_ts_2_1["addPaddingToBase64url"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/djwt@v1.7/base64/base64url", ["https://deno.land/x/djwt@v1.7/base64/base64", "https://deno.land/x/djwt@v1.7/deps"], function (exports_138, context_138) {
    "use strict";
    var base64_ts_2, deps_ts_23;
    var __moduleName = context_138 && context_138.id;
    function convertBase64urlToBase64(base64url) {
        return deps_ts_23.addPaddingToBase64url(base64url).replace(/\-/g, "+").replace(/_/g, "/");
    }
    exports_138("convertBase64urlToBase64", convertBase64urlToBase64);
    function convertBase64ToBase64url(base64) {
        return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    exports_138("convertBase64ToBase64url", convertBase64ToBase64url);
    function convertBase64urlToUint8Array(base64url) {
        return base64_ts_2.convertBase64ToUint8Array(convertBase64urlToBase64(base64url));
    }
    exports_138("convertBase64urlToUint8Array", convertBase64urlToUint8Array);
    function convertUint8ArrayToBase64url(uint8Array) {
        return convertBase64ToBase64url(base64_ts_2.convertUint8ArrayToBase64(uint8Array));
    }
    exports_138("convertUint8ArrayToBase64url", convertUint8ArrayToBase64url);
    return {
        setters: [
            function (base64_ts_2_1) {
                base64_ts_2 = base64_ts_2_1;
            },
            function (deps_ts_23_1) {
                deps_ts_23 = deps_ts_23_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/djwt@v1.7/create", ["https://deno.land/x/djwt@v1.7/base64/base64url", "https://deno.land/x/djwt@v1.7/deps"], function (exports_139, context_139) {
    "use strict";
    var base64url_ts_3, deps_ts_24;
    var __moduleName = context_139 && context_139.id;
    function assertNever(alg, message) {
        throw new RangeError(message);
    }
    exports_139("assertNever", assertNever);
    function setExpiration(exp) {
        return Math.round((exp instanceof Date ? exp.getTime() : Date.now() + exp * 1000) / 1000);
    }
    exports_139("setExpiration", setExpiration);
    function convertHexToBase64url(input) {
        return base64url_ts_3.convertUint8ArrayToBase64url(deps_ts_24.convertHexToUint8Array(input));
    }
    exports_139("convertHexToBase64url", convertHexToBase64url);
    function convertStringToBase64url(input) {
        return base64url_ts_3.convertUint8ArrayToBase64url(new TextEncoder().encode(input));
    }
    exports_139("convertStringToBase64url", convertStringToBase64url);
    function makeSigningInput(header, payload) {
        return `${convertStringToBase64url(JSON.stringify(header))}.${convertStringToBase64url(JSON.stringify(payload))}`;
    }
    async function encrypt(alg, key, msg) {
        switch (alg) {
            case "none":
                return "";
            case "HS256":
                return new deps_ts_24.HmacSha256(key).update(msg).toString();
            case "HS512":
                return new deps_ts_24.HmacSha512(key).update(msg).toString();
            case "RS256":
                return (await new deps_ts_24.RSA(deps_ts_24.RSA.parseKey(key)).sign(msg, { hash: "sha256" })).hex();
            default:
                assertNever(alg, "no matching crypto algorithm in the header: " + alg);
        }
    }
    exports_139("encrypt", encrypt);
    async function makeSignature(alg, key, input) {
        return convertHexToBase64url(await encrypt(alg, key, input));
    }
    exports_139("makeSignature", makeSignature);
    async function makeJwt({ key, header, payload }) {
        try {
            const signingInput = makeSigningInput(header, payload);
            return `${signingInput}.${await makeSignature(header.alg, key, signingInput)}`;
        }
        catch (err) {
            err.message = `Failed to create JWT: ${err.message}`;
            throw err;
        }
    }
    exports_139("makeJwt", makeJwt);
    return {
        setters: [
            function (base64url_ts_3_1) {
                base64url_ts_3 = base64url_ts_3_1;
            },
            function (deps_ts_24_1) {
                deps_ts_24 = deps_ts_24_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/djwt@v1.7/validate", ["https://deno.land/x/djwt@v1.7/create", "https://deno.land/x/djwt@v1.7/base64/base64url", "https://deno.land/x/djwt@v1.7/deps"], function (exports_140, context_140) {
    "use strict";
    var create_ts_1, base64url_ts_4, deps_ts_25, JwtError;
    var __moduleName = context_140 && context_140.id;
    function isObject(obj) {
        return (obj !== null && typeof obj === "object" && Array.isArray(obj) === false);
    }
    exports_140("isObject", isObject);
    function hasProperty(key, x) {
        return key in x;
    }
    exports_140("hasProperty", hasProperty);
    function isExpired(exp, leeway = 0) {
        return exp + leeway < Date.now() / 1000;
    }
    exports_140("isExpired", isExpired);
    function checkHeaderCrit(header, handlers) {
        const reservedWords = new Set([
            "alg",
            "jku",
            "jwk",
            "kid",
            "x5u",
            "x5c",
            "x5t",
            "x5t#S256",
            "typ",
            "cty",
            "crit",
            "enc",
            "zip",
            "epk",
            "apu",
            "apv",
            "iv",
            "tag",
            "p2s",
            "p2c",
        ]);
        if (!Array.isArray(header.crit) ||
            header.crit.some((str) => typeof str !== "string" || !str)) {
            throw Error("header parameter 'crit' must be an array of non-empty strings");
        }
        if (header.crit.some((str) => reservedWords.has(str))) {
            throw Error("the 'crit' list contains a non-extension header parameter");
        }
        if (header.crit.some((str) => typeof header[str] === "undefined" ||
            typeof handlers?.[str] !== "function")) {
            throw Error("critical extension header parameters are not understood");
        }
        return Promise.all(header.crit.map((str) => handlers[str](header[str])));
    }
    exports_140("checkHeaderCrit", checkHeaderCrit);
    function validateJwtObject(maybeJwtObject) {
        if (typeof maybeJwtObject.signature !== "string") {
            throw ReferenceError("the signature is no string");
        }
        if (!(isObject(maybeJwtObject.header) &&
            hasProperty("alg", maybeJwtObject.header) &&
            typeof maybeJwtObject.header.alg === "string")) {
            throw ReferenceError("header parameter 'alg' is not a string");
        }
        if (isObject(maybeJwtObject.payload) &&
            hasProperty("exp", maybeJwtObject.payload)) {
            if (typeof maybeJwtObject.payload.exp !== "number") {
                throw RangeError("claim 'exp' is not a number");
            }
            else if (isExpired(maybeJwtObject.payload.exp, 1)) {
                throw RangeError("the jwt is expired");
            }
        }
        return maybeJwtObject;
    }
    exports_140("validateJwtObject", validateJwtObject);
    async function handleJwtObject(jwtObject, critHandlers) {
        return [
            jwtObject,
            "crit" in jwtObject.header
                ? await checkHeaderCrit(jwtObject.header, critHandlers)
                : undefined,
        ];
    }
    function parseAndDecode(jwt) {
        const parsedArray = jwt
            .split(".")
            .map(base64url_ts_4.convertBase64urlToUint8Array)
            .map((uint8Array, index) => index === 2
            ? deps_ts_25.convertUint8ArrayToHex(uint8Array)
            : JSON.parse(new TextDecoder().decode(uint8Array)));
        if (parsedArray.length !== 3)
            throw TypeError("invalid serialization");
        return {
            header: parsedArray[0],
            payload: parsedArray[1],
            signature: parsedArray[2],
        };
    }
    exports_140("parseAndDecode", parseAndDecode);
    function validateAlgorithm(algorithm, jwtAlg) {
        if (Array.isArray(algorithm)) {
            if (algorithm.length > 1 && algorithm.includes("none")) {
                throw Error("algorithm 'none' must be used alone");
            }
            else
                return algorithm.includes(jwtAlg);
        }
        else {
            return algorithm === jwtAlg;
        }
    }
    async function verifySignature({ signature, key, alg, signingInput, }) {
        switch (alg) {
            case "none":
            case "HS256":
            case "HS512": {
                return signature === (await create_ts_1.encrypt(alg, key, signingInput));
            }
            case "RS256": {
                return await new deps_ts_25.RSA(deps_ts_25.RSA.parseKey(key)).verify(deps_ts_25.convertHexToUint8Array(signature), signingInput, { hash: "sha256" });
            }
            default:
                create_ts_1.assertNever(alg, "no matching crypto alg in the header: " + alg);
        }
    }
    exports_140("verifySignature", verifySignature);
    async function validateJwt({ jwt, key, critHandlers, algorithm, }) {
        try {
            const [oldJwtObject, critResult] = await handleJwtObject(validateJwtObject(parseAndDecode(jwt)), critHandlers);
            if (!validateAlgorithm(algorithm, oldJwtObject.header.alg)) {
                throw Error("no matching algorithm: " + oldJwtObject.header.alg);
            }
            if (!(await verifySignature({
                signature: oldJwtObject.signature,
                key,
                alg: oldJwtObject.header.alg,
                signingInput: jwt.slice(0, jwt.lastIndexOf(".")),
            }))) {
                throw Error("signatures don't match");
            }
            return { ...oldJwtObject, jwt, critResult, isValid: true };
        }
        catch (err) {
            return {
                jwt,
                error: new JwtError(err.message),
                isValid: false,
                isExpired: err.message === "the jwt is expired" ? true : false,
            };
        }
    }
    exports_140("validateJwt", validateJwt);
    return {
        setters: [
            function (create_ts_1_1) {
                create_ts_1 = create_ts_1_1;
            },
            function (base64url_ts_4_1) {
                base64url_ts_4 = base64url_ts_4_1;
            },
            function (deps_ts_25_1) {
                deps_ts_25 = deps_ts_25_1;
            }
        ],
        execute: function () {
            JwtError = class JwtError extends Error {
                constructor(message) {
                    super(message);
                    this.message = message;
                    this.name = this.constructor.name;
                    this.date = new Date();
                }
            };
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/middleware/AuthMiddleware", ["https://deno.land/x/djwt@v1.7/validate", "file:///home/ak/dev/backend/deno_api/practice/config"], function (exports_141, context_141) {
    "use strict";
    var validate_ts_1, config_ts_2, authMiddleware;
    var __moduleName = context_141 && context_141.id;
    return {
        setters: [
            function (validate_ts_1_1) {
                validate_ts_1 = validate_ts_1_1;
            },
            function (config_ts_2_1) {
                config_ts_2 = config_ts_2_1;
            }
        ],
        execute: function () {
            exports_141("authMiddleware", authMiddleware = async (context, next) => {
                let jwt = "";
                if (context.request.headers.get("authorization") &&
                    context.request.headers.get("authorization").split(" ")[0] == "Bearer") {
                    jwt = context.request.headers.get("authorization").split(" ")[1];
                }
                else if (context.request.url.searchParams.get("token")) {
                    jwt = context.request.url.searchParams.get("token");
                }
                else {
                    const body = await context.request.body();
                    const jwtdata = await body.value;
                    if (jwtdata != null && jwtdata.token != null) {
                        jwt = jwtdata.token;
                    }
                }
                if (jwt !== "") {
                    try {
                        validate_ts_1.validateJwt({
                            jwt,
                            key: config_ts_2.key,
                            algorithm: "HS256",
                        });
                        await next();
                    }
                    catch (error) {
                        context.reponse.status = 401;
                        context.reponse.body = {
                            err: "Unauthorised. Token is not valid, try to login again.",
                        };
                    }
                }
                else {
                    context.response.status = 401;
                    context.response.body = {
                        err: "Unauthorised. Please login first.",
                    };
                }
            });
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/routes/CustomerRoute", ["https://deno.land/x/oak@v6.3.1/mod", "file:///home/ak/dev/backend/deno_api/practice/controllers/CustomerController", "file:///home/ak/dev/backend/deno_api/practice/middleware/AuthMiddleware"], function (exports_142, context_142) {
    "use strict";
    var mod_ts_27, CustomerController_ts_1, AuthMiddleware_ts_1, customerRouter, path;
    var __moduleName = context_142 && context_142.id;
    return {
        setters: [
            function (mod_ts_27_1) {
                mod_ts_27 = mod_ts_27_1;
            },
            function (CustomerController_ts_1_1) {
                CustomerController_ts_1 = CustomerController_ts_1_1;
            },
            function (AuthMiddleware_ts_1_1) {
                AuthMiddleware_ts_1 = AuthMiddleware_ts_1_1;
            }
        ],
        execute: function () {
            customerRouter = new mod_ts_27.Router();
            path = "/api/customer/";
            customerRouter.get(path, CustomerController_ts_1.getCustomers)
                .get(path + ":id", CustomerController_ts_1.getCustomer)
                .post(path, AuthMiddleware_ts_1.authMiddleware, CustomerController_ts_1.addCustomer)
                .put(path + ":id", AuthMiddleware_ts_1.authMiddleware, CustomerController_ts_1.updateCustomer)
                .delete(path + ":id", AuthMiddleware_ts_1.authMiddleware, CustomerController_ts_1.deleteCustomer);
            exports_142("default", customerRouter);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/model/User", [], function (exports_143, context_143) {
    "use strict";
    var __moduleName = context_143 && context_143.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.61.0/encoding/utf8", [], function (exports_144, context_144) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_144 && context_144.id;
    function encode(input) {
        return encoder.encode(input);
    }
    exports_144("encode", encode);
    function decode(input) {
        return decoder.decode(input);
    }
    exports_144("decode", decode);
    return {
        setters: [],
        execute: function () {
            exports_144("encoder", encoder = new TextEncoder());
            exports_144("decoder", decoder = new TextDecoder());
        }
    };
});
System.register("https://deno.land/x/bcrypt@v0.2.4/deps", ["https://deno.land/std@0.61.0/encoding/utf8"], function (exports_145, context_145) {
    "use strict";
    var __moduleName = context_145 && context_145.id;
    return {
        setters: [
            function (utf8_ts_5_1) {
                exports_145({
                    "encode": utf8_ts_5_1["encode"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/bcrypt@v0.2.4/src/bcrypt/base64", [], function (exports_146, context_146) {
    "use strict";
    var base64_code, index_64;
    var __moduleName = context_146 && context_146.id;
    function encode(d, len) {
        let off = 0;
        let rs = [];
        let c1 = 0;
        let c2 = 0;
        while (off < len) {
            c1 = d[off++] & 0xff;
            rs.push(base64_code[(c1 >> 2) & 0x3f]);
            c1 = (c1 & 0x03) << 4;
            if (off >= len) {
                rs.push(base64_code[c1 & 0x3f]);
                break;
            }
            c2 = d[off++] & 0xff;
            c1 |= (c2 >> 4) & 0x0f;
            rs.push(base64_code[c1 & 0x3f]);
            c1 = (c2 & 0x0f) << 2;
            if (off >= len) {
                rs.push(base64_code[c1 & 0x3f]);
                break;
            }
            c2 = d[off++] & 0xff;
            c1 |= (c2 >> 6) & 0x03;
            rs.push(base64_code[c1 & 0x3f]);
            rs.push(base64_code[c2 & 0x3f]);
        }
        return rs.join("");
    }
    exports_146("encode", encode);
    function char64(x) {
        if (x.length > 1) {
            throw new Error("Expected a single character");
        }
        let characterAsciiCode = x.charCodeAt(0);
        if (characterAsciiCode < 0 || characterAsciiCode > index_64.length)
            return -1;
        return index_64[characterAsciiCode];
    }
    function decode(s, maxolen) {
        let rs = [];
        let off = 0;
        let slen = s.length;
        let olen = 0;
        let ret;
        let c1, c2, c3, c4, o;
        if (maxolen <= 0)
            throw new Error("Invalid maxolen");
        while (off < slen - 1 && olen < maxolen) {
            c1 = char64(s.charAt(off++));
            c2 = char64(s.charAt(off++));
            if (c1 === -1 || c2 === -1)
                break;
            o = c1 << 2;
            o |= (c2 & 0x30) >> 4;
            rs.push(o);
            if (++olen >= maxolen || off >= slen)
                break;
            c3 = char64(s.charAt(off++));
            if (c3 === -1)
                break;
            o = (c2 & 0x0f) << 4;
            o |= (c3 & 0x3c) >> 2;
            rs.push(o);
            if (++olen >= maxolen || off >= slen)
                break;
            c4 = char64(s.charAt(off++));
            o = (c3 & 0x03) << 6;
            o |= c4;
            rs.push(o);
            ++olen;
        }
        ret = new Uint8Array(olen);
        for (off = 0; off < olen; off++)
            ret[off] = rs[off];
        return ret;
    }
    exports_146("decode", decode);
    return {
        setters: [],
        execute: function () {
            base64_code = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
            index_64 = new Uint8Array([
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                0,
                1,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                -1,
                -1,
                -1,
                -1,
                -1,
                -1,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                -1,
                -1,
                -1,
                -1,
                -1,
            ]);
        }
    };
});
System.register("https://deno.land/x/bcrypt@v0.2.4/src/bcrypt/bcrypt", ["https://deno.land/x/bcrypt@v0.2.4/deps", "https://deno.land/x/bcrypt@v0.2.4/src/bcrypt/base64"], function (exports_147, context_147) {
    "use strict";
    var deps_ts_26, base64, crypto, GENSALT_DEFAULT_LOG2_ROUNDS, BCRYPT_SALT_LEN, BLOWFISH_NUM_ROUNDS, P_orig, S_orig, bf_crypt_ciphertext, P, S;
    var __moduleName = context_147 && context_147.id;
    function encipher(lr, off) {
        let i = 0;
        let n = 0;
        let l = lr[off];
        let r = lr[off + 1];
        l ^= P[0];
        for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;) {
            n = S[(l >> 24) & 0xff];
            n += S[0x100 | ((l >> 16) & 0xff)];
            n ^= S[0x200 | ((l >> 8) & 0xff)];
            n += S[0x300 | (l & 0xff)];
            r ^= n ^ P[++i];
            n = S[(r >> 24) & 0xff];
            n += S[0x100 | ((r >> 16) & 0xff)];
            n ^= S[0x200 | ((r >> 8) & 0xff)];
            n += S[0x300 | (r & 0xff)];
            l ^= n ^ P[++i];
        }
        lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
        lr[off + 1] = l;
    }
    function streamtoword(data, offp) {
        let word = 0;
        let off = offp[0];
        for (let i = 0; i < 4; i++) {
            word = (word << 8) | (data[off] & 0xff);
            off = (off + 1) % data.length;
        }
        offp[0] = off;
        return word;
    }
    function init_key() {
        P = P_orig.slice();
        S = S_orig.slice();
    }
    function key(key) {
        let i;
        let koffp = new Int32Array([0]);
        let lr = new Int32Array([0, 0]);
        let plen = P.length, slen = S.length;
        for (i = 0; i < plen; i++)
            P[i] = P[i] ^ streamtoword(key, koffp);
        for (i = 0; i < plen; i += 2) {
            encipher(lr, 0);
            P[i] = lr[0];
            P[i + 1] = lr[1];
        }
        for (i = 0; i < slen; i += 2) {
            encipher(lr, 0);
            S[i] = lr[0];
            S[i + 1] = lr[1];
        }
    }
    function ekskey(data, key) {
        let i = 0;
        let koffp = new Int32Array([0]);
        let doffp = new Int32Array([0]);
        let lr = new Int32Array([0, 0]);
        let plen = P.length, slen = S.length;
        for (i = 0; i < plen; i++)
            P[i] = P[i] ^ streamtoword(key, koffp);
        for (i = 0; i < plen; i += 2) {
            lr[0] ^= streamtoword(data, doffp);
            lr[1] ^= streamtoword(data, doffp);
            encipher(lr, 0);
            P[i] = lr[0];
            P[i + 1] = lr[1];
        }
        for (i = 0; i < slen; i += 2) {
            lr[0] ^= streamtoword(data, doffp);
            lr[1] ^= streamtoword(data, doffp);
            encipher(lr, 0);
            S[i] = lr[0];
            S[i + 1] = lr[1];
        }
    }
    function crypt_raw(password, salt, log_rounds, cdata) {
        let rounds = 0;
        let i = 0;
        let j = 0;
        let clen = cdata.length;
        let ret;
        if (log_rounds < 4 || log_rounds > 30) {
            throw new Error("Bad number of rounds");
        }
        rounds = 1 << log_rounds;
        if (salt.length !== BCRYPT_SALT_LEN)
            throw new Error("Bad salt length");
        init_key();
        ekskey(salt, password);
        for (i = 0; i !== rounds; i++) {
            key(password);
            key(salt);
        }
        for (i = 0; i < 64; i++) {
            for (j = 0; j < clen >> 1; j++)
                encipher(cdata, j << 1);
        }
        ret = new Uint8Array(clen * 4);
        for (i = 0, j = 0; i < clen; i++) {
            ret[j++] = (cdata[i] >> 24) & 0xff;
            ret[j++] = (cdata[i] >> 16) & 0xff;
            ret[j++] = (cdata[i] >> 8) & 0xff;
            ret[j++] = cdata[i] & 0xff;
        }
        return ret;
    }
    function hashpw(password, salt = gensalt()) {
        let real_salt;
        let passwordb;
        let saltb;
        let hashed;
        let minor = "";
        let rounds = 0;
        let off = 0;
        let rs = [];
        if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
            throw new Error("Invalid salt version");
        }
        if (salt.charAt(2) === "$")
            off = 3;
        else {
            minor = salt.charAt(2);
            if ((minor.charCodeAt(0) >= "a".charCodeAt(0) &&
                minor.charCodeAt(0) >= "z".charCodeAt(0)) ||
                salt.charAt(3) !== "$") {
                throw new Error("Invalid salt revision");
            }
            off = 4;
        }
        if (salt.charAt(off + 2) > "$")
            throw new Error("Missing salt rounds");
        rounds = parseInt(salt.substring(off, off + 2));
        real_salt = salt.substring(off + 3, off + 25);
        passwordb = deps_ts_26.encode(password + (minor.charCodeAt(0) >= "a".charCodeAt(0) ? "\u0000" : ""));
        saltb = base64.decode(real_salt, BCRYPT_SALT_LEN);
        hashed = crypt_raw(passwordb, saltb, rounds, bf_crypt_ciphertext.slice());
        rs.push("$2");
        if (minor.charCodeAt(0) >= "a".charCodeAt(0))
            rs.push(minor);
        rs.push("$");
        if (rounds < 10)
            rs.push("0");
        if (rounds > 30) {
            throw new Error("rounds exceeds maximum (30)");
        }
        rs.push(rounds.toString());
        rs.push("$");
        rs.push(base64.encode(saltb, saltb.length));
        rs.push(base64.encode(hashed, bf_crypt_ciphertext.length * 4 - 1));
        return rs.join("");
    }
    exports_147("hashpw", hashpw);
    function gensalt(log_rounds = GENSALT_DEFAULT_LOG2_ROUNDS) {
        let rs = [];
        let rnd = new Uint8Array(BCRYPT_SALT_LEN);
        crypto.getRandomValues(rnd);
        rs.push("$2a$");
        if (log_rounds < 10)
            rs.push("0");
        if (log_rounds > 30) {
            throw new Error("log_rounds exceeds maximum (30)");
        }
        rs.push(log_rounds.toString());
        rs.push("$");
        rs.push(base64.encode(rnd, rnd.length));
        return rs.join("");
    }
    exports_147("gensalt", gensalt);
    function checkpw(plaintext, hashed) {
        let hashed_bytes;
        let try_bytes;
        let try_pw = hashpw(plaintext, hashed);
        hashed_bytes = deps_ts_26.encode(hashed);
        try_bytes = deps_ts_26.encode(try_pw);
        if (hashed_bytes.length !== try_bytes.length)
            return false;
        let ret = 0;
        for (let i = 0; i < try_bytes.length; i++) {
            ret |= hashed_bytes[i] ^ try_bytes[i];
        }
        return ret === 0;
    }
    exports_147("checkpw", checkpw);
    return {
        setters: [
            function (deps_ts_26_1) {
                deps_ts_26 = deps_ts_26_1;
            },
            function (base64_3) {
                base64 = base64_3;
            }
        ],
        execute: function () {
            crypto = globalThis.crypto;
            GENSALT_DEFAULT_LOG2_ROUNDS = 10;
            BCRYPT_SALT_LEN = 16;
            BLOWFISH_NUM_ROUNDS = 16;
            P_orig = new Int32Array([
                0x243f6a88,
                0x85a308d3,
                0x13198a2e,
                0x03707344,
                0xa4093822,
                0x299f31d0,
                0x082efa98,
                0xec4e6c89,
                0x452821e6,
                0x38d01377,
                0xbe5466cf,
                0x34e90c6c,
                0xc0ac29b7,
                0xc97c50dd,
                0x3f84d5b5,
                0xb5470917,
                0x9216d5d9,
                0x8979fb1b,
            ]);
            S_orig = new Int32Array([
                0xd1310ba6,
                0x98dfb5ac,
                0x2ffd72db,
                0xd01adfb7,
                0xb8e1afed,
                0x6a267e96,
                0xba7c9045,
                0xf12c7f99,
                0x24a19947,
                0xb3916cf7,
                0x0801f2e2,
                0x858efc16,
                0x636920d8,
                0x71574e69,
                0xa458fea3,
                0xf4933d7e,
                0x0d95748f,
                0x728eb658,
                0x718bcd58,
                0x82154aee,
                0x7b54a41d,
                0xc25a59b5,
                0x9c30d539,
                0x2af26013,
                0xc5d1b023,
                0x286085f0,
                0xca417918,
                0xb8db38ef,
                0x8e79dcb0,
                0x603a180e,
                0x6c9e0e8b,
                0xb01e8a3e,
                0xd71577c1,
                0xbd314b27,
                0x78af2fda,
                0x55605c60,
                0xe65525f3,
                0xaa55ab94,
                0x57489862,
                0x63e81440,
                0x55ca396a,
                0x2aab10b6,
                0xb4cc5c34,
                0x1141e8ce,
                0xa15486af,
                0x7c72e993,
                0xb3ee1411,
                0x636fbc2a,
                0x2ba9c55d,
                0x741831f6,
                0xce5c3e16,
                0x9b87931e,
                0xafd6ba33,
                0x6c24cf5c,
                0x7a325381,
                0x28958677,
                0x3b8f4898,
                0x6b4bb9af,
                0xc4bfe81b,
                0x66282193,
                0x61d809cc,
                0xfb21a991,
                0x487cac60,
                0x5dec8032,
                0xef845d5d,
                0xe98575b1,
                0xdc262302,
                0xeb651b88,
                0x23893e81,
                0xd396acc5,
                0x0f6d6ff3,
                0x83f44239,
                0x2e0b4482,
                0xa4842004,
                0x69c8f04a,
                0x9e1f9b5e,
                0x21c66842,
                0xf6e96c9a,
                0x670c9c61,
                0xabd388f0,
                0x6a51a0d2,
                0xd8542f68,
                0x960fa728,
                0xab5133a3,
                0x6eef0b6c,
                0x137a3be4,
                0xba3bf050,
                0x7efb2a98,
                0xa1f1651d,
                0x39af0176,
                0x66ca593e,
                0x82430e88,
                0x8cee8619,
                0x456f9fb4,
                0x7d84a5c3,
                0x3b8b5ebe,
                0xe06f75d8,
                0x85c12073,
                0x401a449f,
                0x56c16aa6,
                0x4ed3aa62,
                0x363f7706,
                0x1bfedf72,
                0x429b023d,
                0x37d0d724,
                0xd00a1248,
                0xdb0fead3,
                0x49f1c09b,
                0x075372c9,
                0x80991b7b,
                0x25d479d8,
                0xf6e8def7,
                0xe3fe501a,
                0xb6794c3b,
                0x976ce0bd,
                0x04c006ba,
                0xc1a94fb6,
                0x409f60c4,
                0x5e5c9ec2,
                0x196a2463,
                0x68fb6faf,
                0x3e6c53b5,
                0x1339b2eb,
                0x3b52ec6f,
                0x6dfc511f,
                0x9b30952c,
                0xcc814544,
                0xaf5ebd09,
                0xbee3d004,
                0xde334afd,
                0x660f2807,
                0x192e4bb3,
                0xc0cba857,
                0x45c8740f,
                0xd20b5f39,
                0xb9d3fbdb,
                0x5579c0bd,
                0x1a60320a,
                0xd6a100c6,
                0x402c7279,
                0x679f25fe,
                0xfb1fa3cc,
                0x8ea5e9f8,
                0xdb3222f8,
                0x3c7516df,
                0xfd616b15,
                0x2f501ec8,
                0xad0552ab,
                0x323db5fa,
                0xfd238760,
                0x53317b48,
                0x3e00df82,
                0x9e5c57bb,
                0xca6f8ca0,
                0x1a87562e,
                0xdf1769db,
                0xd542a8f6,
                0x287effc3,
                0xac6732c6,
                0x8c4f5573,
                0x695b27b0,
                0xbbca58c8,
                0xe1ffa35d,
                0xb8f011a0,
                0x10fa3d98,
                0xfd2183b8,
                0x4afcb56c,
                0x2dd1d35b,
                0x9a53e479,
                0xb6f84565,
                0xd28e49bc,
                0x4bfb9790,
                0xe1ddf2da,
                0xa4cb7e33,
                0x62fb1341,
                0xcee4c6e8,
                0xef20cada,
                0x36774c01,
                0xd07e9efe,
                0x2bf11fb4,
                0x95dbda4d,
                0xae909198,
                0xeaad8e71,
                0x6b93d5a0,
                0xd08ed1d0,
                0xafc725e0,
                0x8e3c5b2f,
                0x8e7594b7,
                0x8ff6e2fb,
                0xf2122b64,
                0x8888b812,
                0x900df01c,
                0x4fad5ea0,
                0x688fc31c,
                0xd1cff191,
                0xb3a8c1ad,
                0x2f2f2218,
                0xbe0e1777,
                0xea752dfe,
                0x8b021fa1,
                0xe5a0cc0f,
                0xb56f74e8,
                0x18acf3d6,
                0xce89e299,
                0xb4a84fe0,
                0xfd13e0b7,
                0x7cc43b81,
                0xd2ada8d9,
                0x165fa266,
                0x80957705,
                0x93cc7314,
                0x211a1477,
                0xe6ad2065,
                0x77b5fa86,
                0xc75442f5,
                0xfb9d35cf,
                0xebcdaf0c,
                0x7b3e89a0,
                0xd6411bd3,
                0xae1e7e49,
                0x00250e2d,
                0x2071b35e,
                0x226800bb,
                0x57b8e0af,
                0x2464369b,
                0xf009b91e,
                0x5563911d,
                0x59dfa6aa,
                0x78c14389,
                0xd95a537f,
                0x207d5ba2,
                0x02e5b9c5,
                0x83260376,
                0x6295cfa9,
                0x11c81968,
                0x4e734a41,
                0xb3472dca,
                0x7b14a94a,
                0x1b510052,
                0x9a532915,
                0xd60f573f,
                0xbc9bc6e4,
                0x2b60a476,
                0x81e67400,
                0x08ba6fb5,
                0x571be91f,
                0xf296ec6b,
                0x2a0dd915,
                0xb6636521,
                0xe7b9f9b6,
                0xff34052e,
                0xc5855664,
                0x53b02d5d,
                0xa99f8fa1,
                0x08ba4799,
                0x6e85076a,
                0x4b7a70e9,
                0xb5b32944,
                0xdb75092e,
                0xc4192623,
                0xad6ea6b0,
                0x49a7df7d,
                0x9cee60b8,
                0x8fedb266,
                0xecaa8c71,
                0x699a17ff,
                0x5664526c,
                0xc2b19ee1,
                0x193602a5,
                0x75094c29,
                0xa0591340,
                0xe4183a3e,
                0x3f54989a,
                0x5b429d65,
                0x6b8fe4d6,
                0x99f73fd6,
                0xa1d29c07,
                0xefe830f5,
                0x4d2d38e6,
                0xf0255dc1,
                0x4cdd2086,
                0x8470eb26,
                0x6382e9c6,
                0x021ecc5e,
                0x09686b3f,
                0x3ebaefc9,
                0x3c971814,
                0x6b6a70a1,
                0x687f3584,
                0x52a0e286,
                0xb79c5305,
                0xaa500737,
                0x3e07841c,
                0x7fdeae5c,
                0x8e7d44ec,
                0x5716f2b8,
                0xb03ada37,
                0xf0500c0d,
                0xf01c1f04,
                0x0200b3ff,
                0xae0cf51a,
                0x3cb574b2,
                0x25837a58,
                0xdc0921bd,
                0xd19113f9,
                0x7ca92ff6,
                0x94324773,
                0x22f54701,
                0x3ae5e581,
                0x37c2dadc,
                0xc8b57634,
                0x9af3dda7,
                0xa9446146,
                0x0fd0030e,
                0xecc8c73e,
                0xa4751e41,
                0xe238cd99,
                0x3bea0e2f,
                0x3280bba1,
                0x183eb331,
                0x4e548b38,
                0x4f6db908,
                0x6f420d03,
                0xf60a04bf,
                0x2cb81290,
                0x24977c79,
                0x5679b072,
                0xbcaf89af,
                0xde9a771f,
                0xd9930810,
                0xb38bae12,
                0xdccf3f2e,
                0x5512721f,
                0x2e6b7124,
                0x501adde6,
                0x9f84cd87,
                0x7a584718,
                0x7408da17,
                0xbc9f9abc,
                0xe94b7d8c,
                0xec7aec3a,
                0xdb851dfa,
                0x63094366,
                0xc464c3d2,
                0xef1c1847,
                0x3215d908,
                0xdd433b37,
                0x24c2ba16,
                0x12a14d43,
                0x2a65c451,
                0x50940002,
                0x133ae4dd,
                0x71dff89e,
                0x10314e55,
                0x81ac77d6,
                0x5f11199b,
                0x043556f1,
                0xd7a3c76b,
                0x3c11183b,
                0x5924a509,
                0xf28fe6ed,
                0x97f1fbfa,
                0x9ebabf2c,
                0x1e153c6e,
                0x86e34570,
                0xeae96fb1,
                0x860e5e0a,
                0x5a3e2ab3,
                0x771fe71c,
                0x4e3d06fa,
                0x2965dcb9,
                0x99e71d0f,
                0x803e89d6,
                0x5266c825,
                0x2e4cc978,
                0x9c10b36a,
                0xc6150eba,
                0x94e2ea78,
                0xa5fc3c53,
                0x1e0a2df4,
                0xf2f74ea7,
                0x361d2b3d,
                0x1939260f,
                0x19c27960,
                0x5223a708,
                0xf71312b6,
                0xebadfe6e,
                0xeac31f66,
                0xe3bc4595,
                0xa67bc883,
                0xb17f37d1,
                0x018cff28,
                0xc332ddef,
                0xbe6c5aa5,
                0x65582185,
                0x68ab9802,
                0xeecea50f,
                0xdb2f953b,
                0x2aef7dad,
                0x5b6e2f84,
                0x1521b628,
                0x29076170,
                0xecdd4775,
                0x619f1510,
                0x13cca830,
                0xeb61bd96,
                0x0334fe1e,
                0xaa0363cf,
                0xb5735c90,
                0x4c70a239,
                0xd59e9e0b,
                0xcbaade14,
                0xeecc86bc,
                0x60622ca7,
                0x9cab5cab,
                0xb2f3846e,
                0x648b1eaf,
                0x19bdf0ca,
                0xa02369b9,
                0x655abb50,
                0x40685a32,
                0x3c2ab4b3,
                0x319ee9d5,
                0xc021b8f7,
                0x9b540b19,
                0x875fa099,
                0x95f7997e,
                0x623d7da8,
                0xf837889a,
                0x97e32d77,
                0x11ed935f,
                0x16681281,
                0x0e358829,
                0xc7e61fd6,
                0x96dedfa1,
                0x7858ba99,
                0x57f584a5,
                0x1b227263,
                0x9b83c3ff,
                0x1ac24696,
                0xcdb30aeb,
                0x532e3054,
                0x8fd948e4,
                0x6dbc3128,
                0x58ebf2ef,
                0x34c6ffea,
                0xfe28ed61,
                0xee7c3c73,
                0x5d4a14d9,
                0xe864b7e3,
                0x42105d14,
                0x203e13e0,
                0x45eee2b6,
                0xa3aaabea,
                0xdb6c4f15,
                0xfacb4fd0,
                0xc742f442,
                0xef6abbb5,
                0x654f3b1d,
                0x41cd2105,
                0xd81e799e,
                0x86854dc7,
                0xe44b476a,
                0x3d816250,
                0xcf62a1f2,
                0x5b8d2646,
                0xfc8883a0,
                0xc1c7b6a3,
                0x7f1524c3,
                0x69cb7492,
                0x47848a0b,
                0x5692b285,
                0x095bbf00,
                0xad19489d,
                0x1462b174,
                0x23820e00,
                0x58428d2a,
                0x0c55f5ea,
                0x1dadf43e,
                0x233f7061,
                0x3372f092,
                0x8d937e41,
                0xd65fecf1,
                0x6c223bdb,
                0x7cde3759,
                0xcbee7460,
                0x4085f2a7,
                0xce77326e,
                0xa6078084,
                0x19f8509e,
                0xe8efd855,
                0x61d99735,
                0xa969a7aa,
                0xc50c06c2,
                0x5a04abfc,
                0x800bcadc,
                0x9e447a2e,
                0xc3453484,
                0xfdd56705,
                0x0e1e9ec9,
                0xdb73dbd3,
                0x105588cd,
                0x675fda79,
                0xe3674340,
                0xc5c43465,
                0x713e38d8,
                0x3d28f89e,
                0xf16dff20,
                0x153e21e7,
                0x8fb03d4a,
                0xe6e39f2b,
                0xdb83adf7,
                0xe93d5a68,
                0x948140f7,
                0xf64c261c,
                0x94692934,
                0x411520f7,
                0x7602d4f7,
                0xbcf46b2e,
                0xd4a20068,
                0xd4082471,
                0x3320f46a,
                0x43b7d4b7,
                0x500061af,
                0x1e39f62e,
                0x97244546,
                0x14214f74,
                0xbf8b8840,
                0x4d95fc1d,
                0x96b591af,
                0x70f4ddd3,
                0x66a02f45,
                0xbfbc09ec,
                0x03bd9785,
                0x7fac6dd0,
                0x31cb8504,
                0x96eb27b3,
                0x55fd3941,
                0xda2547e6,
                0xabca0a9a,
                0x28507825,
                0x530429f4,
                0x0a2c86da,
                0xe9b66dfb,
                0x68dc1462,
                0xd7486900,
                0x680ec0a4,
                0x27a18dee,
                0x4f3ffea2,
                0xe887ad8c,
                0xb58ce006,
                0x7af4d6b6,
                0xaace1e7c,
                0xd3375fec,
                0xce78a399,
                0x406b2a42,
                0x20fe9e35,
                0xd9f385b9,
                0xee39d7ab,
                0x3b124e8b,
                0x1dc9faf7,
                0x4b6d1856,
                0x26a36631,
                0xeae397b2,
                0x3a6efa74,
                0xdd5b4332,
                0x6841e7f7,
                0xca7820fb,
                0xfb0af54e,
                0xd8feb397,
                0x454056ac,
                0xba489527,
                0x55533a3a,
                0x20838d87,
                0xfe6ba9b7,
                0xd096954b,
                0x55a867bc,
                0xa1159a58,
                0xcca92963,
                0x99e1db33,
                0xa62a4a56,
                0x3f3125f9,
                0x5ef47e1c,
                0x9029317c,
                0xfdf8e802,
                0x04272f70,
                0x80bb155c,
                0x05282ce3,
                0x95c11548,
                0xe4c66d22,
                0x48c1133f,
                0xc70f86dc,
                0x07f9c9ee,
                0x41041f0f,
                0x404779a4,
                0x5d886e17,
                0x325f51eb,
                0xd59bc0d1,
                0xf2bcc18f,
                0x41113564,
                0x257b7834,
                0x602a9c60,
                0xdff8e8a3,
                0x1f636c1b,
                0x0e12b4c2,
                0x02e1329e,
                0xaf664fd1,
                0xcad18115,
                0x6b2395e0,
                0x333e92e1,
                0x3b240b62,
                0xeebeb922,
                0x85b2a20e,
                0xe6ba0d99,
                0xde720c8c,
                0x2da2f728,
                0xd0127845,
                0x95b794fd,
                0x647d0862,
                0xe7ccf5f0,
                0x5449a36f,
                0x877d48fa,
                0xc39dfd27,
                0xf33e8d1e,
                0x0a476341,
                0x992eff74,
                0x3a6f6eab,
                0xf4f8fd37,
                0xa812dc60,
                0xa1ebddf8,
                0x991be14c,
                0xdb6e6b0d,
                0xc67b5510,
                0x6d672c37,
                0x2765d43b,
                0xdcd0e804,
                0xf1290dc7,
                0xcc00ffa3,
                0xb5390f92,
                0x690fed0b,
                0x667b9ffb,
                0xcedb7d9c,
                0xa091cf0b,
                0xd9155ea3,
                0xbb132f88,
                0x515bad24,
                0x7b9479bf,
                0x763bd6eb,
                0x37392eb3,
                0xcc115979,
                0x8026e297,
                0xf42e312d,
                0x6842ada7,
                0xc66a2b3b,
                0x12754ccc,
                0x782ef11c,
                0x6a124237,
                0xb79251e7,
                0x06a1bbe6,
                0x4bfb6350,
                0x1a6b1018,
                0x11caedfa,
                0x3d25bdd8,
                0xe2e1c3c9,
                0x44421659,
                0x0a121386,
                0xd90cec6e,
                0xd5abea2a,
                0x64af674e,
                0xda86a85f,
                0xbebfe988,
                0x64e4c3fe,
                0x9dbc8057,
                0xf0f7c086,
                0x60787bf8,
                0x6003604d,
                0xd1fd8346,
                0xf6381fb0,
                0x7745ae04,
                0xd736fccc,
                0x83426b33,
                0xf01eab71,
                0xb0804187,
                0x3c005e5f,
                0x77a057be,
                0xbde8ae24,
                0x55464299,
                0xbf582e61,
                0x4e58f48f,
                0xf2ddfda2,
                0xf474ef38,
                0x8789bdc2,
                0x5366f9c3,
                0xc8b38e74,
                0xb475f255,
                0x46fcd9b9,
                0x7aeb2661,
                0x8b1ddf84,
                0x846a0e79,
                0x915f95e2,
                0x466e598e,
                0x20b45770,
                0x8cd55591,
                0xc902de4c,
                0xb90bace1,
                0xbb8205d0,
                0x11a86248,
                0x7574a99e,
                0xb77f19b6,
                0xe0a9dc09,
                0x662d09a1,
                0xc4324633,
                0xe85a1f02,
                0x09f0be8c,
                0x4a99a025,
                0x1d6efe10,
                0x1ab93d1d,
                0x0ba5a4df,
                0xa186f20f,
                0x2868f169,
                0xdcb7da83,
                0x573906fe,
                0xa1e2ce9b,
                0x4fcd7f52,
                0x50115e01,
                0xa70683fa,
                0xa002b5c4,
                0x0de6d027,
                0x9af88c27,
                0x773f8641,
                0xc3604c06,
                0x61a806b5,
                0xf0177a28,
                0xc0f586e0,
                0x006058aa,
                0x30dc7d62,
                0x11e69ed7,
                0x2338ea63,
                0x53c2dd94,
                0xc2c21634,
                0xbbcbee56,
                0x90bcb6de,
                0xebfc7da1,
                0xce591d76,
                0x6f05e409,
                0x4b7c0188,
                0x39720a3d,
                0x7c927c24,
                0x86e3725f,
                0x724d9db9,
                0x1ac15bb4,
                0xd39eb8fc,
                0xed545578,
                0x08fca5b5,
                0xd83d7cd3,
                0x4dad0fc4,
                0x1e50ef5e,
                0xb161e6f8,
                0xa28514d9,
                0x6c51133c,
                0x6fd5c7e7,
                0x56e14ec4,
                0x362abfce,
                0xddc6c837,
                0xd79a3234,
                0x92638212,
                0x670efa8e,
                0x406000e0,
                0x3a39ce37,
                0xd3faf5cf,
                0xabc27737,
                0x5ac52d1b,
                0x5cb0679e,
                0x4fa33742,
                0xd3822740,
                0x99bc9bbe,
                0xd5118e9d,
                0xbf0f7315,
                0xd62d1c7e,
                0xc700c47b,
                0xb78c1b6b,
                0x21a19045,
                0xb26eb1be,
                0x6a366eb4,
                0x5748ab2f,
                0xbc946e79,
                0xc6a376d2,
                0x6549c2c8,
                0x530ff8ee,
                0x468dde7d,
                0xd5730a1d,
                0x4cd04dc6,
                0x2939bbdb,
                0xa9ba4650,
                0xac9526e8,
                0xbe5ee304,
                0xa1fad5f0,
                0x6a2d519a,
                0x63ef8ce2,
                0x9a86ee22,
                0xc089c2b8,
                0x43242ef6,
                0xa51e03aa,
                0x9cf2d0a4,
                0x83c061ba,
                0x9be96a4d,
                0x8fe51550,
                0xba645bd6,
                0x2826a2f9,
                0xa73a3ae1,
                0x4ba99586,
                0xef5562e9,
                0xc72fefd3,
                0xf752f7da,
                0x3f046f69,
                0x77fa0a59,
                0x80e4a915,
                0x87b08601,
                0x9b09e6ad,
                0x3b3ee593,
                0xe990fd5a,
                0x9e34d797,
                0x2cf0b7d9,
                0x022b8b51,
                0x96d5ac3a,
                0x017da67d,
                0xd1cf3ed6,
                0x7c7d2d28,
                0x1f9f25cf,
                0xadf2b89b,
                0x5ad6b472,
                0x5a88f54c,
                0xe029ac71,
                0xe019a5e6,
                0x47b0acfd,
                0xed93fa9b,
                0xe8d3c48d,
                0x283b57cc,
                0xf8d56629,
                0x79132e28,
                0x785f0191,
                0xed756055,
                0xf7960e44,
                0xe3d35e8c,
                0x15056dd4,
                0x88f46dba,
                0x03a16125,
                0x0564f0bd,
                0xc3eb9e15,
                0x3c9057a2,
                0x97271aec,
                0xa93a072a,
                0x1b3f6d9b,
                0x1e6321f5,
                0xf59c66fb,
                0x26dcf319,
                0x7533d928,
                0xb155fdf5,
                0x03563482,
                0x8aba3cbb,
                0x28517711,
                0xc20ad9f8,
                0xabcc5167,
                0xccad925f,
                0x4de81751,
                0x3830dc8e,
                0x379d5862,
                0x9320f991,
                0xea7a90c2,
                0xfb3e7bce,
                0x5121ce64,
                0x774fbe32,
                0xa8b6e37e,
                0xc3293d46,
                0x48de5369,
                0x6413e680,
                0xa2ae0810,
                0xdd6db224,
                0x69852dfd,
                0x09072166,
                0xb39a460a,
                0x6445c0dd,
                0x586cdecf,
                0x1c20c8ae,
                0x5bbef7dd,
                0x1b588d40,
                0xccd2017f,
                0x6bb4e3bb,
                0xdda26a7e,
                0x3a59ff45,
                0x3e350a44,
                0xbcb4cdd5,
                0x72eacea8,
                0xfa6484bb,
                0x8d6612ae,
                0xbf3c6f47,
                0xd29be463,
                0x542f5d9e,
                0xaec2771b,
                0xf64e6370,
                0x740e0d8d,
                0xe75b1357,
                0xf8721671,
                0xaf537d5d,
                0x4040cb08,
                0x4eb4e2cc,
                0x34d2466a,
                0x0115af84,
                0xe1b00428,
                0x95983a1d,
                0x06b89fb4,
                0xce6ea048,
                0x6f3f3b82,
                0x3520ab82,
                0x011a1d4b,
                0x277227f8,
                0x611560b1,
                0xe7933fdc,
                0xbb3a792b,
                0x344525bd,
                0xa08839e1,
                0x51ce794b,
                0x2f32c9b7,
                0xa01fbac9,
                0xe01cc87e,
                0xbcc7d1f6,
                0xcf0111c3,
                0xa1e8aac7,
                0x1a908749,
                0xd44fbd9a,
                0xd0dadecb,
                0xd50ada38,
                0x0339c32a,
                0xc6913667,
                0x8df9317c,
                0xe0b12b4f,
                0xf79e59b7,
                0x43f5bb3a,
                0xf2d519ff,
                0x27d9459c,
                0xbf97222c,
                0x15e6fc2a,
                0x0f91fc71,
                0x9b941525,
                0xfae59361,
                0xceb69ceb,
                0xc2a86459,
                0x12baa8d1,
                0xb6c1075e,
                0xe3056a0c,
                0x10d25065,
                0xcb03a442,
                0xe0ec6e0e,
                0x1698db3b,
                0x4c98a0be,
                0x3278e964,
                0x9f1f9532,
                0xe0d392df,
                0xd3a0342b,
                0x8971f21e,
                0x1b0a7441,
                0x4ba3348c,
                0xc5be7120,
                0xc37632d8,
                0xdf359f8d,
                0x9b992f2e,
                0xe60b6f47,
                0x0fe3f11d,
                0xe54cda54,
                0x1edad891,
                0xce6279cf,
                0xcd3e7e6f,
                0x1618b166,
                0xfd2c1d05,
                0x848fd2c5,
                0xf6fb2299,
                0xf523f357,
                0xa6327623,
                0x93a83531,
                0x56cccd02,
                0xacf08162,
                0x5a75ebb5,
                0x6e163697,
                0x88d273cc,
                0xde966292,
                0x81b949d0,
                0x4c50901b,
                0x71c65614,
                0xe6c6c7bd,
                0x327a140a,
                0x45e1d006,
                0xc3f27b9a,
                0xc9aa53fd,
                0x62a80f00,
                0xbb25bfe2,
                0x35bdd2f6,
                0x71126905,
                0xb2040222,
                0xb6cbcf7c,
                0xcd769c2b,
                0x53113ec0,
                0x1640e3d3,
                0x38abbd60,
                0x2547adf0,
                0xba38209c,
                0xf746ce76,
                0x77afa1c5,
                0x20756060,
                0x85cbfe4e,
                0x8ae88dd8,
                0x7aaaf9b0,
                0x4cf9aa7e,
                0x1948c25c,
                0x02fb8a8c,
                0x01c36ae4,
                0xd6ebe1f9,
                0x90d4f869,
                0xa65cdea0,
                0x3f09252d,
                0xc208e69f,
                0xb74e6132,
                0xce77e25b,
                0x578fdfe3,
                0x3ac372e6,
            ]);
            bf_crypt_ciphertext = new Int32Array([
                0x4f727068,
                0x65616e42,
                0x65686f6c,
                0x64657253,
                0x63727944,
                0x6f756274,
            ]);
        }
    };
});
System.register("https://deno.land/x/bcrypt@v0.2.4/src/main", ["https://deno.land/x/bcrypt@v0.2.4/src/bcrypt/bcrypt"], function (exports_148, context_148) {
    "use strict";
    var bcrypt;
    var __moduleName = context_148 && context_148.id;
    async function hash(plaintext, salt = undefined) {
        let worker = new Worker(new URL("worker.ts", context_148.meta.url).toString(), { type: "module", deno: true });
        worker.postMessage({
            action: "hash",
            payload: {
                plaintext,
                salt,
            },
        });
        return new Promise((resolve) => {
            worker.onmessage = (event) => {
                resolve(event.data);
                worker.terminate();
            };
        });
    }
    exports_148("hash", hash);
    async function genSalt(log_rounds = undefined) {
        let worker = new Worker(new URL("worker.ts", context_148.meta.url).toString(), { type: "module", deno: true });
        worker.postMessage({
            action: "genSalt",
            payload: {
                log_rounds,
            },
        });
        return new Promise((resolve) => {
            worker.onmessage = (event) => {
                resolve(event.data);
                worker.terminate();
            };
        });
    }
    exports_148("genSalt", genSalt);
    async function compare(plaintext, hash) {
        let worker = new Worker(new URL("worker.ts", context_148.meta.url).toString(), { type: "module", deno: true });
        worker.postMessage({
            action: "compare",
            payload: {
                plaintext,
                hash,
            },
        });
        return new Promise((resolve) => {
            worker.onmessage = (event) => {
                resolve(event.data);
                worker.terminate();
            };
        });
    }
    exports_148("compare", compare);
    function compareSync(plaintext, hash) {
        try {
            return bcrypt.checkpw(plaintext, hash);
        }
        catch {
            return false;
        }
    }
    exports_148("compareSync", compareSync);
    function genSaltSync(log_rounds = undefined) {
        return bcrypt.gensalt(log_rounds);
    }
    exports_148("genSaltSync", genSaltSync);
    function hashSync(plaintext, salt = undefined) {
        return bcrypt.hashpw(plaintext, salt);
    }
    exports_148("hashSync", hashSync);
    return {
        setters: [
            function (bcrypt_1) {
                bcrypt = bcrypt_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/x/bcrypt@v0.2.4/mod", ["https://deno.land/x/bcrypt@v0.2.4/src/main"], function (exports_149, context_149) {
    "use strict";
    var __moduleName = context_149 && context_149.id;
    return {
        setters: [
            function (main_ts_1_1) {
                exports_149({
                    "genSalt": main_ts_1_1["genSalt"],
                    "compare": main_ts_1_1["compare"],
                    "hash": main_ts_1_1["hash"],
                    "genSaltSync": main_ts_1_1["genSaltSync"],
                    "compareSync": main_ts_1_1["compareSync"],
                    "hashSync": main_ts_1_1["hashSync"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/controllers/UserController", ["https://deno.land/x/postgres@v0.4.5/mod", "file:///home/ak/dev/backend/deno_api/practice/config", "https://deno.land/x/bcrypt@v0.2.4/mod"], function (exports_150, context_150) {
    "use strict";
    var mod_ts_28, config_ts_3, bcrypt, client, getUsers, getUser, addUser, updatePassword, deleteUser;
    var __moduleName = context_150 && context_150.id;
    return {
        setters: [
            function (mod_ts_28_1) {
                mod_ts_28 = mod_ts_28_1;
            },
            function (config_ts_3_1) {
                config_ts_3 = config_ts_3_1;
            },
            function (bcrypt_2) {
                bcrypt = bcrypt_2;
            }
        ],
        execute: function () {
            client = new mod_ts_28.Client(config_ts_3.connString);
            getUsers = async ({ response }) => {
                try {
                    await client.connect();
                    const result = await client.query("select * from users");
                    response.status = 200;
                    response.body = result.rows;
                }
                catch (error) {
                    response.status = 500;
                    response.body = { err: error.toString() };
                }
                finally {
                    await client.end();
                }
            };
            exports_150("getUsers", getUsers);
            getUser = async ({ params, response }) => {
                try {
                    await client.connect();
                    const result = await client.query("select * from users where username=$1;", params.name);
                    if (result.rows.toString() == "") {
                        response.status = 404;
                        response.body = {
                            err: "Username:" + params.name +
                                " is not registered.",
                        };
                        return;
                    }
                    else {
                        response.body = result.rows;
                        response.status = 200;
                    }
                }
                catch (error) {
                    response.status = 500;
                    response.body = { err: error.toString() };
                }
            };
            exports_150("getUser", getUser);
            addUser = async ({ request, response }) => {
                const body = await request.body();
                const user = await body.value;
                if (user.username === "" || user.password === "") {
                    response.body = {
                        err: "User & Password cannot be empty",
                    };
                    response.status = 500;
                    return;
                }
                try {
                    const hash = await bcrypt.hash(user.password);
                    await client.connect();
                    const result = await client.query("insert into users values($1,$2)", user.username, hash);
                    response.body = user;
                    response.status = 201;
                }
                catch (error) {
                    console.log(error);
                    response.status = 500;
                    response.body = { err: error.message };
                }
                finally {
                    await client.end();
                }
            };
            exports_150("addUser", addUser);
            updatePassword = async ({ params, request, response }) => {
                await getUser({ params: { "name": params.name }, response });
                if (response.status === 404) {
                    const errMsg = response.body.err;
                    response.body = { err: errMsg };
                    response.status = 404;
                    return;
                }
                else {
                    const body = await request.body();
                    const user = await body.value;
                    const currentHashPwd = response.body[0][1];
                    const isPwdMatch = bcrypt.compare(user.password, currentHashPwd);
                    if (!isPwdMatch) {
                        response.body = { err: "Username/password do not match" };
                        response.status = 404;
                        return;
                    }
                    else {
                        const hash = await bcrypt.hash(user.newpassword);
                        try {
                            await client.connect();
                            const result = await client.query("update users set password=$1 where username=$2", hash, params.name);
                            response.body = { msg: "Password has been changes." };
                            response.status = 200;
                        }
                        catch (error) {
                            console.log(error);
                            response.status = 500;
                            response.body = { err: error.messgae };
                        }
                        finally {
                            await client.end();
                        }
                    }
                }
            };
            exports_150("updatePassword", updatePassword);
            deleteUser = async ({ params, response }) => {
                await getUser({ params: { "name": params.name }, response });
                if (response.status === 404) {
                    const errMsg = response.body.err;
                    response.status = 404;
                    response.body = { err: errMsg };
                    return;
                }
                try {
                    await client.connect();
                    const result = await client.query("delete from users where username=$1", params.name);
                    response.body = {
                        msg: "Username " + params.name + " had been deleted.",
                    };
                    response.status = 204;
                }
                catch (error) {
                    response.status = 500;
                    response.body = { err: error.message };
                }
                finally {
                    client.end();
                }
            };
            exports_150("deleteUser", deleteUser);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/routes/UserRoute", ["https://deno.land/x/oak@v6.3.1/mod", "file:///home/ak/dev/backend/deno_api/practice/controllers/UserController"], function (exports_151, context_151) {
    "use strict";
    var mod_ts_29, UserController_ts_1, userRouter, path;
    var __moduleName = context_151 && context_151.id;
    return {
        setters: [
            function (mod_ts_29_1) {
                mod_ts_29 = mod_ts_29_1;
            },
            function (UserController_ts_1_1) {
                UserController_ts_1 = UserController_ts_1_1;
            }
        ],
        execute: function () {
            userRouter = new mod_ts_29.Router();
            path = "/api/user/";
            userRouter
                .get(path, UserController_ts_1.getUsers)
                .get(path + ":name", UserController_ts_1.getUser)
                .post(path, UserController_ts_1.addUser)
                .put(path + ":name", UserController_ts_1.updatePassword)
                .delete(path + ":name", UserController_ts_1.deleteUser);
            exports_151("default", userRouter);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/controllers/TokenController", ["https://deno.land/x/djwt@v1.7/create", "file:///home/ak/dev/backend/deno_api/practice/config", "file:///home/ak/dev/backend/deno_api/practice/controllers/UserController", "https://deno.land/x/bcrypt@v0.2.4/mod"], function (exports_152, context_152) {
    "use strict";
    var create_ts_2, config_ts_4, UserController_ts_2, bcrypt, getToken;
    var __moduleName = context_152 && context_152.id;
    return {
        setters: [
            function (create_ts_2_1) {
                create_ts_2 = create_ts_2_1;
            },
            function (config_ts_4_1) {
                config_ts_4 = config_ts_4_1;
            },
            function (UserController_ts_2_1) {
                UserController_ts_2 = UserController_ts_2_1;
            },
            function (bcrypt_3) {
                bcrypt = bcrypt_3;
            }
        ],
        execute: function () {
            exports_152("getToken", getToken = async ({ request, response }) => {
                const body = await request.body();
                try {
                    const user = await body.value;
                    await UserController_ts_2.getUser({ params: { "name": user.username }, response });
                    if (response.status === 404) {
                        const errMsg = response.body.err;
                        response.body = { err: errMsg };
                        response.status = 404;
                        return;
                    }
                    else {
                        const currentHashPwd = response.body[0][1];
                        const isPwdMatch = bcrypt.compare(user.password, currentHashPwd);
                        if (!isPwdMatch) {
                            response.body = {
                                err: "Username / password do not match",
                            };
                            response.status = 404;
                            return;
                        }
                        else {
                            const payload = {
                                iss: user.username,
                                exp: create_ts_2.setExpiration(new Date("2020-12-31")),
                            };
                            const header = {
                                alg: "HS256",
                                type: "JWT",
                            };
                            const jwt = await create_ts_2.makeJwt({ header, payload, key: config_ts_4.key });
                            response.body = { token: jwt, username: payload.iss };
                            response.status = 200;
                        }
                    }
                }
                catch (error) {
                    console.log(error);
                    response.status = 500;
                    response.body = { err: error.toString() };
                }
            });
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/routes/TokenRoute", ["https://deno.land/x/oak@v6.3.1/mod", "file:///home/ak/dev/backend/deno_api/practice/controllers/TokenController"], function (exports_153, context_153) {
    "use strict";
    var mod_ts_30, TokenController_ts_1, tokenRouter;
    var __moduleName = context_153 && context_153.id;
    return {
        setters: [
            function (mod_ts_30_1) {
                mod_ts_30 = mod_ts_30_1;
            },
            function (TokenController_ts_1_1) {
                TokenController_ts_1 = TokenController_ts_1_1;
            }
        ],
        execute: function () {
            tokenRouter = new mod_ts_30.Router();
            tokenRouter.post("/auth/", TokenController_ts_1.getToken);
            exports_153("default", tokenRouter);
        }
    };
});
System.register("file:///home/ak/dev/backend/deno_api/practice/index", ["https://deno.land/std@0.74.0/fmt/colors", "file:///home/ak/dev/backend/deno_api/practice/routes/HomeRoute", "https://deno.land/x/oak@v6.3.1/mod", "file:///home/ak/dev/backend/deno_api/practice/controllers/NotFoundController", "file:///home/ak/dev/backend/deno_api/practice/routes/CustomerRoute", "file:///home/ak/dev/backend/deno_api/practice/routes/UserRoute", "file:///home/ak/dev/backend/deno_api/practice/routes/TokenRoute"], function (exports_154, context_154) {
    "use strict";
    var colors_ts_2, HomeRoute_ts_1, mod_ts_31, NotFoundController_ts_1, CustomerRoute_ts_1, UserRoute_ts_1, TokenRoute_ts_1, app, env, HOST, PORT;
    var __moduleName = context_154 && context_154.id;
    return {
        setters: [
            function (colors_ts_2_1) {
                colors_ts_2 = colors_ts_2_1;
            },
            function (HomeRoute_ts_1_1) {
                HomeRoute_ts_1 = HomeRoute_ts_1_1;
            },
            function (mod_ts_31_1) {
                mod_ts_31 = mod_ts_31_1;
            },
            function (NotFoundController_ts_1_1) {
                NotFoundController_ts_1 = NotFoundController_ts_1_1;
            },
            function (CustomerRoute_ts_1_1) {
                CustomerRoute_ts_1 = CustomerRoute_ts_1_1;
            },
            function (UserRoute_ts_1_1) {
                UserRoute_ts_1 = UserRoute_ts_1_1;
            },
            function (TokenRoute_ts_1_1) {
                TokenRoute_ts_1 = TokenRoute_ts_1_1;
            }
        ],
        execute: async function () {
            app = new mod_ts_31.Application();
            env = Deno.env.toObject();
            HOST = env.HOST || "127.0.0.1";
            PORT = env.PORT || 8180;
            app.use(HomeRoute_ts_1.default.routes());
            app.use(CustomerRoute_ts_1.default.routes());
            app.use(UserRoute_ts_1.default.routes());
            app.use(TokenRoute_ts_1.default.routes());
            console.log(colors_ts_2.bgBlue(colors_ts_2.bold(colors_ts_2.green(`${HOST} ${PORT}`))));
            app.use(NotFoundController_ts_1.default);
            await app.listen(`${HOST}:${PORT}`);
        }
    };
});

await __instantiate("file:///home/ak/dev/backend/deno_api/practice/index", true);
